# coding: utf-8

"""
    Assets - Deadlock API

     ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_ 

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from assets_deadlock_api_client.models.hero_colors_v2 import HeroColorsV2
from assets_deadlock_api_client.models.hero_description_v2 import HeroDescriptionV2
from assets_deadlock_api_client.models.hero_images_v2 import HeroImagesV2
from assets_deadlock_api_client.models.hero_level_info_v2 import HeroLevelInfoV2
from assets_deadlock_api_client.models.hero_physics_v2 import HeroPhysicsV2
from assets_deadlock_api_client.models.hero_shop_stat_display_v2 import HeroShopStatDisplayV2
from assets_deadlock_api_client.models.hero_starting_stats_v2 import HeroStartingStatsV2
from assets_deadlock_api_client.models.hero_type_v2 import HeroTypeV2
from assets_deadlock_api_client.models.raw_hero_item_slot_info_value_v2 import RawHeroItemSlotInfoValueV2
from assets_deadlock_api_client.models.raw_hero_map_mod_cost_bonuses_v2 import RawHeroMapModCostBonusesV2
from assets_deadlock_api_client.models.raw_hero_purchase_bonus_v2 import RawHeroPurchaseBonusV2
from assets_deadlock_api_client.models.raw_hero_scaling_stat_v2 import RawHeroScalingStatV2
from assets_deadlock_api_client.models.raw_hero_stats_display_v2 import RawHeroStatsDisplayV2
from assets_deadlock_api_client.models.raw_hero_stats_uiv2 import RawHeroStatsUIV2
from typing import Optional, Set
from typing_extensions import Self

class HeroV2(BaseModel):
    """
    HeroV2
    """ # noqa: E501
    id: StrictInt
    class_name: StrictStr
    name: StrictStr
    description: HeroDescriptionV2
    recommended_upgrades: Optional[List[StrictStr]] = None
    recommended_ability_order: Optional[List[StrictStr]] = None
    player_selectable: StrictBool
    disabled: StrictBool
    in_development: StrictBool
    needs_testing: StrictBool
    assigned_players_only: StrictBool
    tags: Optional[List[StrictStr]] = None
    gun_tag: Optional[StrictStr] = None
    hideout_rich_presence: Optional[StrictStr] = None
    hero_type: Optional[HeroTypeV2] = None
    prerelease_only: Optional[StrictBool] = None
    limited_testing: StrictBool
    complexity: StrictInt
    skin: StrictInt
    images: HeroImagesV2
    items: Dict[str, StrictStr]
    starting_stats: HeroStartingStatsV2
    item_slot_info: Dict[str, RawHeroItemSlotInfoValueV2]
    physics: HeroPhysicsV2
    colors: HeroColorsV2
    shop_stat_display: HeroShopStatDisplayV2
    cost_bonuses: Optional[Dict[str, List[RawHeroMapModCostBonusesV2]]] = None
    stats_display: RawHeroStatsDisplayV2
    hero_stats_ui: RawHeroStatsUIV2
    level_info: Dict[str, HeroLevelInfoV2]
    scaling_stats: Dict[str, RawHeroScalingStatV2]
    purchase_bonuses: Dict[str, List[RawHeroPurchaseBonusV2]]
    standard_level_up_upgrades: Dict[str, Union[StrictFloat, StrictInt]]
    __properties: ClassVar[List[str]] = ["id", "class_name", "name", "description", "recommended_upgrades", "recommended_ability_order", "player_selectable", "disabled", "in_development", "needs_testing", "assigned_players_only", "tags", "gun_tag", "hideout_rich_presence", "hero_type", "prerelease_only", "limited_testing", "complexity", "skin", "images", "items", "starting_stats", "item_slot_info", "physics", "colors", "shop_stat_display", "cost_bonuses", "stats_display", "hero_stats_ui", "level_info", "scaling_stats", "purchase_bonuses", "standard_level_up_upgrades"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of HeroV2 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of description
        if self.description:
            _dict['description'] = self.description.to_dict()
        # override the default output from pydantic by calling `to_dict()` of images
        if self.images:
            _dict['images'] = self.images.to_dict()
        # override the default output from pydantic by calling `to_dict()` of starting_stats
        if self.starting_stats:
            _dict['starting_stats'] = self.starting_stats.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in item_slot_info (dict)
        _field_dict = {}
        if self.item_slot_info:
            for _key_item_slot_info in self.item_slot_info:
                if self.item_slot_info[_key_item_slot_info]:
                    _field_dict[_key_item_slot_info] = self.item_slot_info[_key_item_slot_info].to_dict()
            _dict['item_slot_info'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of physics
        if self.physics:
            _dict['physics'] = self.physics.to_dict()
        # override the default output from pydantic by calling `to_dict()` of colors
        if self.colors:
            _dict['colors'] = self.colors.to_dict()
        # override the default output from pydantic by calling `to_dict()` of shop_stat_display
        if self.shop_stat_display:
            _dict['shop_stat_display'] = self.shop_stat_display.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in cost_bonuses (dict of array)
        _field_dict_of_array = {}
        if self.cost_bonuses:
            for _key_cost_bonuses in self.cost_bonuses:
                if self.cost_bonuses[_key_cost_bonuses] is not None:
                    _field_dict_of_array[_key_cost_bonuses] = [
                        _item.to_dict() for _item in self.cost_bonuses[_key_cost_bonuses]
                    ]
            _dict['cost_bonuses'] = _field_dict_of_array
        # override the default output from pydantic by calling `to_dict()` of stats_display
        if self.stats_display:
            _dict['stats_display'] = self.stats_display.to_dict()
        # override the default output from pydantic by calling `to_dict()` of hero_stats_ui
        if self.hero_stats_ui:
            _dict['hero_stats_ui'] = self.hero_stats_ui.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each value in level_info (dict)
        _field_dict = {}
        if self.level_info:
            for _key_level_info in self.level_info:
                if self.level_info[_key_level_info]:
                    _field_dict[_key_level_info] = self.level_info[_key_level_info].to_dict()
            _dict['level_info'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in scaling_stats (dict)
        _field_dict = {}
        if self.scaling_stats:
            for _key_scaling_stats in self.scaling_stats:
                if self.scaling_stats[_key_scaling_stats]:
                    _field_dict[_key_scaling_stats] = self.scaling_stats[_key_scaling_stats].to_dict()
            _dict['scaling_stats'] = _field_dict
        # override the default output from pydantic by calling `to_dict()` of each value in purchase_bonuses (dict of array)
        _field_dict_of_array = {}
        if self.purchase_bonuses:
            for _key_purchase_bonuses in self.purchase_bonuses:
                if self.purchase_bonuses[_key_purchase_bonuses] is not None:
                    _field_dict_of_array[_key_purchase_bonuses] = [
                        _item.to_dict() for _item in self.purchase_bonuses[_key_purchase_bonuses]
                    ]
            _dict['purchase_bonuses'] = _field_dict_of_array
        # set to None if recommended_upgrades (nullable) is None
        # and model_fields_set contains the field
        if self.recommended_upgrades is None and "recommended_upgrades" in self.model_fields_set:
            _dict['recommended_upgrades'] = None

        # set to None if recommended_ability_order (nullable) is None
        # and model_fields_set contains the field
        if self.recommended_ability_order is None and "recommended_ability_order" in self.model_fields_set:
            _dict['recommended_ability_order'] = None

        # set to None if tags (nullable) is None
        # and model_fields_set contains the field
        if self.tags is None and "tags" in self.model_fields_set:
            _dict['tags'] = None

        # set to None if gun_tag (nullable) is None
        # and model_fields_set contains the field
        if self.gun_tag is None and "gun_tag" in self.model_fields_set:
            _dict['gun_tag'] = None

        # set to None if hideout_rich_presence (nullable) is None
        # and model_fields_set contains the field
        if self.hideout_rich_presence is None and "hideout_rich_presence" in self.model_fields_set:
            _dict['hideout_rich_presence'] = None

        # set to None if hero_type (nullable) is None
        # and model_fields_set contains the field
        if self.hero_type is None and "hero_type" in self.model_fields_set:
            _dict['hero_type'] = None

        # set to None if prerelease_only (nullable) is None
        # and model_fields_set contains the field
        if self.prerelease_only is None and "prerelease_only" in self.model_fields_set:
            _dict['prerelease_only'] = None

        # set to None if cost_bonuses (nullable) is None
        # and model_fields_set contains the field
        if self.cost_bonuses is None and "cost_bonuses" in self.model_fields_set:
            _dict['cost_bonuses'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of HeroV2 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "class_name": obj.get("class_name"),
            "name": obj.get("name"),
            "description": HeroDescriptionV2.from_dict(obj["description"]) if obj.get("description") is not None else None,
            "recommended_upgrades": obj.get("recommended_upgrades"),
            "recommended_ability_order": obj.get("recommended_ability_order"),
            "player_selectable": obj.get("player_selectable"),
            "disabled": obj.get("disabled"),
            "in_development": obj.get("in_development"),
            "needs_testing": obj.get("needs_testing"),
            "assigned_players_only": obj.get("assigned_players_only"),
            "tags": obj.get("tags"),
            "gun_tag": obj.get("gun_tag"),
            "hideout_rich_presence": obj.get("hideout_rich_presence"),
            "hero_type": obj.get("hero_type"),
            "prerelease_only": obj.get("prerelease_only"),
            "limited_testing": obj.get("limited_testing"),
            "complexity": obj.get("complexity"),
            "skin": obj.get("skin"),
            "images": HeroImagesV2.from_dict(obj["images"]) if obj.get("images") is not None else None,
            "items": obj.get("items"),
            "starting_stats": HeroStartingStatsV2.from_dict(obj["starting_stats"]) if obj.get("starting_stats") is not None else None,
            "item_slot_info": dict(
                (_k, RawHeroItemSlotInfoValueV2.from_dict(_v))
                for _k, _v in obj["item_slot_info"].items()
            )
            if obj.get("item_slot_info") is not None
            else None,
            "physics": HeroPhysicsV2.from_dict(obj["physics"]) if obj.get("physics") is not None else None,
            "colors": HeroColorsV2.from_dict(obj["colors"]) if obj.get("colors") is not None else None,
            "shop_stat_display": HeroShopStatDisplayV2.from_dict(obj["shop_stat_display"]) if obj.get("shop_stat_display") is not None else None,
            "cost_bonuses": dict(
                (_k,
                        [RawHeroMapModCostBonusesV2.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("cost_bonuses", {}).items()
            ),
            "stats_display": RawHeroStatsDisplayV2.from_dict(obj["stats_display"]) if obj.get("stats_display") is not None else None,
            "hero_stats_ui": RawHeroStatsUIV2.from_dict(obj["hero_stats_ui"]) if obj.get("hero_stats_ui") is not None else None,
            "level_info": dict(
                (_k, HeroLevelInfoV2.from_dict(_v))
                for _k, _v in obj["level_info"].items()
            )
            if obj.get("level_info") is not None
            else None,
            "scaling_stats": dict(
                (_k, RawHeroScalingStatV2.from_dict(_v))
                for _k, _v in obj["scaling_stats"].items()
            )
            if obj.get("scaling_stats") is not None
            else None,
            "purchase_bonuses": dict(
                (_k,
                        [RawHeroPurchaseBonusV2.from_dict(_item) for _item in _v]
                        if _v is not None
                        else None
                )
                for _k, _v in obj.get("purchase_bonuses", {}).items()
            ),
            "standard_level_up_upgrades": obj.get("standard_level_up_upgrades")
        })
        return _obj


