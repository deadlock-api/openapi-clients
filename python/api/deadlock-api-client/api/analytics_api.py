# coding: utf-8

"""
    Deadlock API

     ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         

    The version of the OpenAPI document: 0.1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Dict, List, Optional
from typing_extensions import Annotated
from deadlock-api-client.models.analytics_ability_order_stats import AnalyticsAbilityOrderStats
from deadlock-api-client.models.analytics_hero_stats import AnalyticsHeroStats
from deadlock-api-client.models.build_item_stats import BuildItemStats
from deadlock-api-client.models.entry import Entry
from deadlock-api-client.models.hash_map_value import HashMapValue
from deadlock-api-client.models.hero_comb_stats import HeroCombStats
from deadlock-api-client.models.hero_counter_stats import HeroCounterStats
from deadlock-api-client.models.hero_synergy_stats import HeroSynergyStats
from deadlock-api-client.models.item_permutation_stats import ItemPermutationStats
from deadlock-api-client.models.item_stats import ItemStats

from deadlock-api-client.api_client import ApiClient, RequestSerialized
from deadlock-api-client.api_response import ApiResponse
from deadlock-api-client.rest import RESTResponseType


class AnalyticsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def ability_order_stats(
        self,
        hero_id: Annotated[int, Field(strict=True, ge=0, description="See more: <https://assets.deadlock-api.com/v2/heroes>")],
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_ability_upgrades: Annotated[Optional[Annotated[int, Field(le=16, strict=True, ge=0)]], Field(description="Filter players based on their minimum number of ability upgrades over the whole match.")] = None,
        max_ability_upgrades: Annotated[Optional[Annotated[int, Field(le=16, strict=True, ge=1)]], Field(description="Filter players based on their maximum number of ability upgrades over the whole match.")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for an ability order to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AnalyticsAbilityOrderStats]:
        """Ability Order Stats

         Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param hero_id: See more: <https://assets.deadlock-api.com/v2/heroes> (required)
        :type hero_id: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_ability_upgrades: Filter players based on their minimum number of ability upgrades over the whole match.
        :type min_ability_upgrades: int
        :param max_ability_upgrades: Filter players based on their maximum number of ability upgrades over the whole match.
        :type max_ability_upgrades: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param min_matches: The minimum number of matches played for an ability order to be included in the response.
        :type min_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ability_order_stats_serialize(
            hero_id=hero_id,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_ability_upgrades=min_ability_upgrades,
            max_ability_upgrades=max_ability_upgrades,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            min_matches=min_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AnalyticsAbilityOrderStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ability_order_stats_with_http_info(
        self,
        hero_id: Annotated[int, Field(strict=True, ge=0, description="See more: <https://assets.deadlock-api.com/v2/heroes>")],
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_ability_upgrades: Annotated[Optional[Annotated[int, Field(le=16, strict=True, ge=0)]], Field(description="Filter players based on their minimum number of ability upgrades over the whole match.")] = None,
        max_ability_upgrades: Annotated[Optional[Annotated[int, Field(le=16, strict=True, ge=1)]], Field(description="Filter players based on their maximum number of ability upgrades over the whole match.")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for an ability order to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AnalyticsAbilityOrderStats]]:
        """Ability Order Stats

         Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param hero_id: See more: <https://assets.deadlock-api.com/v2/heroes> (required)
        :type hero_id: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_ability_upgrades: Filter players based on their minimum number of ability upgrades over the whole match.
        :type min_ability_upgrades: int
        :param max_ability_upgrades: Filter players based on their maximum number of ability upgrades over the whole match.
        :type max_ability_upgrades: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param min_matches: The minimum number of matches played for an ability order to be included in the response.
        :type min_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ability_order_stats_serialize(
            hero_id=hero_id,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_ability_upgrades=min_ability_upgrades,
            max_ability_upgrades=max_ability_upgrades,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            min_matches=min_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AnalyticsAbilityOrderStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ability_order_stats_without_preload_content(
        self,
        hero_id: Annotated[int, Field(strict=True, ge=0, description="See more: <https://assets.deadlock-api.com/v2/heroes>")],
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_ability_upgrades: Annotated[Optional[Annotated[int, Field(le=16, strict=True, ge=0)]], Field(description="Filter players based on their minimum number of ability upgrades over the whole match.")] = None,
        max_ability_upgrades: Annotated[Optional[Annotated[int, Field(le=16, strict=True, ge=1)]], Field(description="Filter players based on their maximum number of ability upgrades over the whole match.")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for an ability order to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ability Order Stats

         Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param hero_id: See more: <https://assets.deadlock-api.com/v2/heroes> (required)
        :type hero_id: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_ability_upgrades: Filter players based on their minimum number of ability upgrades over the whole match.
        :type min_ability_upgrades: int
        :param max_ability_upgrades: Filter players based on their maximum number of ability upgrades over the whole match.
        :type max_ability_upgrades: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param min_matches: The minimum number of matches played for an ability order to be included in the response.
        :type min_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ability_order_stats_serialize(
            hero_id=hero_id,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_ability_upgrades=min_ability_upgrades,
            max_ability_upgrades=max_ability_upgrades,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            min_matches=min_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AnalyticsAbilityOrderStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ability_order_stats_serialize(
        self,
        hero_id,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_ability_upgrades,
        max_ability_upgrades,
        min_networth,
        max_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        min_matches,
        account_id,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if hero_id is not None:
            
            _query_params.append(('hero_id', hero_id))
            
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_ability_upgrades is not None:
            
            _query_params.append(('min_ability_upgrades', min_ability_upgrades))
            
        if max_ability_upgrades is not None:
            
            _query_params.append(('max_ability_upgrades', max_ability_upgrades))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if min_matches is not None:
            
            _query_params.append(('min_matches', min_matches))
            
        if account_id is not None:
            
            _query_params.append(('account_id', account_id))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/ability-order-stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def build_item_stats(
        self,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter builds based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_last_updated_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_last_updated_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter builds based on their last updated time (Unix timestamp).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[BuildItemStats]:
        """Build Item Stats

         Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param hero_id: Filter builds based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_last_updated_unix_timestamp: Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
        :type min_last_updated_unix_timestamp: int
        :param max_last_updated_unix_timestamp: Filter builds based on their last updated time (Unix timestamp).
        :type max_last_updated_unix_timestamp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build_item_stats_serialize(
            hero_id=hero_id,
            min_last_updated_unix_timestamp=min_last_updated_unix_timestamp,
            max_last_updated_unix_timestamp=max_last_updated_unix_timestamp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BuildItemStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def build_item_stats_with_http_info(
        self,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter builds based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_last_updated_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_last_updated_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter builds based on their last updated time (Unix timestamp).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[BuildItemStats]]:
        """Build Item Stats

         Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param hero_id: Filter builds based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_last_updated_unix_timestamp: Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
        :type min_last_updated_unix_timestamp: int
        :param max_last_updated_unix_timestamp: Filter builds based on their last updated time (Unix timestamp).
        :type max_last_updated_unix_timestamp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build_item_stats_serialize(
            hero_id=hero_id,
            min_last_updated_unix_timestamp=min_last_updated_unix_timestamp,
            max_last_updated_unix_timestamp=max_last_updated_unix_timestamp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BuildItemStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def build_item_stats_without_preload_content(
        self,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter builds based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_last_updated_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_last_updated_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter builds based on their last updated time (Unix timestamp).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Build Item Stats

         Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param hero_id: Filter builds based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_last_updated_unix_timestamp: Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
        :type min_last_updated_unix_timestamp: int
        :param max_last_updated_unix_timestamp: Filter builds based on their last updated time (Unix timestamp).
        :type max_last_updated_unix_timestamp: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._build_item_stats_serialize(
            hero_id=hero_id,
            min_last_updated_unix_timestamp=min_last_updated_unix_timestamp,
            max_last_updated_unix_timestamp=max_last_updated_unix_timestamp,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[BuildItemStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _build_item_stats_serialize(
        self,
        hero_id,
        min_last_updated_unix_timestamp,
        max_last_updated_unix_timestamp,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if hero_id is not None:
            
            _query_params.append(('hero_id', hero_id))
            
        if min_last_updated_unix_timestamp is not None:
            
            _query_params.append(('min_last_updated_unix_timestamp', min_last_updated_unix_timestamp))
            
        if max_last_updated_unix_timestamp is not None:
            
            _query_params.append(('max_last_updated_unix_timestamp', max_last_updated_unix_timestamp))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/build-item-stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def hero_comb_stats(
        self,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        include_hero_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of hero ids to include. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        exclude_hero_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of hero ids to exclude. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a hero combination to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        comb_size: Annotated[Optional[Annotated[int, Field(le=6, strict=True, ge=2)]], Field(description="The combination size to return.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[HeroCombStats]:
        """Hero Comb Stats

         Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param include_hero_ids: Comma separated list of hero ids to include. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type include_hero_ids: List[int]
        :param exclude_hero_ids: Comma separated list of hero ids to exclude. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type exclude_hero_ids: List[int]
        :param min_matches: The minimum number of matches played for a hero combination to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param comb_size: The combination size to return.
        :type comb_size: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_comb_stats_serialize(
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            include_hero_ids=include_hero_ids,
            exclude_hero_ids=exclude_hero_ids,
            min_matches=min_matches,
            max_matches=max_matches,
            comb_size=comb_size,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[HeroCombStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def hero_comb_stats_with_http_info(
        self,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        include_hero_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of hero ids to include. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        exclude_hero_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of hero ids to exclude. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a hero combination to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        comb_size: Annotated[Optional[Annotated[int, Field(le=6, strict=True, ge=2)]], Field(description="The combination size to return.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[HeroCombStats]]:
        """Hero Comb Stats

         Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param include_hero_ids: Comma separated list of hero ids to include. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type include_hero_ids: List[int]
        :param exclude_hero_ids: Comma separated list of hero ids to exclude. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type exclude_hero_ids: List[int]
        :param min_matches: The minimum number of matches played for a hero combination to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param comb_size: The combination size to return.
        :type comb_size: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_comb_stats_serialize(
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            include_hero_ids=include_hero_ids,
            exclude_hero_ids=exclude_hero_ids,
            min_matches=min_matches,
            max_matches=max_matches,
            comb_size=comb_size,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[HeroCombStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def hero_comb_stats_without_preload_content(
        self,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        include_hero_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of hero ids to include. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        exclude_hero_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of hero ids to exclude. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a hero combination to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        comb_size: Annotated[Optional[Annotated[int, Field(le=6, strict=True, ge=2)]], Field(description="The combination size to return.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Hero Comb Stats

         Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param include_hero_ids: Comma separated list of hero ids to include. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type include_hero_ids: List[int]
        :param exclude_hero_ids: Comma separated list of hero ids to exclude. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type exclude_hero_ids: List[int]
        :param min_matches: The minimum number of matches played for a hero combination to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param comb_size: The combination size to return.
        :type comb_size: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_comb_stats_serialize(
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            include_hero_ids=include_hero_ids,
            exclude_hero_ids=exclude_hero_ids,
            min_matches=min_matches,
            max_matches=max_matches,
            comb_size=comb_size,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[HeroCombStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _hero_comb_stats_serialize(
        self,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_networth,
        max_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        include_hero_ids,
        exclude_hero_ids,
        min_matches,
        max_matches,
        comb_size,
        account_id,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'include_hero_ids': 'multi',
            'exclude_hero_ids': 'multi',
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if include_hero_ids is not None:
            
            _query_params.append(('include_hero_ids', include_hero_ids))
            
        if exclude_hero_ids is not None:
            
            _query_params.append(('exclude_hero_ids', exclude_hero_ids))
            
        if min_matches is not None:
            
            _query_params.append(('min_matches', min_matches))
            
        if max_matches is not None:
            
            _query_params.append(('max_matches', max_matches))
            
        if comb_size is not None:
            
            _query_params.append(('comb_size', comb_size))
            
        if account_id is not None:
            
            _query_params.append(('account_id', account_id))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/hero-comb-stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def hero_counters_stats(
        self,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_enemy_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter enemy players based on their net worth.")] = None,
        max_enemy_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter enemy players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        same_lane_filter: Annotated[Optional[StrictBool], Field(description="When `true`, only considers matchups where both `hero_id` and `enemy_hero_id` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a hero combination to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[HeroCounterStats]:
        """Hero Counter Stats

         Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_enemy_networth: Filter enemy players based on their net worth.
        :type min_enemy_networth: int
        :param max_enemy_networth: Filter enemy players based on their net worth.
        :type max_enemy_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param same_lane_filter: When `true`, only considers matchups where both `hero_id` and `enemy_hero_id` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
        :type same_lane_filter: bool
        :param min_matches: The minimum number of matches played for a hero combination to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_counters_stats_serialize(
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_enemy_networth=min_enemy_networth,
            max_enemy_networth=max_enemy_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            same_lane_filter=same_lane_filter,
            min_matches=min_matches,
            max_matches=max_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[HeroCounterStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def hero_counters_stats_with_http_info(
        self,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_enemy_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter enemy players based on their net worth.")] = None,
        max_enemy_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter enemy players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        same_lane_filter: Annotated[Optional[StrictBool], Field(description="When `true`, only considers matchups where both `hero_id` and `enemy_hero_id` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a hero combination to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[HeroCounterStats]]:
        """Hero Counter Stats

         Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_enemy_networth: Filter enemy players based on their net worth.
        :type min_enemy_networth: int
        :param max_enemy_networth: Filter enemy players based on their net worth.
        :type max_enemy_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param same_lane_filter: When `true`, only considers matchups where both `hero_id` and `enemy_hero_id` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
        :type same_lane_filter: bool
        :param min_matches: The minimum number of matches played for a hero combination to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_counters_stats_serialize(
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_enemy_networth=min_enemy_networth,
            max_enemy_networth=max_enemy_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            same_lane_filter=same_lane_filter,
            min_matches=min_matches,
            max_matches=max_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[HeroCounterStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def hero_counters_stats_without_preload_content(
        self,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_enemy_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter enemy players based on their net worth.")] = None,
        max_enemy_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter enemy players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        same_lane_filter: Annotated[Optional[StrictBool], Field(description="When `true`, only considers matchups where both `hero_id` and `enemy_hero_id` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a hero combination to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Hero Counter Stats

         Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_enemy_networth: Filter enemy players based on their net worth.
        :type min_enemy_networth: int
        :param max_enemy_networth: Filter enemy players based on their net worth.
        :type max_enemy_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param same_lane_filter: When `true`, only considers matchups where both `hero_id` and `enemy_hero_id` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
        :type same_lane_filter: bool
        :param min_matches: The minimum number of matches played for a hero combination to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_counters_stats_serialize(
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_enemy_networth=min_enemy_networth,
            max_enemy_networth=max_enemy_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            same_lane_filter=same_lane_filter,
            min_matches=min_matches,
            max_matches=max_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[HeroCounterStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _hero_counters_stats_serialize(
        self,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_networth,
        max_networth,
        min_enemy_networth,
        max_enemy_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        same_lane_filter,
        min_matches,
        max_matches,
        account_id,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_enemy_networth is not None:
            
            _query_params.append(('min_enemy_networth', min_enemy_networth))
            
        if max_enemy_networth is not None:
            
            _query_params.append(('max_enemy_networth', max_enemy_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if same_lane_filter is not None:
            
            _query_params.append(('same_lane_filter', same_lane_filter))
            
        if min_matches is not None:
            
            _query_params.append(('min_matches', min_matches))
            
        if max_matches is not None:
            
            _query_params.append(('max_matches', max_matches))
            
        if account_id is not None:
            
            _query_params.append(('account_id', account_id))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/hero-counter-stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def hero_scoreboard(
        self,
        sort_by: Annotated[StrictStr, Field(description="The field to sort by.")],
        sort_direction: Annotated[Optional[StrictStr], Field(description="The direction to sort heroes in.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter by min number of matches played.")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Entry]:
        """Hero Scoreboard

         This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param sort_by: The field to sort by. (required)
        :type sort_by: str
        :param sort_direction: The direction to sort heroes in.
        :type sort_direction: str
        :param min_matches: Filter by min number of matches played.
        :type min_matches: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_scoreboard_serialize(
            sort_by=sort_by,
            sort_direction=sort_direction,
            min_matches=min_matches,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Entry]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def hero_scoreboard_with_http_info(
        self,
        sort_by: Annotated[StrictStr, Field(description="The field to sort by.")],
        sort_direction: Annotated[Optional[StrictStr], Field(description="The direction to sort heroes in.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter by min number of matches played.")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Entry]]:
        """Hero Scoreboard

         This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param sort_by: The field to sort by. (required)
        :type sort_by: str
        :param sort_direction: The direction to sort heroes in.
        :type sort_direction: str
        :param min_matches: Filter by min number of matches played.
        :type min_matches: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_scoreboard_serialize(
            sort_by=sort_by,
            sort_direction=sort_direction,
            min_matches=min_matches,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Entry]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def hero_scoreboard_without_preload_content(
        self,
        sort_by: Annotated[StrictStr, Field(description="The field to sort by.")],
        sort_direction: Annotated[Optional[StrictStr], Field(description="The direction to sort heroes in.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter by min number of matches played.")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Hero Scoreboard

         This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param sort_by: The field to sort by. (required)
        :type sort_by: str
        :param sort_direction: The direction to sort heroes in.
        :type sort_direction: str
        :param min_matches: Filter by min number of matches played.
        :type min_matches: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_scoreboard_serialize(
            sort_by=sort_by,
            sort_direction=sort_direction,
            min_matches=min_matches,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Entry]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _hero_scoreboard_serialize(
        self,
        sort_by,
        sort_direction,
        min_matches,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_networth,
        max_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        account_id,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_direction is not None:
            
            _query_params.append(('sort_direction', sort_direction))
            
        if min_matches is not None:
            
            _query_params.append(('min_matches', min_matches))
            
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if account_id is not None:
            
            _query_params.append(('account_id', account_id))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/scoreboards/heroes',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def hero_stats(
        self,
        bucket: Annotated[Optional[StrictStr], Field(description="Bucket allows you to group the stats by a specific field.")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        min_hero_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on the number of matches they have played with a specific hero.")] = None,
        max_hero_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on the number of matches they have played with a specific hero.")] = None,
        include_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        exclude_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AnalyticsHeroStats]:
        """Hero Stats

         Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param bucket: Bucket allows you to group the stats by a specific field.
        :type bucket: str
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param min_hero_matches: Filter players based on the number of matches they have played with a specific hero.
        :type min_hero_matches: int
        :param max_hero_matches: Filter players based on the number of matches they have played with a specific hero.
        :type max_hero_matches: int
        :param include_item_ids: Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type include_item_ids: List[int]
        :param exclude_item_ids: Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type exclude_item_ids: List[int]
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_stats_serialize(
            bucket=bucket,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            min_hero_matches=min_hero_matches,
            max_hero_matches=max_hero_matches,
            include_item_ids=include_item_ids,
            exclude_item_ids=exclude_item_ids,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AnalyticsHeroStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def hero_stats_with_http_info(
        self,
        bucket: Annotated[Optional[StrictStr], Field(description="Bucket allows you to group the stats by a specific field.")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        min_hero_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on the number of matches they have played with a specific hero.")] = None,
        max_hero_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on the number of matches they have played with a specific hero.")] = None,
        include_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        exclude_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AnalyticsHeroStats]]:
        """Hero Stats

         Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param bucket: Bucket allows you to group the stats by a specific field.
        :type bucket: str
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param min_hero_matches: Filter players based on the number of matches they have played with a specific hero.
        :type min_hero_matches: int
        :param max_hero_matches: Filter players based on the number of matches they have played with a specific hero.
        :type max_hero_matches: int
        :param include_item_ids: Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type include_item_ids: List[int]
        :param exclude_item_ids: Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type exclude_item_ids: List[int]
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_stats_serialize(
            bucket=bucket,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            min_hero_matches=min_hero_matches,
            max_hero_matches=max_hero_matches,
            include_item_ids=include_item_ids,
            exclude_item_ids=exclude_item_ids,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AnalyticsHeroStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def hero_stats_without_preload_content(
        self,
        bucket: Annotated[Optional[StrictStr], Field(description="Bucket allows you to group the stats by a specific field.")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        min_hero_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on the number of matches they have played with a specific hero.")] = None,
        max_hero_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on the number of matches they have played with a specific hero.")] = None,
        include_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        exclude_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Hero Stats

         Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param bucket: Bucket allows you to group the stats by a specific field.
        :type bucket: str
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param min_hero_matches: Filter players based on the number of matches they have played with a specific hero.
        :type min_hero_matches: int
        :param max_hero_matches: Filter players based on the number of matches they have played with a specific hero.
        :type max_hero_matches: int
        :param include_item_ids: Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type include_item_ids: List[int]
        :param exclude_item_ids: Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type exclude_item_ids: List[int]
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_stats_serialize(
            bucket=bucket,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            min_hero_matches=min_hero_matches,
            max_hero_matches=max_hero_matches,
            include_item_ids=include_item_ids,
            exclude_item_ids=exclude_item_ids,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AnalyticsHeroStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _hero_stats_serialize(
        self,
        bucket,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_networth,
        max_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        min_hero_matches,
        max_hero_matches,
        include_item_ids,
        exclude_item_ids,
        account_id,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'include_item_ids': 'multi',
            'exclude_item_ids': 'multi',
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if min_hero_matches is not None:
            
            _query_params.append(('min_hero_matches', min_hero_matches))
            
        if max_hero_matches is not None:
            
            _query_params.append(('max_hero_matches', max_hero_matches))
            
        if include_item_ids is not None:
            
            _query_params.append(('include_item_ids', include_item_ids))
            
        if exclude_item_ids is not None:
            
            _query_params.append(('exclude_item_ids', exclude_item_ids))
            
        if account_id is not None:
            
            _query_params.append(('account_id', account_id))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/hero-stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def hero_synergies_stats(
        self,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        same_lane_filter: Annotated[Optional[StrictBool], Field(description="When `true`, only considers matchups where both `hero_id1` and `hero_id2` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.")] = None,
        same_party_filter: Annotated[Optional[StrictBool], Field(description="When `true`, only considers matchups where both `hero_id` and `hero_id2` were on the same party. When `false`, considers all matchups regardless of party affiliation.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a hero combination to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[HeroSynergyStats]:
        """Hero Synergy Stats

         Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param same_lane_filter: When `true`, only considers matchups where both `hero_id1` and `hero_id2` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
        :type same_lane_filter: bool
        :param same_party_filter: When `true`, only considers matchups where both `hero_id` and `hero_id2` were on the same party. When `false`, considers all matchups regardless of party affiliation.
        :type same_party_filter: bool
        :param min_matches: The minimum number of matches played for a hero combination to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_synergies_stats_serialize(
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            same_lane_filter=same_lane_filter,
            same_party_filter=same_party_filter,
            min_matches=min_matches,
            max_matches=max_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[HeroSynergyStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def hero_synergies_stats_with_http_info(
        self,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        same_lane_filter: Annotated[Optional[StrictBool], Field(description="When `true`, only considers matchups where both `hero_id1` and `hero_id2` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.")] = None,
        same_party_filter: Annotated[Optional[StrictBool], Field(description="When `true`, only considers matchups where both `hero_id` and `hero_id2` were on the same party. When `false`, considers all matchups regardless of party affiliation.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a hero combination to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[HeroSynergyStats]]:
        """Hero Synergy Stats

         Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param same_lane_filter: When `true`, only considers matchups where both `hero_id1` and `hero_id2` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
        :type same_lane_filter: bool
        :param same_party_filter: When `true`, only considers matchups where both `hero_id` and `hero_id2` were on the same party. When `false`, considers all matchups regardless of party affiliation.
        :type same_party_filter: bool
        :param min_matches: The minimum number of matches played for a hero combination to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_synergies_stats_serialize(
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            same_lane_filter=same_lane_filter,
            same_party_filter=same_party_filter,
            min_matches=min_matches,
            max_matches=max_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[HeroSynergyStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def hero_synergies_stats_without_preload_content(
        self,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        same_lane_filter: Annotated[Optional[StrictBool], Field(description="When `true`, only considers matchups where both `hero_id1` and `hero_id2` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.")] = None,
        same_party_filter: Annotated[Optional[StrictBool], Field(description="When `true`, only considers matchups where both `hero_id` and `hero_id2` were on the same party. When `false`, considers all matchups regardless of party affiliation.")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a hero combination to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Hero Synergy Stats

         Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param same_lane_filter: When `true`, only considers matchups where both `hero_id1` and `hero_id2` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
        :type same_lane_filter: bool
        :param same_party_filter: When `true`, only considers matchups where both `hero_id` and `hero_id2` were on the same party. When `false`, considers all matchups regardless of party affiliation.
        :type same_party_filter: bool
        :param min_matches: The minimum number of matches played for a hero combination to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._hero_synergies_stats_serialize(
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            same_lane_filter=same_lane_filter,
            same_party_filter=same_party_filter,
            min_matches=min_matches,
            max_matches=max_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[HeroSynergyStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _hero_synergies_stats_serialize(
        self,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_networth,
        max_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        same_lane_filter,
        same_party_filter,
        min_matches,
        max_matches,
        account_id,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if same_lane_filter is not None:
            
            _query_params.append(('same_lane_filter', same_lane_filter))
            
        if same_party_filter is not None:
            
            _query_params.append(('same_party_filter', same_party_filter))
            
        if min_matches is not None:
            
            _query_params.append(('min_matches', min_matches))
            
        if max_matches is not None:
            
            _query_params.append(('max_matches', max_matches))
            
        if account_id is not None:
            
            _query_params.append(('account_id', account_id))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/hero-synergy-stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def item_permutation_stats(
        self,
        item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids. See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        comb_size: Annotated[Optional[Annotated[int, Field(le=12, strict=True, ge=2)]], Field(description="The combination size to return.")] = None,
        hero_ids: Annotated[Optional[StrictStr], Field(description="Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ItemPermutationStats]:
        """Item Permutation Stats

         Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param item_ids: Comma separated list of item ids. See more: <https://assets.deadlock-api.com/v2/items>
        :type item_ids: List[int]
        :param comb_size: The combination size to return.
        :type comb_size: int
        :param hero_ids: Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_ids: str
        :param hero_id: Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._item_permutation_stats_serialize(
            item_ids=item_ids,
            comb_size=comb_size,
            hero_ids=hero_ids,
            hero_id=hero_id,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ItemPermutationStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def item_permutation_stats_with_http_info(
        self,
        item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids. See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        comb_size: Annotated[Optional[Annotated[int, Field(le=12, strict=True, ge=2)]], Field(description="The combination size to return.")] = None,
        hero_ids: Annotated[Optional[StrictStr], Field(description="Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ItemPermutationStats]]:
        """Item Permutation Stats

         Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param item_ids: Comma separated list of item ids. See more: <https://assets.deadlock-api.com/v2/items>
        :type item_ids: List[int]
        :param comb_size: The combination size to return.
        :type comb_size: int
        :param hero_ids: Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_ids: str
        :param hero_id: Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._item_permutation_stats_serialize(
            item_ids=item_ids,
            comb_size=comb_size,
            hero_ids=hero_ids,
            hero_id=hero_id,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ItemPermutationStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def item_permutation_stats_without_preload_content(
        self,
        item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids. See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        comb_size: Annotated[Optional[Annotated[int, Field(le=12, strict=True, ge=2)]], Field(description="The combination size to return.")] = None,
        hero_ids: Annotated[Optional[StrictStr], Field(description="Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Item Permutation Stats

         Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param item_ids: Comma separated list of item ids. See more: <https://assets.deadlock-api.com/v2/items>
        :type item_ids: List[int]
        :param comb_size: The combination size to return.
        :type comb_size: int
        :param hero_ids: Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_ids: str
        :param hero_id: Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._item_permutation_stats_serialize(
            item_ids=item_ids,
            comb_size=comb_size,
            hero_ids=hero_ids,
            hero_id=hero_id,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ItemPermutationStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _item_permutation_stats_serialize(
        self,
        item_ids,
        comb_size,
        hero_ids,
        hero_id,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_networth,
        max_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        account_id,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'item_ids': 'multi',
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if item_ids is not None:
            
            _query_params.append(('item_ids', item_ids))
            
        if comb_size is not None:
            
            _query_params.append(('comb_size', comb_size))
            
        if hero_ids is not None:
            
            _query_params.append(('hero_ids', hero_ids))
            
        if hero_id is not None:
            
            _query_params.append(('hero_id', hero_id))
            
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if account_id is not None:
            
            _query_params.append(('account_id', account_id))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/item-permutation-stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def item_stats(
        self,
        bucket: Annotated[Optional[StrictStr], Field(description="Bucket allows you to group the stats by a specific field.")] = None,
        hero_ids: Annotated[Optional[StrictStr], Field(description="Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        include_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to include. See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        exclude_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to exclude. See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for an item to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ItemStats]:
        """Item Stats

         Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param bucket: Bucket allows you to group the stats by a specific field.
        :type bucket: str
        :param hero_ids: Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_ids: str
        :param hero_id: Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param include_item_ids: Comma separated list of item ids to include. See more: <https://assets.deadlock-api.com/v2/items>
        :type include_item_ids: List[int]
        :param exclude_item_ids: Comma separated list of item ids to exclude. See more: <https://assets.deadlock-api.com/v2/items>
        :type exclude_item_ids: List[int]
        :param min_matches: The minimum number of matches played for an item to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._item_stats_serialize(
            bucket=bucket,
            hero_ids=hero_ids,
            hero_id=hero_id,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            include_item_ids=include_item_ids,
            exclude_item_ids=exclude_item_ids,
            min_matches=min_matches,
            max_matches=max_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ItemStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def item_stats_with_http_info(
        self,
        bucket: Annotated[Optional[StrictStr], Field(description="Bucket allows you to group the stats by a specific field.")] = None,
        hero_ids: Annotated[Optional[StrictStr], Field(description="Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        include_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to include. See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        exclude_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to exclude. See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for an item to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ItemStats]]:
        """Item Stats

         Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param bucket: Bucket allows you to group the stats by a specific field.
        :type bucket: str
        :param hero_ids: Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_ids: str
        :param hero_id: Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param include_item_ids: Comma separated list of item ids to include. See more: <https://assets.deadlock-api.com/v2/items>
        :type include_item_ids: List[int]
        :param exclude_item_ids: Comma separated list of item ids to exclude. See more: <https://assets.deadlock-api.com/v2/items>
        :type exclude_item_ids: List[int]
        :param min_matches: The minimum number of matches played for an item to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._item_stats_serialize(
            bucket=bucket,
            hero_ids=hero_ids,
            hero_id=hero_id,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            include_item_ids=include_item_ids,
            exclude_item_ids=exclude_item_ids,
            min_matches=min_matches,
            max_matches=max_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ItemStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def item_stats_without_preload_content(
        self,
        bucket: Annotated[Optional[StrictStr], Field(description="Bucket allows you to group the stats by a specific field.")] = None,
        hero_ids: Annotated[Optional[StrictStr], Field(description="Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        include_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to include. See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        exclude_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to exclude. See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for an item to be included in the response.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        account_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter for matches with a specific player account ID.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Item Stats

         Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param bucket: Bucket allows you to group the stats by a specific field.
        :type bucket: str
        :param hero_ids: Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_ids: str
        :param hero_id: Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param include_item_ids: Comma separated list of item ids to include. See more: <https://assets.deadlock-api.com/v2/items>
        :type include_item_ids: List[int]
        :param exclude_item_ids: Comma separated list of item ids to exclude. See more: <https://assets.deadlock-api.com/v2/items>
        :type exclude_item_ids: List[int]
        :param min_matches: The minimum number of matches played for an item to be included in the response.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param account_id: Filter for matches with a specific player account ID.
        :type account_id: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._item_stats_serialize(
            bucket=bucket,
            hero_ids=hero_ids,
            hero_id=hero_id,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            include_item_ids=include_item_ids,
            exclude_item_ids=exclude_item_ids,
            min_matches=min_matches,
            max_matches=max_matches,
            account_id=account_id,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ItemStats]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _item_stats_serialize(
        self,
        bucket,
        hero_ids,
        hero_id,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_networth,
        max_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        include_item_ids,
        exclude_item_ids,
        min_matches,
        max_matches,
        account_id,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'include_item_ids': 'multi',
            'exclude_item_ids': 'multi',
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if bucket is not None:
            
            _query_params.append(('bucket', bucket))
            
        if hero_ids is not None:
            
            _query_params.append(('hero_ids', hero_ids))
            
        if hero_id is not None:
            
            _query_params.append(('hero_id', hero_id))
            
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if include_item_ids is not None:
            
            _query_params.append(('include_item_ids', include_item_ids))
            
        if exclude_item_ids is not None:
            
            _query_params.append(('exclude_item_ids', exclude_item_ids))
            
        if min_matches is not None:
            
            _query_params.append(('min_matches', min_matches))
            
        if max_matches is not None:
            
            _query_params.append(('max_matches', max_matches))
            
        if account_id is not None:
            
            _query_params.append(('account_id', account_id))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/item-stats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def player_scoreboard(
        self,
        sort_by: Annotated[StrictStr, Field(description="The field to sort by.")],
        sort_direction: Annotated[Optional[StrictStr], Field(description="The direction to sort players in.")] = None,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a player to be included in the scoreboard.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        start: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset to start fetching players from.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="The maximum number of players to fetch.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Entry]:
        """Player Scoreboard

         This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param sort_by: The field to sort by. (required)
        :type sort_by: str
        :param sort_direction: The direction to sort players in.
        :type sort_direction: str
        :param hero_id: Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_matches: The minimum number of matches played for a player to be included in the scoreboard.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param start: The offset to start fetching players from.
        :type start: int
        :param limit: The maximum number of players to fetch.
        :type limit: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._player_scoreboard_serialize(
            sort_by=sort_by,
            sort_direction=sort_direction,
            hero_id=hero_id,
            min_matches=min_matches,
            max_matches=max_matches,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            start=start,
            limit=limit,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Entry]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def player_scoreboard_with_http_info(
        self,
        sort_by: Annotated[StrictStr, Field(description="The field to sort by.")],
        sort_direction: Annotated[Optional[StrictStr], Field(description="The direction to sort players in.")] = None,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a player to be included in the scoreboard.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        start: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset to start fetching players from.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="The maximum number of players to fetch.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Entry]]:
        """Player Scoreboard

         This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param sort_by: The field to sort by. (required)
        :type sort_by: str
        :param sort_direction: The direction to sort players in.
        :type sort_direction: str
        :param hero_id: Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_matches: The minimum number of matches played for a player to be included in the scoreboard.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param start: The offset to start fetching players from.
        :type start: int
        :param limit: The maximum number of players to fetch.
        :type limit: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._player_scoreboard_serialize(
            sort_by=sort_by,
            sort_direction=sort_direction,
            hero_id=hero_id,
            min_matches=min_matches,
            max_matches=max_matches,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            start=start,
            limit=limit,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Entry]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def player_scoreboard_without_preload_content(
        self,
        sort_by: Annotated[StrictStr, Field(description="The field to sort by.")],
        sort_direction: Annotated[Optional[StrictStr], Field(description="The direction to sort players in.")] = None,
        hero_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The minimum number of matches played for a player to be included in the scoreboard.")] = None,
        max_matches: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="The maximum number of matches played for a hero combination to be included in the response.")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        start: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The offset to start fetching players from.")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="The maximum number of players to fetch.")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Player Scoreboard

         This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param sort_by: The field to sort by. (required)
        :type sort_by: str
        :param sort_direction: The direction to sort players in.
        :type sort_direction: str
        :param hero_id: Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_id: int
        :param min_matches: The minimum number of matches played for a player to be included in the scoreboard.
        :type min_matches: int
        :param max_matches: The maximum number of matches played for a hero combination to be included in the response.
        :type max_matches: int
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param start: The offset to start fetching players from.
        :type start: int
        :param limit: The maximum number of players to fetch.
        :type limit: int
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._player_scoreboard_serialize(
            sort_by=sort_by,
            sort_direction=sort_direction,
            hero_id=hero_id,
            min_matches=min_matches,
            max_matches=max_matches,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            start=start,
            limit=limit,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Entry]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _player_scoreboard_serialize(
        self,
        sort_by,
        sort_direction,
        hero_id,
        min_matches,
        max_matches,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_networth,
        max_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        start,
        limit,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_direction is not None:
            
            _query_params.append(('sort_direction', sort_direction))
            
        if hero_id is not None:
            
            _query_params.append(('hero_id', hero_id))
            
        if min_matches is not None:
            
            _query_params.append(('min_matches', min_matches))
            
        if max_matches is not None:
            
            _query_params.append(('max_matches', max_matches))
            
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/scoreboards/players',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def player_stats_metrics(
        self,
        hero_ids: Annotated[Optional[StrictStr], Field(description="Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        include_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        exclude_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Dict[str, HashMapValue]]:
        """Player Stats Metrics

         Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param hero_ids: Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_ids: str
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param include_item_ids: Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type include_item_ids: List[int]
        :param exclude_item_ids: Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type exclude_item_ids: List[int]
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._player_stats_metrics_serialize(
            hero_ids=hero_ids,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            include_item_ids=include_item_ids,
            exclude_item_ids=exclude_item_ids,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dict[str, HashMapValue]]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def player_stats_metrics_with_http_info(
        self,
        hero_ids: Annotated[Optional[StrictStr], Field(description="Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        include_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        exclude_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Dict[str, HashMapValue]]]:
        """Player Stats Metrics

         Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param hero_ids: Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_ids: str
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param include_item_ids: Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type include_item_ids: List[int]
        :param exclude_item_ids: Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type exclude_item_ids: List[int]
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._player_stats_metrics_serialize(
            hero_ids=hero_ids,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            include_item_ids=include_item_ids,
            exclude_item_ids=exclude_item_ids,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dict[str, HashMapValue]]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def player_stats_metrics_without_preload_content(
        self,
        hero_ids: Annotated[Optional[StrictStr], Field(description="Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>")] = None,
        min_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.")] = None,
        max_unix_timestamp: Annotated[Optional[StrictInt], Field(description="Filter matches based on their start time (Unix timestamp).")] = None,
        min_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        max_duration_s: Annotated[Optional[Annotated[int, Field(le=7000, strict=True, ge=0)]], Field(description="Filter matches based on their duration in seconds (up to 7000s).")] = None,
        min_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        max_networth: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter players based on their net worth.")] = None,
        min_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        max_average_badge: Annotated[Optional[Annotated[int, Field(le=116, strict=True, ge=0)]], Field(description="Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>")] = None,
        min_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        max_match_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Filter matches based on their ID.")] = None,
        include_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        exclude_item_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>")] = None,
        account_ids: Annotated[Optional[List[Annotated[int, Field(strict=True, ge=0)]]], Field(description="Comma separated list of account ids to include")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Player Stats Metrics

         Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     

        :param hero_ids: Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
        :type hero_ids: str
        :param min_unix_timestamp: Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
        :type min_unix_timestamp: int
        :param max_unix_timestamp: Filter matches based on their start time (Unix timestamp).
        :type max_unix_timestamp: int
        :param min_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type min_duration_s: int
        :param max_duration_s: Filter matches based on their duration in seconds (up to 7000s).
        :type max_duration_s: int
        :param min_networth: Filter players based on their net worth.
        :type min_networth: int
        :param max_networth: Filter players based on their net worth.
        :type max_networth: int
        :param min_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type min_average_badge: int
        :param max_average_badge: Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
        :type max_average_badge: int
        :param min_match_id: Filter matches based on their ID.
        :type min_match_id: int
        :param max_match_id: Filter matches based on their ID.
        :type max_match_id: int
        :param include_item_ids: Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type include_item_ids: List[int]
        :param exclude_item_ids: Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
        :type exclude_item_ids: List[int]
        :param account_ids: Comma separated list of account ids to include
        :type account_ids: List[int]
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._player_stats_metrics_serialize(
            hero_ids=hero_ids,
            min_unix_timestamp=min_unix_timestamp,
            max_unix_timestamp=max_unix_timestamp,
            min_duration_s=min_duration_s,
            max_duration_s=max_duration_s,
            min_networth=min_networth,
            max_networth=max_networth,
            min_average_badge=min_average_badge,
            max_average_badge=max_average_badge,
            min_match_id=min_match_id,
            max_match_id=max_match_id,
            include_item_ids=include_item_ids,
            exclude_item_ids=exclude_item_ids,
            account_ids=account_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Dict[str, HashMapValue]]",
            '400': None,
            '500': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _player_stats_metrics_serialize(
        self,
        hero_ids,
        min_unix_timestamp,
        max_unix_timestamp,
        min_duration_s,
        max_duration_s,
        min_networth,
        max_networth,
        min_average_badge,
        max_average_badge,
        min_match_id,
        max_match_id,
        include_item_ids,
        exclude_item_ids,
        account_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'include_item_ids': 'multi',
            'exclude_item_ids': 'multi',
            'account_ids': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if hero_ids is not None:
            
            _query_params.append(('hero_ids', hero_ids))
            
        if min_unix_timestamp is not None:
            
            _query_params.append(('min_unix_timestamp', min_unix_timestamp))
            
        if max_unix_timestamp is not None:
            
            _query_params.append(('max_unix_timestamp', max_unix_timestamp))
            
        if min_duration_s is not None:
            
            _query_params.append(('min_duration_s', min_duration_s))
            
        if max_duration_s is not None:
            
            _query_params.append(('max_duration_s', max_duration_s))
            
        if min_networth is not None:
            
            _query_params.append(('min_networth', min_networth))
            
        if max_networth is not None:
            
            _query_params.append(('max_networth', max_networth))
            
        if min_average_badge is not None:
            
            _query_params.append(('min_average_badge', min_average_badge))
            
        if max_average_badge is not None:
            
            _query_params.append(('max_average_badge', max_average_badge))
            
        if min_match_id is not None:
            
            _query_params.append(('min_match_id', min_match_id))
            
        if max_match_id is not None:
            
            _query_params.append(('max_match_id', max_match_id))
            
        if include_item_ids is not None:
            
            _query_params.append(('include_item_ids', include_item_ids))
            
        if exclude_item_ids is not None:
            
            _query_params.append(('exclude_item_ids', exclude_item_ids))
            
        if account_ids is not None:
            
            _query_params.append(('account_ids', account_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/v1/analytics/player-stats/metrics',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


