/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package deadlock_api_client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import deadlock_api_client.models.EnemyStats
import deadlock_api_client.models.HeroStats
import deadlock_api_client.models.MateStats
import deadlock_api_client.models.PartyStats
import deadlock_api_client.models.PlayerMatchHistoryEntry
import deadlock_api_client.models.SteamProfile

import com.squareup.moshi.Json

import deadlock_api_client.infrastructure.ApiClient
import deadlock_api_client.infrastructure.ApiResponse
import deadlock_api_client.infrastructure.ClientException
import deadlock_api_client.infrastructure.ClientError
import deadlock_api_client.infrastructure.ServerException
import deadlock_api_client.infrastructure.ServerError
import deadlock_api_client.infrastructure.MultiValueMap
import deadlock_api_client.infrastructure.PartConfig
import deadlock_api_client.infrastructure.RequestConfig
import deadlock_api_client.infrastructure.RequestMethod
import deadlock_api_client.infrastructure.ResponseType
import deadlock_api_client.infrastructure.Success
import deadlock_api_client.infrastructure.toMultiValue

open class PlayersApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.deadlock-api.com")
        }
    }

    /**
     * enum for parameter gameMode
     */
     enum class GameModeEnemyStats(val value: kotlin.String) {
         @Json(name = "normal") normal("normal"),
         @Json(name = "street_brawl") street_brawl("street_brawl");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/players/{account_id}/enemy-stats
     * Enemy Stats
     *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minMatchesPlayed Filter based on the number of matches played. (optional)
     * @param maxMatchesPlayed Filter based on the number of matches played. (optional)
     * @return kotlin.collections.List<EnemyStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enemyStats(accountId: kotlin.Int, gameMode: GameModeEnemyStats? = null, minUnixTimestamp: kotlin.Long? = null, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, minMatchesPlayed: kotlin.Long? = null, maxMatchesPlayed: kotlin.Long? = null) : kotlin.collections.List<EnemyStats> {
        val localVarResponse = enemyStatsWithHttpInfo(accountId = accountId, gameMode = gameMode, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minMatchId = minMatchId, maxMatchId = maxMatchId, minMatchesPlayed = minMatchesPlayed, maxMatchesPlayed = maxMatchesPlayed)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<EnemyStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/players/{account_id}/enemy-stats
     * Enemy Stats
     *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minMatchesPlayed Filter based on the number of matches played. (optional)
     * @param maxMatchesPlayed Filter based on the number of matches played. (optional)
     * @return ApiResponse<kotlin.collections.List<EnemyStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enemyStatsWithHttpInfo(accountId: kotlin.Int, gameMode: GameModeEnemyStats?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, minMatchesPlayed: kotlin.Long?, maxMatchesPlayed: kotlin.Long?) : ApiResponse<kotlin.collections.List<EnemyStats>?> {
        val localVariableConfig = enemyStatsRequestConfig(accountId = accountId, gameMode = gameMode, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minMatchId = minMatchId, maxMatchId = maxMatchId, minMatchesPlayed = minMatchesPlayed, maxMatchesPlayed = maxMatchesPlayed)

        return request<Unit, kotlin.collections.List<EnemyStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation enemyStats
     *
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minMatchesPlayed Filter based on the number of matches played. (optional)
     * @param maxMatchesPlayed Filter based on the number of matches played. (optional)
     * @return RequestConfig
     */
    fun enemyStatsRequestConfig(accountId: kotlin.Int, gameMode: GameModeEnemyStats?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, minMatchesPlayed: kotlin.Long?, maxMatchesPlayed: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (gameMode != null) {
                    put("game_mode", listOf(gameMode.value))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (minMatchesPlayed != null) {
                    put("min_matches_played", listOf(minMatchesPlayed.toString()))
                }
                if (maxMatchesPlayed != null) {
                    put("max_matches_played", listOf(maxMatchesPlayed.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/players/{account_id}/enemy-stats".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/players/{account_id}/match-history
     * Match History
     *  This endpoint returns the player match history for the given &#x60;account_id&#x60;.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: 100req/s&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Key | 50req/min &amp; 1000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Global | 2000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 10req/h |     
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param forceRefetch Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit. (optional)
     * @param onlyStoredHistory Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;. (optional)
     * @return kotlin.collections.List<PlayerMatchHistoryEntry>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun matchHistory(accountId: kotlin.Int, forceRefetch: kotlin.Boolean? = null, onlyStoredHistory: kotlin.Boolean? = null) : kotlin.collections.List<PlayerMatchHistoryEntry> {
        val localVarResponse = matchHistoryWithHttpInfo(accountId = accountId, forceRefetch = forceRefetch, onlyStoredHistory = onlyStoredHistory)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PlayerMatchHistoryEntry>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/players/{account_id}/match-history
     * Match History
     *  This endpoint returns the player match history for the given &#x60;account_id&#x60;.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: 100req/s&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Key | 50req/min &amp; 1000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Global | 2000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 10req/h |     
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param forceRefetch Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit. (optional)
     * @param onlyStoredHistory Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;. (optional)
     * @return ApiResponse<kotlin.collections.List<PlayerMatchHistoryEntry>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun matchHistoryWithHttpInfo(accountId: kotlin.Int, forceRefetch: kotlin.Boolean?, onlyStoredHistory: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<PlayerMatchHistoryEntry>?> {
        val localVariableConfig = matchHistoryRequestConfig(accountId = accountId, forceRefetch = forceRefetch, onlyStoredHistory = onlyStoredHistory)

        return request<Unit, kotlin.collections.List<PlayerMatchHistoryEntry>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation matchHistory
     *
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param forceRefetch Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit. (optional)
     * @param onlyStoredHistory Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;. (optional)
     * @return RequestConfig
     */
    fun matchHistoryRequestConfig(accountId: kotlin.Int, forceRefetch: kotlin.Boolean?, onlyStoredHistory: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (forceRefetch != null) {
                    put("force_refetch", listOf(forceRefetch.toString()))
                }
                if (onlyStoredHistory != null) {
                    put("only_stored_history", listOf(onlyStoredHistory.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/players/{account_id}/match-history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter gameMode
     */
     enum class GameModeMateStats(val value: kotlin.String) {
         @Json(name = "normal") normal("normal"),
         @Json(name = "street_brawl") street_brawl("street_brawl");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/players/{account_id}/mate-stats
     * Mate Stats
     *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minMatchesPlayed Filter based on the number of matches played. (optional)
     * @param maxMatchesPlayed Filter based on the number of matches played. (optional)
     * @param sameParty Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches. (optional, default to true)
     * @return kotlin.collections.List<MateStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun mateStats(accountId: kotlin.Int, gameMode: GameModeMateStats? = null, minUnixTimestamp: kotlin.Long? = null, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, minMatchesPlayed: kotlin.Long? = null, maxMatchesPlayed: kotlin.Long? = null, sameParty: kotlin.Boolean? = true) : kotlin.collections.List<MateStats> {
        val localVarResponse = mateStatsWithHttpInfo(accountId = accountId, gameMode = gameMode, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minMatchId = minMatchId, maxMatchId = maxMatchId, minMatchesPlayed = minMatchesPlayed, maxMatchesPlayed = maxMatchesPlayed, sameParty = sameParty)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MateStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/players/{account_id}/mate-stats
     * Mate Stats
     *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minMatchesPlayed Filter based on the number of matches played. (optional)
     * @param maxMatchesPlayed Filter based on the number of matches played. (optional)
     * @param sameParty Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches. (optional, default to true)
     * @return ApiResponse<kotlin.collections.List<MateStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun mateStatsWithHttpInfo(accountId: kotlin.Int, gameMode: GameModeMateStats?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, minMatchesPlayed: kotlin.Long?, maxMatchesPlayed: kotlin.Long?, sameParty: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<MateStats>?> {
        val localVariableConfig = mateStatsRequestConfig(accountId = accountId, gameMode = gameMode, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minMatchId = minMatchId, maxMatchId = maxMatchId, minMatchesPlayed = minMatchesPlayed, maxMatchesPlayed = maxMatchesPlayed, sameParty = sameParty)

        return request<Unit, kotlin.collections.List<MateStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation mateStats
     *
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minMatchesPlayed Filter based on the number of matches played. (optional)
     * @param maxMatchesPlayed Filter based on the number of matches played. (optional)
     * @param sameParty Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches. (optional, default to true)
     * @return RequestConfig
     */
    fun mateStatsRequestConfig(accountId: kotlin.Int, gameMode: GameModeMateStats?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, minMatchesPlayed: kotlin.Long?, maxMatchesPlayed: kotlin.Long?, sameParty: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (gameMode != null) {
                    put("game_mode", listOf(gameMode.value))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (minMatchesPlayed != null) {
                    put("min_matches_played", listOf(minMatchesPlayed.toString()))
                }
                if (maxMatchesPlayed != null) {
                    put("max_matches_played", listOf(maxMatchesPlayed.toString()))
                }
                if (sameParty != null) {
                    put("same_party", listOf(sameParty.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/players/{account_id}/mate-stats".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter gameMode
     */
     enum class GameModePartyStats(val value: kotlin.String) {
         @Json(name = "normal") normal("normal"),
         @Json(name = "street_brawl") street_brawl("street_brawl");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/players/{account_id}/party-stats
     * Party Stats
     *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return kotlin.collections.List<PartyStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun partyStats(accountId: kotlin.Int, gameMode: GameModePartyStats? = null, minUnixTimestamp: kotlin.Long? = null, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null) : kotlin.collections.List<PartyStats> {
        val localVarResponse = partyStatsWithHttpInfo(accountId = accountId, gameMode = gameMode, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minMatchId = minMatchId, maxMatchId = maxMatchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PartyStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/players/{account_id}/party-stats
     * Party Stats
     *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return ApiResponse<kotlin.collections.List<PartyStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun partyStatsWithHttpInfo(accountId: kotlin.Int, gameMode: GameModePartyStats?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?) : ApiResponse<kotlin.collections.List<PartyStats>?> {
        val localVariableConfig = partyStatsRequestConfig(accountId = accountId, gameMode = gameMode, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minMatchId = minMatchId, maxMatchId = maxMatchId)

        return request<Unit, kotlin.collections.List<PartyStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation partyStats
     *
     * @param accountId The players &#x60;SteamID3&#x60;
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return RequestConfig
     */
    fun partyStatsRequestConfig(accountId: kotlin.Int, gameMode: GameModePartyStats?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (gameMode != null) {
                    put("game_mode", listOf(gameMode.value))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/players/{account_id}/party-stats".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter gameMode
     */
     enum class GameModePlayerHeroStats(val value: kotlin.String) {
         @Json(name = "normal") normal("normal"),
         @Json(name = "street_brawl") street_brawl("street_brawl");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/players/hero-stats
     * Hero Stats
     *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their final net worth. (optional)
     * @param maxNetworth Filter players based on their final net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return kotlin.collections.List<HeroStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun playerHeroStats(accountIds: kotlin.collections.List<kotlin.Int>, gameMode: GameModePlayerHeroStats? = null, heroIds: kotlin.String? = null, minUnixTimestamp: kotlin.Long? = null, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null) : kotlin.collections.List<HeroStats> {
        val localVarResponse = playerHeroStatsWithHttpInfo(accountIds = accountIds, gameMode = gameMode, heroIds = heroIds, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<HeroStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/players/hero-stats
     * Hero Stats
     *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their final net worth. (optional)
     * @param maxNetworth Filter players based on their final net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return ApiResponse<kotlin.collections.List<HeroStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun playerHeroStatsWithHttpInfo(accountIds: kotlin.collections.List<kotlin.Int>, gameMode: GameModePlayerHeroStats?, heroIds: kotlin.String?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?) : ApiResponse<kotlin.collections.List<HeroStats>?> {
        val localVariableConfig = playerHeroStatsRequestConfig(accountIds = accountIds, gameMode = gameMode, heroIds = heroIds, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId)

        return request<Unit, kotlin.collections.List<HeroStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation playerHeroStats
     *
     * @param accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @param gameMode Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. If not specified, both are included. (optional)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their final net worth. (optional)
     * @param maxNetworth Filter players based on their final net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return RequestConfig
     */
    fun playerHeroStatsRequestConfig(accountIds: kotlin.collections.List<kotlin.Int>, gameMode: GameModePlayerHeroStats?, heroIds: kotlin.String?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                if (gameMode != null) {
                    put("game_mode", listOf(gameMode.value))
                }
                if (heroIds != null) {
                    put("hero_ids", listOf(heroIds.toString()))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/players/hero-stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/players/steam
     * Batch Steam Profile
     *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @return kotlin.collections.List<SteamProfile>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun steam(accountIds: kotlin.collections.List<kotlin.Long>) : kotlin.collections.List<SteamProfile> {
        val localVarResponse = steamWithHttpInfo(accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SteamProfile>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/players/steam
     * Batch Steam Profile
     *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @return ApiResponse<kotlin.collections.List<SteamProfile>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun steamWithHttpInfo(accountIds: kotlin.collections.List<kotlin.Long>) : ApiResponse<kotlin.collections.List<SteamProfile>?> {
        val localVariableConfig = steamRequestConfig(accountIds = accountIds)

        return request<Unit, kotlin.collections.List<SteamProfile>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation steam
     *
     * @param accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @return RequestConfig
     */
    fun steamRequestConfig(accountIds: kotlin.collections.List<kotlin.Long>) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("account_ids", toMultiValue(accountIds.toList(), "multi"))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/players/steam",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/players/steam-search
     * Steam Profile Search
     *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param searchQuery Search query for Steam profiles.
     * @return kotlin.collections.List<SteamProfile>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun steamSearch(searchQuery: kotlin.String) : kotlin.collections.List<SteamProfile> {
        val localVarResponse = steamSearchWithHttpInfo(searchQuery = searchQuery)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<SteamProfile>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/players/steam-search
     * Steam Profile Search
     *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param searchQuery Search query for Steam profiles.
     * @return ApiResponse<kotlin.collections.List<SteamProfile>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun steamSearchWithHttpInfo(searchQuery: kotlin.String) : ApiResponse<kotlin.collections.List<SteamProfile>?> {
        val localVariableConfig = steamSearchRequestConfig(searchQuery = searchQuery)

        return request<Unit, kotlin.collections.List<SteamProfile>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation steamSearch
     *
     * @param searchQuery Search query for Steam profiles.
     * @return RequestConfig
     */
    fun steamSearchRequestConfig(searchQuery: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("search_query", listOf(searchQuery.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/players/steam-search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
