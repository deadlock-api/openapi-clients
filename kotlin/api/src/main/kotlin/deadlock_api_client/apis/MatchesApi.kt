/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package deadlock_api_client.apis

import deadlock_api_client.models.ActiveMatch
import deadlock_api_client.models.ClickhouseMatchInfo
import deadlock_api_client.models.MatchSaltsResponse
import deadlock_api_client.models.MatchSpectateResponse

import deadlock_api_client.infrastructure.*
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import io.ktor.http.ParametersBuilder
import com.google.gson.Gson
import com.google.gson.GsonBuilder
import java.text.DateFormat

    open class MatchesApi(
    baseUrl: String = ApiClient.BASE_URL,
    httpClientEngine: HttpClientEngine? = null,
    httpClientConfig: ((HttpClientConfig<*>) -> Unit)? = null,
    jsonBlock: GsonBuilder.() -> Unit = ApiClient.JSON_DEFAULT,
    ) : ApiClient(
        baseUrl,
        httpClientEngine,
        httpClientConfig,
        jsonBlock,
    ) {

        /**
        * GET /v1/matches/active
        * Active
        *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @param accountId The account ID to filter active matches by (&#x60;SteamID3&#x60;) (optional)
         * @param accountIds Comma separated list of account ids to include (optional)
         * @return kotlin.collections.List<ActiveMatch>
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun activeMatches(accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?): HttpResponse<kotlin.collections.List<ActiveMatch>> {

            val localVariableAuthNames = listOf<String>()

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            accountId?.apply { localVariableQuery["account_id"] = listOf("$accountId") }
            accountIds?.apply { localVariableQuery["account_ids"] = toMultiValue(this, "multi") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/matches/active",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /v1/matches/active/raw
        * Active as Protobuf
        *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @return kotlin.collections.List<kotlin.Int>
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun activeMatchesRaw(): HttpResponse<kotlin.collections.List<kotlin.Int>> {

            val localVariableAuthNames = listOf<String>()

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/matches/active/raw",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /v1/matches/metadata
        * Bulk Metadata
        *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
         * @param includeInfo Include match info in the response. (optional, default to true)
         * @param includeObjectives Include objectives in the response. (optional)
         * @param includeMidBoss Include midboss in the response. (optional)
         * @param includePlayerInfo Include player info in the response. (optional)
         * @param includePlayerItems Include player items in the response. (optional)
         * @param includePlayerStats Include player stats in the response. (optional)
         * @param includePlayerDeathDetails Include player death details in the response. (optional)
         * @param matchIds Comma separated list of match ids, limited by &#x60;limit&#x60; (optional)
         * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
         * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
         * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
         * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
         * @param minAverageBadge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
         * @param maxAverageBadge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
         * @param minMatchId Filter matches based on their ID. (optional)
         * @param maxMatchId Filter matches based on their ID. (optional)
         * @param isHighSkillRangeParties Filter matches based on whether they are in the high skill range. (optional)
         * @param isLowPriPool Filter matches based on whether they are in the low priority pool. (optional)
         * @param isNewPlayerPool Filter matches based on whether they are in the new player pool. (optional)
         * @param accountIds Filter matches by account IDs of players that participated in the match. (optional)
         * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
         * @param orderBy The field to order the results by. (optional)
         * @param orderDirection The direction to order the results by. (optional)
         * @param limit The maximum number of matches to return. (optional, default to 1000)
         * @return kotlin.collections.List<kotlin.Int>
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun bulkMetadata(includeInfo: kotlin.Boolean?, includeObjectives: kotlin.Boolean?, includeMidBoss: kotlin.Boolean?, includePlayerInfo: kotlin.Boolean?, includePlayerItems: kotlin.Boolean?, includePlayerStats: kotlin.Boolean?, includePlayerDeathDetails: kotlin.Boolean?, matchIds: kotlin.collections.List<kotlin.Long>?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, isHighSkillRangeParties: kotlin.Boolean?, isLowPriPool: kotlin.Boolean?, isNewPlayerPool: kotlin.Boolean?, accountIds: kotlin.collections.List<kotlin.Int>?, heroIds: kotlin.String?, orderBy: kotlin.String?, orderDirection: kotlin.String?, limit: kotlin.Int?): HttpResponse<kotlin.collections.List<kotlin.Int>> {

            val localVariableAuthNames = listOf<String>()

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            includeInfo?.apply { localVariableQuery["include_info"] = listOf("$includeInfo") }
            includeObjectives?.apply { localVariableQuery["include_objectives"] = listOf("$includeObjectives") }
            includeMidBoss?.apply { localVariableQuery["include_mid_boss"] = listOf("$includeMidBoss") }
            includePlayerInfo?.apply { localVariableQuery["include_player_info"] = listOf("$includePlayerInfo") }
            includePlayerItems?.apply { localVariableQuery["include_player_items"] = listOf("$includePlayerItems") }
            includePlayerStats?.apply { localVariableQuery["include_player_stats"] = listOf("$includePlayerStats") }
            includePlayerDeathDetails?.apply { localVariableQuery["include_player_death_details"] = listOf("$includePlayerDeathDetails") }
            matchIds?.apply { localVariableQuery["match_ids"] = toMultiValue(this, "multi") }
            minUnixTimestamp?.apply { localVariableQuery["min_unix_timestamp"] = listOf("$minUnixTimestamp") }
            maxUnixTimestamp?.apply { localVariableQuery["max_unix_timestamp"] = listOf("$maxUnixTimestamp") }
            minDurationS?.apply { localVariableQuery["min_duration_s"] = listOf("$minDurationS") }
            maxDurationS?.apply { localVariableQuery["max_duration_s"] = listOf("$maxDurationS") }
            minAverageBadge?.apply { localVariableQuery["min_average_badge"] = listOf("$minAverageBadge") }
            maxAverageBadge?.apply { localVariableQuery["max_average_badge"] = listOf("$maxAverageBadge") }
            minMatchId?.apply { localVariableQuery["min_match_id"] = listOf("$minMatchId") }
            maxMatchId?.apply { localVariableQuery["max_match_id"] = listOf("$maxMatchId") }
            isHighSkillRangeParties?.apply { localVariableQuery["is_high_skill_range_parties"] = listOf("$isHighSkillRangeParties") }
            isLowPriPool?.apply { localVariableQuery["is_low_pri_pool"] = listOf("$isLowPriPool") }
            isNewPlayerPool?.apply { localVariableQuery["is_new_player_pool"] = listOf("$isNewPlayerPool") }
            accountIds?.apply { localVariableQuery["account_ids"] = toMultiValue(this, "multi") }
            heroIds?.apply { localVariableQuery["hero_ids"] = listOf("$heroIds") }
            orderBy?.apply { localVariableQuery["order_by"] = listOf("$orderBy") }
            orderDirection?.apply { localVariableQuery["order_direction"] = listOf("$orderDirection") }
            limit?.apply { localVariableQuery["limit"] = listOf("$limit") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/matches/metadata",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /v1/matches/{match_id}/metadata
        * Metadata
        *  This endpoint returns the match metadata for the given &#x60;match_id&#x60; parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 10req/30mins | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 10req/min | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 10req/10s |     
         * @param matchId The match ID 
         * @param isCustom  (optional)
         * @return void
        */
        open suspend fun metadata(matchId: kotlin.Long, isCustom: kotlin.Boolean?): HttpResponse<Unit> {

            val localVariableAuthNames = listOf<String>()

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            isCustom?.apply { localVariableQuery["is_custom"] = listOf("$isCustom") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/matches/{match_id}/metadata".replace("{" + "match_id" + "}", "$matchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /v1/matches/{match_id}/metadata/raw
        * Metadata as Protobuf
        *  This endpoints returns the raw .meta.bz2 file for the given &#x60;match_id&#x60;.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 10req/30mins | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 10req/min | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 10req/10s |     
         * @param matchId The match ID 
         * @param isCustom  (optional)
         * @return kotlin.collections.List<kotlin.Int>
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun metadataRaw(matchId: kotlin.Long, isCustom: kotlin.Boolean?): HttpResponse<kotlin.collections.List<kotlin.Int>> {

            val localVariableAuthNames = listOf<String>()

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            isCustom?.apply { localVariableQuery["is_custom"] = listOf("$isCustom") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/matches/{match_id}/metadata/raw".replace("{" + "match_id" + "}", "$matchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /v1/matches/recently-fetched
        * Recently Fetched
        *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @param playerIngestedOnly If true, only return matches that have been ingested by players. (optional)
         * @return kotlin.collections.List<ClickhouseMatchInfo>
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun recentlyFetched(playerIngestedOnly: kotlin.Boolean?): HttpResponse<kotlin.collections.List<ClickhouseMatchInfo>> {

            val localVariableAuthNames = listOf<String>()

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()
            playerIngestedOnly?.apply { localVariableQuery["player_ingested_only"] = listOf("$playerIngestedOnly") }

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/matches/recently-fetched",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /v1/matches/{match_id}/salts
        * Salts
        *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s&lt;br&gt;From Steam: 10req/30mins | | Key | From DB: -&lt;br&gt;From Steam: 10req/min | | Global | From DB: -&lt;br&gt;From Steam: 10req/10s |     
         * @param matchId The match ID 
         * @return MatchSaltsResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun salts(matchId: kotlin.Long): HttpResponse<MatchSaltsResponse> {

            val localVariableAuthNames = listOf<String>()

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/matches/{match_id}/salts".replace("{" + "match_id" + "}", "$matchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        /**
        * GET /v1/matches/{match_id}/live/url
        * Live Broadcast URL
        *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
         * @param matchId The match ID 
         * @return MatchSpectateResponse
        */
            @Suppress("UNCHECKED_CAST")
        open suspend fun url(matchId: kotlin.Long): HttpResponse<MatchSpectateResponse> {

            val localVariableAuthNames = listOf<String>()

            val localVariableBody = 
                    io.ktor.client.utils.EmptyContent

            val localVariableQuery = mutableMapOf<String, List<String>>()

            val localVariableHeaders = mutableMapOf<String, String>()

            val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/v1/matches/{match_id}/live/url".replace("{" + "match_id" + "}", "$matchId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            )

            return request(
            localVariableConfig,
            localVariableBody,
            localVariableAuthNames
            ).wrap()
            }

        }
