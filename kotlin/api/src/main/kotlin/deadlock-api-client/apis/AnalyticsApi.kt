/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package deadlock-api-client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import deadlock-api-client.models.AnalyticsAbilityOrderStats
import deadlock-api-client.models.AnalyticsHeroStats
import deadlock-api-client.models.BadgeDistribution
import deadlock-api-client.models.BuildItemStats
import deadlock-api-client.models.Entry
import deadlock-api-client.models.HashMapValue
import deadlock-api-client.models.HeroCombStats
import deadlock-api-client.models.HeroCounterStats
import deadlock-api-client.models.HeroSynergyStats
import deadlock-api-client.models.ItemPermutationStats
import deadlock-api-client.models.ItemStats

import com.squareup.moshi.Json

import deadlock-api-client.infrastructure.ApiClient
import deadlock-api-client.infrastructure.ApiResponse
import deadlock-api-client.infrastructure.ClientException
import deadlock-api-client.infrastructure.ClientError
import deadlock-api-client.infrastructure.ServerException
import deadlock-api-client.infrastructure.ServerError
import deadlock-api-client.infrastructure.MultiValueMap
import deadlock-api-client.infrastructure.PartConfig
import deadlock-api-client.infrastructure.RequestConfig
import deadlock-api-client.infrastructure.RequestMethod
import deadlock-api-client.infrastructure.ResponseType
import deadlock-api-client.infrastructure.Success
import deadlock-api-client.infrastructure.toMultiValue

class AnalyticsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.deadlock-api.com")
        }
    }

    /**
     * GET /v1/analytics/ability-order-stats
     * Ability Order Stats
     *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param heroId See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minAbilityUpgrades Filter players based on their minimum number of ability upgrades over the whole match. (optional)
     * @param maxAbilityUpgrades Filter players based on their maximum number of ability upgrades over the whole match. (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minMatches The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<AnalyticsAbilityOrderStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun abilityOrderStats(heroId: kotlin.Int, minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minAbilityUpgrades: kotlin.Long? = null, maxAbilityUpgrades: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, minMatches: kotlin.Int? = 20, accountId: kotlin.Int? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<AnalyticsAbilityOrderStats> {
        val localVarResponse = abilityOrderStatsWithHttpInfo(heroId = heroId, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minAbilityUpgrades = minAbilityUpgrades, maxAbilityUpgrades = maxAbilityUpgrades, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, minMatches = minMatches, accountId = accountId, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AnalyticsAbilityOrderStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/ability-order-stats
     * Ability Order Stats
     *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param heroId See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minAbilityUpgrades Filter players based on their minimum number of ability upgrades over the whole match. (optional)
     * @param maxAbilityUpgrades Filter players based on their maximum number of ability upgrades over the whole match. (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minMatches The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<AnalyticsAbilityOrderStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun abilityOrderStatsWithHttpInfo(heroId: kotlin.Int, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minAbilityUpgrades: kotlin.Long?, maxAbilityUpgrades: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, minMatches: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<AnalyticsAbilityOrderStats>?> {
        val localVariableConfig = abilityOrderStatsRequestConfig(heroId = heroId, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minAbilityUpgrades = minAbilityUpgrades, maxAbilityUpgrades = maxAbilityUpgrades, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, minMatches = minMatches, accountId = accountId, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<AnalyticsAbilityOrderStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation abilityOrderStats
     *
     * @param heroId See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minAbilityUpgrades Filter players based on their minimum number of ability upgrades over the whole match. (optional)
     * @param maxAbilityUpgrades Filter players based on their maximum number of ability upgrades over the whole match. (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minMatches The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun abilityOrderStatsRequestConfig(heroId: kotlin.Int, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minAbilityUpgrades: kotlin.Long?, maxAbilityUpgrades: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, minMatches: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("hero_id", listOf(heroId.toString()))
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minAbilityUpgrades != null) {
                    put("min_ability_upgrades", listOf(minAbilityUpgrades.toString()))
                }
                if (maxAbilityUpgrades != null) {
                    put("max_ability_upgrades", listOf(maxAbilityUpgrades.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (minMatches != null) {
                    put("min_matches", listOf(minMatches.toString()))
                }
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/ability-order-stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/analytics/badge-distribution
     * Badge Distribution
     *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param isHighSkillRangeParties Filter matches based on whether they are in the high skill range. (optional)
     * @param isLowPriPool Filter matches based on whether they are in the low priority pool. (optional)
     * @param isNewPlayerPool Filter matches based on whether they are in the new player pool. (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return kotlin.collections.List<BadgeDistribution>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun badgeDistribution(minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, isHighSkillRangeParties: kotlin.Boolean? = null, isLowPriPool: kotlin.Boolean? = null, isNewPlayerPool: kotlin.Boolean? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null) : kotlin.collections.List<BadgeDistribution> {
        val localVarResponse = badgeDistributionWithHttpInfo(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, isHighSkillRangeParties = isHighSkillRangeParties, isLowPriPool = isLowPriPool, isNewPlayerPool = isNewPlayerPool, minMatchId = minMatchId, maxMatchId = maxMatchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BadgeDistribution>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/badge-distribution
     * Badge Distribution
     *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param isHighSkillRangeParties Filter matches based on whether they are in the high skill range. (optional)
     * @param isLowPriPool Filter matches based on whether they are in the low priority pool. (optional)
     * @param isNewPlayerPool Filter matches based on whether they are in the new player pool. (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return ApiResponse<kotlin.collections.List<BadgeDistribution>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun badgeDistributionWithHttpInfo(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, isHighSkillRangeParties: kotlin.Boolean?, isLowPriPool: kotlin.Boolean?, isNewPlayerPool: kotlin.Boolean?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?) : ApiResponse<kotlin.collections.List<BadgeDistribution>?> {
        val localVariableConfig = badgeDistributionRequestConfig(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, isHighSkillRangeParties = isHighSkillRangeParties, isLowPriPool = isLowPriPool, isNewPlayerPool = isNewPlayerPool, minMatchId = minMatchId, maxMatchId = maxMatchId)

        return request<Unit, kotlin.collections.List<BadgeDistribution>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation badgeDistribution
     *
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param isHighSkillRangeParties Filter matches based on whether they are in the high skill range. (optional)
     * @param isLowPriPool Filter matches based on whether they are in the low priority pool. (optional)
     * @param isNewPlayerPool Filter matches based on whether they are in the new player pool. (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return RequestConfig
     */
    fun badgeDistributionRequestConfig(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, isHighSkillRangeParties: kotlin.Boolean?, isLowPriPool: kotlin.Boolean?, isNewPlayerPool: kotlin.Boolean?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (isHighSkillRangeParties != null) {
                    put("is_high_skill_range_parties", listOf(isHighSkillRangeParties.toString()))
                }
                if (isLowPriPool != null) {
                    put("is_low_pri_pool", listOf(isLowPriPool.toString()))
                }
                if (isNewPlayerPool != null) {
                    put("is_new_player_pool", listOf(isNewPlayerPool.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/badge-distribution",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/analytics/build-item-stats
     * Build Item Stats
     *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param heroId Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minLastUpdatedUnixTimestamp Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxLastUpdatedUnixTimestamp Filter builds based on their last updated time (Unix timestamp). (optional)
     * @return kotlin.collections.List<BuildItemStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun buildItemStats(heroId: kotlin.Int? = null, minLastUpdatedUnixTimestamp: kotlin.Long? = 1755561600L, maxLastUpdatedUnixTimestamp: kotlin.Long? = null) : kotlin.collections.List<BuildItemStats> {
        val localVarResponse = buildItemStatsWithHttpInfo(heroId = heroId, minLastUpdatedUnixTimestamp = minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp = maxLastUpdatedUnixTimestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BuildItemStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/build-item-stats
     * Build Item Stats
     *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param heroId Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minLastUpdatedUnixTimestamp Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxLastUpdatedUnixTimestamp Filter builds based on their last updated time (Unix timestamp). (optional)
     * @return ApiResponse<kotlin.collections.List<BuildItemStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun buildItemStatsWithHttpInfo(heroId: kotlin.Int?, minLastUpdatedUnixTimestamp: kotlin.Long?, maxLastUpdatedUnixTimestamp: kotlin.Long?) : ApiResponse<kotlin.collections.List<BuildItemStats>?> {
        val localVariableConfig = buildItemStatsRequestConfig(heroId = heroId, minLastUpdatedUnixTimestamp = minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp = maxLastUpdatedUnixTimestamp)

        return request<Unit, kotlin.collections.List<BuildItemStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation buildItemStats
     *
     * @param heroId Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minLastUpdatedUnixTimestamp Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxLastUpdatedUnixTimestamp Filter builds based on their last updated time (Unix timestamp). (optional)
     * @return RequestConfig
     */
    fun buildItemStatsRequestConfig(heroId: kotlin.Int?, minLastUpdatedUnixTimestamp: kotlin.Long?, maxLastUpdatedUnixTimestamp: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (heroId != null) {
                    put("hero_id", listOf(heroId.toString()))
                }
                if (minLastUpdatedUnixTimestamp != null) {
                    put("min_last_updated_unix_timestamp", listOf(minLastUpdatedUnixTimestamp.toString()))
                }
                if (maxLastUpdatedUnixTimestamp != null) {
                    put("max_last_updated_unix_timestamp", listOf(maxLastUpdatedUnixTimestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/build-item-stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/analytics/hero-comb-stats
     * Hero Comb Stats
     *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param includeHeroIds Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param excludeHeroIds Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minMatches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param combSize The combination size to return. (optional, default to 6)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<HeroCombStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun heroCombStats(minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, includeHeroIds: kotlin.collections.List<kotlin.Int>? = null, excludeHeroIds: kotlin.collections.List<kotlin.Int>? = null, minMatches: kotlin.Int? = 20, maxMatches: kotlin.Int? = null, combSize: kotlin.Int? = 6, accountId: kotlin.Int? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<HeroCombStats> {
        val localVarResponse = heroCombStatsWithHttpInfo(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, includeHeroIds = includeHeroIds, excludeHeroIds = excludeHeroIds, minMatches = minMatches, maxMatches = maxMatches, combSize = combSize, accountId = accountId, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<HeroCombStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/hero-comb-stats
     * Hero Comb Stats
     *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param includeHeroIds Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param excludeHeroIds Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minMatches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param combSize The combination size to return. (optional, default to 6)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<HeroCombStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun heroCombStatsWithHttpInfo(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, includeHeroIds: kotlin.collections.List<kotlin.Int>?, excludeHeroIds: kotlin.collections.List<kotlin.Int>?, minMatches: kotlin.Int?, maxMatches: kotlin.Int?, combSize: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<HeroCombStats>?> {
        val localVariableConfig = heroCombStatsRequestConfig(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, includeHeroIds = includeHeroIds, excludeHeroIds = excludeHeroIds, minMatches = minMatches, maxMatches = maxMatches, combSize = combSize, accountId = accountId, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<HeroCombStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation heroCombStats
     *
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param includeHeroIds Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param excludeHeroIds Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minMatches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param combSize The combination size to return. (optional, default to 6)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun heroCombStatsRequestConfig(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, includeHeroIds: kotlin.collections.List<kotlin.Int>?, excludeHeroIds: kotlin.collections.List<kotlin.Int>?, minMatches: kotlin.Int?, maxMatches: kotlin.Int?, combSize: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (includeHeroIds != null) {
                    put("include_hero_ids", toMultiValue(includeHeroIds.toList(), "multi"))
                }
                if (excludeHeroIds != null) {
                    put("exclude_hero_ids", toMultiValue(excludeHeroIds.toList(), "multi"))
                }
                if (minMatches != null) {
                    put("min_matches", listOf(minMatches.toString()))
                }
                if (maxMatches != null) {
                    put("max_matches", listOf(maxMatches.toString()))
                }
                if (combSize != null) {
                    put("comb_size", listOf(combSize.toString()))
                }
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/hero-comb-stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/analytics/hero-counter-stats
     * Hero Counter Stats
     *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (&#x60;hero_id&#x60;) wins against an enemy hero (&#x60;enemy_hero_id&#x60;) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minEnemyNetworth Filter enemy players based on their net worth. (optional)
     * @param maxEnemyNetworth Filter enemy players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param sameLaneFilter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param minMatches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20L)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<HeroCounterStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun heroCountersStats(minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minEnemyNetworth: kotlin.Long? = null, maxEnemyNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, sameLaneFilter: kotlin.Boolean? = true, minMatches: kotlin.Long? = 20L, maxMatches: kotlin.Int? = null, accountId: kotlin.Int? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<HeroCounterStats> {
        val localVarResponse = heroCountersStatsWithHttpInfo(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minEnemyNetworth = minEnemyNetworth, maxEnemyNetworth = maxEnemyNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, sameLaneFilter = sameLaneFilter, minMatches = minMatches, maxMatches = maxMatches, accountId = accountId, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<HeroCounterStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/hero-counter-stats
     * Hero Counter Stats
     *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (&#x60;hero_id&#x60;) wins against an enemy hero (&#x60;enemy_hero_id&#x60;) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minEnemyNetworth Filter enemy players based on their net worth. (optional)
     * @param maxEnemyNetworth Filter enemy players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param sameLaneFilter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param minMatches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20L)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<HeroCounterStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun heroCountersStatsWithHttpInfo(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minEnemyNetworth: kotlin.Long?, maxEnemyNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, sameLaneFilter: kotlin.Boolean?, minMatches: kotlin.Long?, maxMatches: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<HeroCounterStats>?> {
        val localVariableConfig = heroCountersStatsRequestConfig(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minEnemyNetworth = minEnemyNetworth, maxEnemyNetworth = maxEnemyNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, sameLaneFilter = sameLaneFilter, minMatches = minMatches, maxMatches = maxMatches, accountId = accountId, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<HeroCounterStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation heroCountersStats
     *
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minEnemyNetworth Filter enemy players based on their net worth. (optional)
     * @param maxEnemyNetworth Filter enemy players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param sameLaneFilter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param minMatches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20L)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun heroCountersStatsRequestConfig(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minEnemyNetworth: kotlin.Long?, maxEnemyNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, sameLaneFilter: kotlin.Boolean?, minMatches: kotlin.Long?, maxMatches: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minEnemyNetworth != null) {
                    put("min_enemy_networth", listOf(minEnemyNetworth.toString()))
                }
                if (maxEnemyNetworth != null) {
                    put("max_enemy_networth", listOf(maxEnemyNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (sameLaneFilter != null) {
                    put("same_lane_filter", listOf(sameLaneFilter.toString()))
                }
                if (minMatches != null) {
                    put("min_matches", listOf(minMatches.toString()))
                }
                if (maxMatches != null) {
                    put("max_matches", listOf(maxMatches.toString()))
                }
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/hero-counter-stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortBy
     */
     enum class SortByHeroScoreboard(val value: kotlin.String) {
         @Json(name = "matches") matches("matches"),
         @Json(name = "wins") wins("wins"),
         @Json(name = "losses") losses("losses"),
         @Json(name = "winrate") winrate("winrate"),
         @Json(name = "max_kills_per_match") max_kills_per_match("max_kills_per_match"),
         @Json(name = "avg_kills_per_match") avg_kills_per_match("avg_kills_per_match"),
         @Json(name = "kills") kills("kills"),
         @Json(name = "max_deaths_per_match") max_deaths_per_match("max_deaths_per_match"),
         @Json(name = "avg_deaths_per_match") avg_deaths_per_match("avg_deaths_per_match"),
         @Json(name = "deaths") deaths("deaths"),
         @Json(name = "max_damage_taken_per_match") max_damage_taken_per_match("max_damage_taken_per_match"),
         @Json(name = "avg_damage_taken_per_match") avg_damage_taken_per_match("avg_damage_taken_per_match"),
         @Json(name = "damage_taken") damage_taken("damage_taken"),
         @Json(name = "max_assists_per_match") max_assists_per_match("max_assists_per_match"),
         @Json(name = "avg_assists_per_match") avg_assists_per_match("avg_assists_per_match"),
         @Json(name = "assists") assists("assists"),
         @Json(name = "max_net_worth_per_match") max_net_worth_per_match("max_net_worth_per_match"),
         @Json(name = "avg_net_worth_per_match") avg_net_worth_per_match("avg_net_worth_per_match"),
         @Json(name = "net_worth") net_worth("net_worth"),
         @Json(name = "max_last_hits_per_match") max_last_hits_per_match("max_last_hits_per_match"),
         @Json(name = "avg_last_hits_per_match") avg_last_hits_per_match("avg_last_hits_per_match"),
         @Json(name = "last_hits") last_hits("last_hits"),
         @Json(name = "max_denies_per_match") max_denies_per_match("max_denies_per_match"),
         @Json(name = "avg_denies_per_match") avg_denies_per_match("avg_denies_per_match"),
         @Json(name = "denies") denies("denies"),
         @Json(name = "max_player_level_per_match") max_player_level_per_match("max_player_level_per_match"),
         @Json(name = "avg_player_level_per_match") avg_player_level_per_match("avg_player_level_per_match"),
         @Json(name = "player_level") player_level("player_level"),
         @Json(name = "max_creep_kills_per_match") max_creep_kills_per_match("max_creep_kills_per_match"),
         @Json(name = "avg_creep_kills_per_match") avg_creep_kills_per_match("avg_creep_kills_per_match"),
         @Json(name = "creep_kills") creep_kills("creep_kills"),
         @Json(name = "max_neutral_kills_per_match") max_neutral_kills_per_match("max_neutral_kills_per_match"),
         @Json(name = "avg_neutral_kills_per_match") avg_neutral_kills_per_match("avg_neutral_kills_per_match"),
         @Json(name = "neutral_kills") neutral_kills("neutral_kills"),
         @Json(name = "max_creep_damage_per_match") max_creep_damage_per_match("max_creep_damage_per_match"),
         @Json(name = "avg_creep_damage_per_match") avg_creep_damage_per_match("avg_creep_damage_per_match"),
         @Json(name = "creep_damage") creep_damage("creep_damage"),
         @Json(name = "max_player_damage_per_match") max_player_damage_per_match("max_player_damage_per_match"),
         @Json(name = "avg_player_damage_per_match") avg_player_damage_per_match("avg_player_damage_per_match"),
         @Json(name = "player_damage") player_damage("player_damage"),
         @Json(name = "max_neutral_damage_per_match") max_neutral_damage_per_match("max_neutral_damage_per_match"),
         @Json(name = "avg_neutral_damage_per_match") avg_neutral_damage_per_match("avg_neutral_damage_per_match"),
         @Json(name = "neutral_damage") neutral_damage("neutral_damage"),
         @Json(name = "max_boss_damage_per_match") max_boss_damage_per_match("max_boss_damage_per_match"),
         @Json(name = "avg_boss_damage_per_match") avg_boss_damage_per_match("avg_boss_damage_per_match"),
         @Json(name = "boss_damage") boss_damage("boss_damage"),
         @Json(name = "max_max_health_per_match") max_max_health_per_match("max_max_health_per_match"),
         @Json(name = "avg_max_health_per_match") avg_max_health_per_match("avg_max_health_per_match"),
         @Json(name = "max_health") max_health("max_health"),
         @Json(name = "max_shots_hit_per_match") max_shots_hit_per_match("max_shots_hit_per_match"),
         @Json(name = "avg_shots_hit_per_match") avg_shots_hit_per_match("avg_shots_hit_per_match"),
         @Json(name = "shots_hit") shots_hit("shots_hit"),
         @Json(name = "max_shots_missed_per_match") max_shots_missed_per_match("max_shots_missed_per_match"),
         @Json(name = "avg_shots_missed_per_match") avg_shots_missed_per_match("avg_shots_missed_per_match"),
         @Json(name = "shots_missed") shots_missed("shots_missed"),
         @Json(name = "max_hero_bullets_hit_per_match") max_hero_bullets_hit_per_match("max_hero_bullets_hit_per_match"),
         @Json(name = "avg_hero_bullets_hit_per_match") avg_hero_bullets_hit_per_match("avg_hero_bullets_hit_per_match"),
         @Json(name = "hero_bullets_hit") hero_bullets_hit("hero_bullets_hit"),
         @Json(name = "max_hero_bullets_hit_crit_per_match") max_hero_bullets_hit_crit_per_match("max_hero_bullets_hit_crit_per_match"),
         @Json(name = "avg_hero_bullets_hit_crit_per_match") avg_hero_bullets_hit_crit_per_match("avg_hero_bullets_hit_crit_per_match"),
         @Json(name = "hero_bullets_hit_crit") hero_bullets_hit_crit("hero_bullets_hit_crit");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortDirection
     */
     enum class SortDirectionHeroScoreboard(val value: kotlin.String) {
         @Json(name = "desc") desc("desc"),
         @Json(name = "asc") asc("asc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/analytics/scoreboards/heroes
     * Hero Scoreboard
     *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param sortBy The field to sort by.
     * @param sortDirection The direction to sort heroes in. (optional)
     * @param minMatches Filter by min number of matches played. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<Entry>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun heroScoreboard(sortBy: SortByHeroScoreboard, sortDirection: SortDirectionHeroScoreboard? = null, minMatches: kotlin.Int? = null, minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, accountId: kotlin.Int? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<Entry> {
        val localVarResponse = heroScoreboardWithHttpInfo(sortBy = sortBy, sortDirection = sortDirection, minMatches = minMatches, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, accountId = accountId, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Entry>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/scoreboards/heroes
     * Hero Scoreboard
     *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param sortBy The field to sort by.
     * @param sortDirection The direction to sort heroes in. (optional)
     * @param minMatches Filter by min number of matches played. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<Entry>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun heroScoreboardWithHttpInfo(sortBy: SortByHeroScoreboard, sortDirection: SortDirectionHeroScoreboard?, minMatches: kotlin.Int?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<Entry>?> {
        val localVariableConfig = heroScoreboardRequestConfig(sortBy = sortBy, sortDirection = sortDirection, minMatches = minMatches, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, accountId = accountId, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<Entry>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation heroScoreboard
     *
     * @param sortBy The field to sort by.
     * @param sortDirection The direction to sort heroes in. (optional)
     * @param minMatches Filter by min number of matches played. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun heroScoreboardRequestConfig(sortBy: SortByHeroScoreboard, sortDirection: SortDirectionHeroScoreboard?, minMatches: kotlin.Int?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("sort_by", listOf(sortBy.value))
                if (sortDirection != null) {
                    put("sort_direction", listOf(sortDirection.value))
                }
                if (minMatches != null) {
                    put("min_matches", listOf(minMatches.toString()))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/scoreboards/heroes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter bucket
     */
     enum class BucketHeroStats(val value: kotlin.String) {
         @Json(name = "no_bucket") no_bucket("no_bucket"),
         @Json(name = "start_time_hour") start_time_hour("start_time_hour"),
         @Json(name = "start_time_day") start_time_day("start_time_day"),
         @Json(name = "start_time_week") start_time_week("start_time_week"),
         @Json(name = "start_time_month") start_time_month("start_time_month");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/analytics/hero-stats
     * Hero Stats
     *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minHeroMatches Filter players based on the number of matches they have played with a specific hero. (optional)
     * @param maxHeroMatches Filter players based on the number of matches they have played with a specific hero. (optional)
     * @param includeItemIds Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param excludeItemIds Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<AnalyticsHeroStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun heroStats(bucket: BucketHeroStats? = null, minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, minHeroMatches: kotlin.Long? = null, maxHeroMatches: kotlin.Long? = null, includeItemIds: kotlin.collections.List<kotlin.Int>? = null, excludeItemIds: kotlin.collections.List<kotlin.Int>? = null, accountId: kotlin.Int? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<AnalyticsHeroStats> {
        val localVarResponse = heroStatsWithHttpInfo(bucket = bucket, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, minHeroMatches = minHeroMatches, maxHeroMatches = maxHeroMatches, includeItemIds = includeItemIds, excludeItemIds = excludeItemIds, accountId = accountId, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<AnalyticsHeroStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/hero-stats
     * Hero Stats
     *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minHeroMatches Filter players based on the number of matches they have played with a specific hero. (optional)
     * @param maxHeroMatches Filter players based on the number of matches they have played with a specific hero. (optional)
     * @param includeItemIds Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param excludeItemIds Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<AnalyticsHeroStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun heroStatsWithHttpInfo(bucket: BucketHeroStats?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, minHeroMatches: kotlin.Long?, maxHeroMatches: kotlin.Long?, includeItemIds: kotlin.collections.List<kotlin.Int>?, excludeItemIds: kotlin.collections.List<kotlin.Int>?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<AnalyticsHeroStats>?> {
        val localVariableConfig = heroStatsRequestConfig(bucket = bucket, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, minHeroMatches = minHeroMatches, maxHeroMatches = maxHeroMatches, includeItemIds = includeItemIds, excludeItemIds = excludeItemIds, accountId = accountId, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<AnalyticsHeroStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation heroStats
     *
     * @param bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param minHeroMatches Filter players based on the number of matches they have played with a specific hero. (optional)
     * @param maxHeroMatches Filter players based on the number of matches they have played with a specific hero. (optional)
     * @param includeItemIds Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param excludeItemIds Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun heroStatsRequestConfig(bucket: BucketHeroStats?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, minHeroMatches: kotlin.Long?, maxHeroMatches: kotlin.Long?, includeItemIds: kotlin.collections.List<kotlin.Int>?, excludeItemIds: kotlin.collections.List<kotlin.Int>?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (bucket != null) {
                    put("bucket", listOf(bucket.value))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (minHeroMatches != null) {
                    put("min_hero_matches", listOf(minHeroMatches.toString()))
                }
                if (maxHeroMatches != null) {
                    put("max_hero_matches", listOf(maxHeroMatches.toString()))
                }
                if (includeItemIds != null) {
                    put("include_item_ids", toMultiValue(includeItemIds.toList(), "multi"))
                }
                if (excludeItemIds != null) {
                    put("exclude_item_ids", toMultiValue(excludeItemIds.toList(), "multi"))
                }
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/hero-stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/analytics/hero-synergy-stats
     * Hero Synergy Stats
     *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (&#x60;hero_id1&#x60; and &#x60;hero_id2&#x60;) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param sameLaneFilter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param samePartyFilter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)
     * @param minMatches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20L)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<HeroSynergyStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun heroSynergiesStats(minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, sameLaneFilter: kotlin.Boolean? = true, samePartyFilter: kotlin.Boolean? = true, minMatches: kotlin.Long? = 20L, maxMatches: kotlin.Int? = null, accountId: kotlin.Int? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<HeroSynergyStats> {
        val localVarResponse = heroSynergiesStatsWithHttpInfo(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, sameLaneFilter = sameLaneFilter, samePartyFilter = samePartyFilter, minMatches = minMatches, maxMatches = maxMatches, accountId = accountId, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<HeroSynergyStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/hero-synergy-stats
     * Hero Synergy Stats
     *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (&#x60;hero_id1&#x60; and &#x60;hero_id2&#x60;) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param sameLaneFilter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param samePartyFilter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)
     * @param minMatches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20L)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<HeroSynergyStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun heroSynergiesStatsWithHttpInfo(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, sameLaneFilter: kotlin.Boolean?, samePartyFilter: kotlin.Boolean?, minMatches: kotlin.Long?, maxMatches: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<HeroSynergyStats>?> {
        val localVariableConfig = heroSynergiesStatsRequestConfig(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, sameLaneFilter = sameLaneFilter, samePartyFilter = samePartyFilter, minMatches = minMatches, maxMatches = maxMatches, accountId = accountId, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<HeroSynergyStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation heroSynergiesStats
     *
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param sameLaneFilter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param samePartyFilter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)
     * @param minMatches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20L)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun heroSynergiesStatsRequestConfig(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, sameLaneFilter: kotlin.Boolean?, samePartyFilter: kotlin.Boolean?, minMatches: kotlin.Long?, maxMatches: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (sameLaneFilter != null) {
                    put("same_lane_filter", listOf(sameLaneFilter.toString()))
                }
                if (samePartyFilter != null) {
                    put("same_party_filter", listOf(samePartyFilter.toString()))
                }
                if (minMatches != null) {
                    put("min_matches", listOf(minMatches.toString()))
                }
                if (maxMatches != null) {
                    put("max_matches", listOf(maxMatches.toString()))
                }
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/hero-synergy-stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/analytics/item-permutation-stats
     * Item Permutation Stats
     *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param itemIds Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param combSize The combination size to return. (optional, default to 2)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param heroId Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<ItemPermutationStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun itemPermutationStats(itemIds: kotlin.collections.List<kotlin.Int>? = null, combSize: kotlin.Int? = 2, heroIds: kotlin.String? = null, heroId: kotlin.Int? = null, minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, accountId: kotlin.Int? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<ItemPermutationStats> {
        val localVarResponse = itemPermutationStatsWithHttpInfo(itemIds = itemIds, combSize = combSize, heroIds = heroIds, heroId = heroId, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, accountId = accountId, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ItemPermutationStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/item-permutation-stats
     * Item Permutation Stats
     *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param itemIds Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param combSize The combination size to return. (optional, default to 2)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param heroId Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<ItemPermutationStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun itemPermutationStatsWithHttpInfo(itemIds: kotlin.collections.List<kotlin.Int>?, combSize: kotlin.Int?, heroIds: kotlin.String?, heroId: kotlin.Int?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<ItemPermutationStats>?> {
        val localVariableConfig = itemPermutationStatsRequestConfig(itemIds = itemIds, combSize = combSize, heroIds = heroIds, heroId = heroId, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, accountId = accountId, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<ItemPermutationStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation itemPermutationStats
     *
     * @param itemIds Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param combSize The combination size to return. (optional, default to 2)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param heroId Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun itemPermutationStatsRequestConfig(itemIds: kotlin.collections.List<kotlin.Int>?, combSize: kotlin.Int?, heroIds: kotlin.String?, heroId: kotlin.Int?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (itemIds != null) {
                    put("item_ids", toMultiValue(itemIds.toList(), "multi"))
                }
                if (combSize != null) {
                    put("comb_size", listOf(combSize.toString()))
                }
                if (heroIds != null) {
                    put("hero_ids", listOf(heroIds.toString()))
                }
                if (heroId != null) {
                    put("hero_id", listOf(heroId.toString()))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/item-permutation-stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter bucket
     */
     enum class BucketItemStats(val value: kotlin.String) {
         @Json(name = "no_bucket") no_bucket("no_bucket"),
         @Json(name = "hero") hero("hero"),
         @Json(name = "team") team("team"),
         @Json(name = "start_time_hour") start_time_hour("start_time_hour"),
         @Json(name = "start_time_day") start_time_day("start_time_day"),
         @Json(name = "start_time_week") start_time_week("start_time_week"),
         @Json(name = "start_time_month") start_time_month("start_time_month"),
         @Json(name = "game_time_min") game_time_min("game_time_min"),
         @Json(name = "game_time_normalized_percentage") game_time_normalized_percentage("game_time_normalized_percentage"),
         @Json(name = "net_worth_by_1000") net_worth_by_1000("net_worth_by_1000"),
         @Json(name = "net_worth_by_2000") net_worth_by_2000("net_worth_by_2000"),
         @Json(name = "net_worth_by_3000") net_worth_by_3000("net_worth_by_3000"),
         @Json(name = "net_worth_by_5000") net_worth_by_5000("net_worth_by_5000"),
         @Json(name = "net_worth_by_10000") net_worth_by_10000("net_worth_by_10000");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/analytics/item-stats
     * Item Stats
     *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param heroId Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param includeItemIds Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param excludeItemIds Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param minMatches The minimum number of matches played for an item to be included in the response. (optional, default to 20)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<ItemStats>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun itemStats(bucket: BucketItemStats? = null, heroIds: kotlin.String? = null, heroId: kotlin.Int? = null, minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, includeItemIds: kotlin.collections.List<kotlin.Int>? = null, excludeItemIds: kotlin.collections.List<kotlin.Int>? = null, minMatches: kotlin.Int? = 20, maxMatches: kotlin.Int? = null, accountId: kotlin.Int? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<ItemStats> {
        val localVarResponse = itemStatsWithHttpInfo(bucket = bucket, heroIds = heroIds, heroId = heroId, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, includeItemIds = includeItemIds, excludeItemIds = excludeItemIds, minMatches = minMatches, maxMatches = maxMatches, accountId = accountId, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ItemStats>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/item-stats
     * Item Stats
     *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param heroId Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param includeItemIds Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param excludeItemIds Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param minMatches The minimum number of matches played for an item to be included in the response. (optional, default to 20)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<ItemStats>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun itemStatsWithHttpInfo(bucket: BucketItemStats?, heroIds: kotlin.String?, heroId: kotlin.Int?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, includeItemIds: kotlin.collections.List<kotlin.Int>?, excludeItemIds: kotlin.collections.List<kotlin.Int>?, minMatches: kotlin.Int?, maxMatches: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<ItemStats>?> {
        val localVariableConfig = itemStatsRequestConfig(bucket = bucket, heroIds = heroIds, heroId = heroId, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, includeItemIds = includeItemIds, excludeItemIds = excludeItemIds, minMatches = minMatches, maxMatches = maxMatches, accountId = accountId, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<ItemStats>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation itemStats
     *
     * @param bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param heroId Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param includeItemIds Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param excludeItemIds Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param minMatches The minimum number of matches played for an item to be included in the response. (optional, default to 20)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param accountId Filter for matches with a specific player account ID. (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun itemStatsRequestConfig(bucket: BucketItemStats?, heroIds: kotlin.String?, heroId: kotlin.Int?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, includeItemIds: kotlin.collections.List<kotlin.Int>?, excludeItemIds: kotlin.collections.List<kotlin.Int>?, minMatches: kotlin.Int?, maxMatches: kotlin.Int?, accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (bucket != null) {
                    put("bucket", listOf(bucket.value))
                }
                if (heroIds != null) {
                    put("hero_ids", listOf(heroIds.toString()))
                }
                if (heroId != null) {
                    put("hero_id", listOf(heroId.toString()))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (includeItemIds != null) {
                    put("include_item_ids", toMultiValue(includeItemIds.toList(), "multi"))
                }
                if (excludeItemIds != null) {
                    put("exclude_item_ids", toMultiValue(excludeItemIds.toList(), "multi"))
                }
                if (minMatches != null) {
                    put("min_matches", listOf(minMatches.toString()))
                }
                if (maxMatches != null) {
                    put("max_matches", listOf(maxMatches.toString()))
                }
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/item-stats",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortBy
     */
     enum class SortByPlayerScoreboard(val value: kotlin.String) {
         @Json(name = "matches") matches("matches"),
         @Json(name = "wins") wins("wins"),
         @Json(name = "losses") losses("losses"),
         @Json(name = "winrate") winrate("winrate"),
         @Json(name = "max_kills_per_match") max_kills_per_match("max_kills_per_match"),
         @Json(name = "avg_kills_per_match") avg_kills_per_match("avg_kills_per_match"),
         @Json(name = "kills") kills("kills"),
         @Json(name = "max_deaths_per_match") max_deaths_per_match("max_deaths_per_match"),
         @Json(name = "avg_deaths_per_match") avg_deaths_per_match("avg_deaths_per_match"),
         @Json(name = "deaths") deaths("deaths"),
         @Json(name = "max_damage_taken_per_match") max_damage_taken_per_match("max_damage_taken_per_match"),
         @Json(name = "avg_damage_taken_per_match") avg_damage_taken_per_match("avg_damage_taken_per_match"),
         @Json(name = "damage_taken") damage_taken("damage_taken"),
         @Json(name = "max_assists_per_match") max_assists_per_match("max_assists_per_match"),
         @Json(name = "avg_assists_per_match") avg_assists_per_match("avg_assists_per_match"),
         @Json(name = "assists") assists("assists"),
         @Json(name = "max_net_worth_per_match") max_net_worth_per_match("max_net_worth_per_match"),
         @Json(name = "avg_net_worth_per_match") avg_net_worth_per_match("avg_net_worth_per_match"),
         @Json(name = "net_worth") net_worth("net_worth"),
         @Json(name = "max_last_hits_per_match") max_last_hits_per_match("max_last_hits_per_match"),
         @Json(name = "avg_last_hits_per_match") avg_last_hits_per_match("avg_last_hits_per_match"),
         @Json(name = "last_hits") last_hits("last_hits"),
         @Json(name = "max_denies_per_match") max_denies_per_match("max_denies_per_match"),
         @Json(name = "avg_denies_per_match") avg_denies_per_match("avg_denies_per_match"),
         @Json(name = "denies") denies("denies"),
         @Json(name = "max_player_level_per_match") max_player_level_per_match("max_player_level_per_match"),
         @Json(name = "avg_player_level_per_match") avg_player_level_per_match("avg_player_level_per_match"),
         @Json(name = "player_level") player_level("player_level"),
         @Json(name = "max_creep_kills_per_match") max_creep_kills_per_match("max_creep_kills_per_match"),
         @Json(name = "avg_creep_kills_per_match") avg_creep_kills_per_match("avg_creep_kills_per_match"),
         @Json(name = "creep_kills") creep_kills("creep_kills"),
         @Json(name = "max_neutral_kills_per_match") max_neutral_kills_per_match("max_neutral_kills_per_match"),
         @Json(name = "avg_neutral_kills_per_match") avg_neutral_kills_per_match("avg_neutral_kills_per_match"),
         @Json(name = "neutral_kills") neutral_kills("neutral_kills"),
         @Json(name = "max_creep_damage_per_match") max_creep_damage_per_match("max_creep_damage_per_match"),
         @Json(name = "avg_creep_damage_per_match") avg_creep_damage_per_match("avg_creep_damage_per_match"),
         @Json(name = "creep_damage") creep_damage("creep_damage"),
         @Json(name = "max_player_damage_per_match") max_player_damage_per_match("max_player_damage_per_match"),
         @Json(name = "avg_player_damage_per_match") avg_player_damage_per_match("avg_player_damage_per_match"),
         @Json(name = "player_damage") player_damage("player_damage"),
         @Json(name = "max_neutral_damage_per_match") max_neutral_damage_per_match("max_neutral_damage_per_match"),
         @Json(name = "avg_neutral_damage_per_match") avg_neutral_damage_per_match("avg_neutral_damage_per_match"),
         @Json(name = "neutral_damage") neutral_damage("neutral_damage"),
         @Json(name = "max_boss_damage_per_match") max_boss_damage_per_match("max_boss_damage_per_match"),
         @Json(name = "avg_boss_damage_per_match") avg_boss_damage_per_match("avg_boss_damage_per_match"),
         @Json(name = "boss_damage") boss_damage("boss_damage"),
         @Json(name = "max_max_health_per_match") max_max_health_per_match("max_max_health_per_match"),
         @Json(name = "avg_max_health_per_match") avg_max_health_per_match("avg_max_health_per_match"),
         @Json(name = "max_health") max_health("max_health"),
         @Json(name = "max_shots_hit_per_match") max_shots_hit_per_match("max_shots_hit_per_match"),
         @Json(name = "avg_shots_hit_per_match") avg_shots_hit_per_match("avg_shots_hit_per_match"),
         @Json(name = "shots_hit") shots_hit("shots_hit"),
         @Json(name = "max_shots_missed_per_match") max_shots_missed_per_match("max_shots_missed_per_match"),
         @Json(name = "avg_shots_missed_per_match") avg_shots_missed_per_match("avg_shots_missed_per_match"),
         @Json(name = "shots_missed") shots_missed("shots_missed"),
         @Json(name = "max_hero_bullets_hit_per_match") max_hero_bullets_hit_per_match("max_hero_bullets_hit_per_match"),
         @Json(name = "avg_hero_bullets_hit_per_match") avg_hero_bullets_hit_per_match("avg_hero_bullets_hit_per_match"),
         @Json(name = "hero_bullets_hit") hero_bullets_hit("hero_bullets_hit"),
         @Json(name = "max_hero_bullets_hit_crit_per_match") max_hero_bullets_hit_crit_per_match("max_hero_bullets_hit_crit_per_match"),
         @Json(name = "avg_hero_bullets_hit_crit_per_match") avg_hero_bullets_hit_crit_per_match("avg_hero_bullets_hit_crit_per_match"),
         @Json(name = "hero_bullets_hit_crit") hero_bullets_hit_crit("hero_bullets_hit_crit");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sortDirection
     */
     enum class SortDirectionPlayerScoreboard(val value: kotlin.String) {
         @Json(name = "desc") desc("desc"),
         @Json(name = "asc") asc("asc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/analytics/scoreboards/players
     * Player Scoreboard
     *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param sortBy The field to sort by.
     * @param sortDirection The direction to sort players in. (optional)
     * @param heroId Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minMatches The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param start The offset to start fetching players from. (optional)
     * @param limit The maximum number of players to fetch. (optional, default to 100)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<Entry>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun playerScoreboard(sortBy: SortByPlayerScoreboard, sortDirection: SortDirectionPlayerScoreboard? = null, heroId: kotlin.Int? = null, minMatches: kotlin.Int? = 20, maxMatches: kotlin.Int? = null, minUnixTimestamp: kotlin.Long? = null, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, start: kotlin.Int? = null, limit: kotlin.Int? = 100, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<Entry> {
        val localVarResponse = playerScoreboardWithHttpInfo(sortBy = sortBy, sortDirection = sortDirection, heroId = heroId, minMatches = minMatches, maxMatches = maxMatches, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, start = start, limit = limit, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<Entry>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/scoreboards/players
     * Player Scoreboard
     *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param sortBy The field to sort by.
     * @param sortDirection The direction to sort players in. (optional)
     * @param heroId Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minMatches The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param start The offset to start fetching players from. (optional)
     * @param limit The maximum number of players to fetch. (optional, default to 100)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<Entry>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun playerScoreboardWithHttpInfo(sortBy: SortByPlayerScoreboard, sortDirection: SortDirectionPlayerScoreboard?, heroId: kotlin.Int?, minMatches: kotlin.Int?, maxMatches: kotlin.Int?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<Entry>?> {
        val localVariableConfig = playerScoreboardRequestConfig(sortBy = sortBy, sortDirection = sortDirection, heroId = heroId, minMatches = minMatches, maxMatches = maxMatches, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, start = start, limit = limit, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<Entry>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation playerScoreboard
     *
     * @param sortBy The field to sort by.
     * @param sortDirection The direction to sort players in. (optional)
     * @param heroId Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minMatches The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)
     * @param maxMatches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param start The offset to start fetching players from. (optional)
     * @param limit The maximum number of players to fetch. (optional, default to 100)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun playerScoreboardRequestConfig(sortBy: SortByPlayerScoreboard, sortDirection: SortDirectionPlayerScoreboard?, heroId: kotlin.Int?, minMatches: kotlin.Int?, maxMatches: kotlin.Int?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, start: kotlin.Int?, limit: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("sort_by", listOf(sortBy.value))
                if (sortDirection != null) {
                    put("sort_direction", listOf(sortDirection.value))
                }
                if (heroId != null) {
                    put("hero_id", listOf(heroId.toString()))
                }
                if (minMatches != null) {
                    put("min_matches", listOf(minMatches.toString()))
                }
                if (maxMatches != null) {
                    put("max_matches", listOf(maxMatches.toString()))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (start != null) {
                    put("start", listOf(start.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/scoreboards/players",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/analytics/player-stats/metrics
     * Player Stats Metrics
     *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  &gt; Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param maxMatches The maximum number of matches to analyze. (optional)
     * @param includeItemIds Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param excludeItemIds Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.Map<kotlin.String, HashMapValue>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun playerStatsMetrics(heroIds: kotlin.String? = null, minUnixTimestamp: kotlin.Long? = 1755561600L, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minNetworth: kotlin.Long? = null, maxNetworth: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, maxMatches: kotlin.Int? = null, includeItemIds: kotlin.collections.List<kotlin.Int>? = null, excludeItemIds: kotlin.collections.List<kotlin.Int>? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.Map<kotlin.String, HashMapValue> {
        val localVarResponse = playerStatsMetricsWithHttpInfo(heroIds = heroIds, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, maxMatches = maxMatches, includeItemIds = includeItemIds, excludeItemIds = excludeItemIds, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, HashMapValue>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/analytics/player-stats/metrics
     * Player Stats Metrics
     *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  &gt; Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param maxMatches The maximum number of matches to analyze. (optional)
     * @param includeItemIds Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param excludeItemIds Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, HashMapValue>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun playerStatsMetricsWithHttpInfo(heroIds: kotlin.String?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, maxMatches: kotlin.Int?, includeItemIds: kotlin.collections.List<kotlin.Int>?, excludeItemIds: kotlin.collections.List<kotlin.Int>?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.Map<kotlin.String, HashMapValue>?> {
        val localVariableConfig = playerStatsMetricsRequestConfig(heroIds = heroIds, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minNetworth = minNetworth, maxNetworth = maxNetworth, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, maxMatches = maxMatches, includeItemIds = includeItemIds, excludeItemIds = excludeItemIds, accountIds = accountIds)

        return request<Unit, kotlin.collections.Map<kotlin.String, HashMapValue>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation playerStatsMetrics
     *
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1755561600L)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minNetworth Filter players based on their net worth. (optional)
     * @param maxNetworth Filter players based on their net worth. (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param maxMatches The maximum number of matches to analyze. (optional)
     * @param includeItemIds Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param excludeItemIds Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun playerStatsMetricsRequestConfig(heroIds: kotlin.String?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minNetworth: kotlin.Long?, maxNetworth: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, maxMatches: kotlin.Int?, includeItemIds: kotlin.collections.List<kotlin.Int>?, excludeItemIds: kotlin.collections.List<kotlin.Int>?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (heroIds != null) {
                    put("hero_ids", listOf(heroIds.toString()))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minNetworth != null) {
                    put("min_networth", listOf(minNetworth.toString()))
                }
                if (maxNetworth != null) {
                    put("max_networth", listOf(maxNetworth.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (maxMatches != null) {
                    put("max_matches", listOf(maxMatches.toString()))
                }
                if (includeItemIds != null) {
                    put("include_item_ids", toMultiValue(includeItemIds.toList(), "multi"))
                }
                if (excludeItemIds != null) {
                    put("exclude_item_ids", toMultiValue(excludeItemIds.toList(), "multi"))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/analytics/player-stats/metrics",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
