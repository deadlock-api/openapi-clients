/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package deadlock-api-client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import deadlock-api-client.models.ActiveMatch
import deadlock-api-client.models.BadgeDistribution
import deadlock-api-client.models.ClickhouseMatchInfo
import deadlock-api-client.models.MatchSaltsResponse
import deadlock-api-client.models.MatchSpectateResponse

import com.squareup.moshi.Json

import deadlock-api-client.infrastructure.ApiClient
import deadlock-api-client.infrastructure.ApiResponse
import deadlock-api-client.infrastructure.ClientException
import deadlock-api-client.infrastructure.ClientError
import deadlock-api-client.infrastructure.ServerException
import deadlock-api-client.infrastructure.ServerError
import deadlock-api-client.infrastructure.MultiValueMap
import deadlock-api-client.infrastructure.PartConfig
import deadlock-api-client.infrastructure.RequestConfig
import deadlock-api-client.infrastructure.RequestMethod
import deadlock-api-client.infrastructure.ResponseType
import deadlock-api-client.infrastructure.Success
import deadlock-api-client.infrastructure.toMultiValue

class MatchesApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.deadlock-api.com")
        }
    }

    /**
     * GET /v1/matches/active
     * Active
     *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountId The account ID to filter active matches by (&#x60;SteamID3&#x60;) (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return kotlin.collections.List<ActiveMatch>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun activeMatches(accountId: kotlin.Int? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null) : kotlin.collections.List<ActiveMatch> {
        val localVarResponse = activeMatchesWithHttpInfo(accountId = accountId, accountIds = accountIds)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ActiveMatch>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/matches/active
     * Active
     *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param accountId The account ID to filter active matches by (&#x60;SteamID3&#x60;) (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return ApiResponse<kotlin.collections.List<ActiveMatch>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun activeMatchesWithHttpInfo(accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : ApiResponse<kotlin.collections.List<ActiveMatch>?> {
        val localVariableConfig = activeMatchesRequestConfig(accountId = accountId, accountIds = accountIds)

        return request<Unit, kotlin.collections.List<ActiveMatch>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activeMatches
     *
     * @param accountId The account ID to filter active matches by (&#x60;SteamID3&#x60;) (optional)
     * @param accountIds Comma separated list of account ids to include (optional)
     * @return RequestConfig
     */
    fun activeMatchesRequestConfig(accountId: kotlin.Int?, accountIds: kotlin.collections.List<kotlin.Int>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/matches/active",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/matches/active/raw
     * Active as Protobuf
     *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @return kotlin.collections.List<kotlin.Int>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun activeMatchesRaw() : kotlin.collections.List<kotlin.Int> {
        val localVarResponse = activeMatchesRawWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Int>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/matches/active/raw
     * Active as Protobuf
     *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @return ApiResponse<kotlin.collections.List<kotlin.Int>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun activeMatchesRawWithHttpInfo() : ApiResponse<kotlin.collections.List<kotlin.Int>?> {
        val localVariableConfig = activeMatchesRawRequestConfig()

        return request<Unit, kotlin.collections.List<kotlin.Int>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation activeMatchesRaw
     *
     * @return RequestConfig
     */
    fun activeMatchesRawRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/octet-stream"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/matches/active/raw",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/matches/badge-distribution
     * Badge Distribution
     *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return kotlin.collections.List<BadgeDistribution>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun badgeDistribution(minUnixTimestamp: kotlin.Long? = null, maxUnixTimestamp: kotlin.Long? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null) : kotlin.collections.List<BadgeDistribution> {
        val localVarResponse = badgeDistributionWithHttpInfo(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minMatchId = minMatchId, maxMatchId = maxMatchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BadgeDistribution>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/matches/badge-distribution
     * Badge Distribution
     *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return ApiResponse<kotlin.collections.List<BadgeDistribution>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun badgeDistributionWithHttpInfo(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?) : ApiResponse<kotlin.collections.List<BadgeDistribution>?> {
        val localVariableConfig = badgeDistributionRequestConfig(minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minMatchId = minMatchId, maxMatchId = maxMatchId)

        return request<Unit, kotlin.collections.List<BadgeDistribution>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation badgeDistribution
     *
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @return RequestConfig
     */
    fun badgeDistributionRequestConfig(minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/matches/badge-distribution",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter orderBy
     */
     enum class OrderByBulkMetadata(val value: kotlin.String) {
         @Json(name = "match_id") match_id("match_id"),
         @Json(name = "start_time") start_time("start_time");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter orderDirection
     */
     enum class OrderDirectionBulkMetadata(val value: kotlin.String) {
         @Json(name = "desc") desc("desc"),
         @Json(name = "asc") asc("asc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/matches/metadata
     * Bulk Metadata
     *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
     * @param includeInfo Include match info in the response. (optional, default to true)
     * @param includeObjectives Include objectives in the response. (optional)
     * @param includeMidBoss Include midboss in the response. (optional)
     * @param includePlayerInfo Include player info in the response. (optional)
     * @param includePlayerItems Include player items in the response. (optional)
     * @param includePlayerStats Include player stats in the response. (optional)
     * @param includePlayerDeathDetails Include player death details in the response. (optional)
     * @param matchIds Comma separated list of match ids, limited by &#x60;limit&#x60; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param isHighSkillRangeParties Filter matches based on whether they are in the high skill range. (optional)
     * @param isLowPriPool Filter matches based on whether they are in the low priority pool. (optional)
     * @param isNewPlayerPool Filter matches based on whether they are in the new player pool. (optional)
     * @param accountIds Filter matches by account IDs of players that participated in the match. (optional)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param orderBy The field to order the results by. (optional)
     * @param orderDirection The direction to order the results by. (optional)
     * @param limit The maximum number of matches to return. (optional, default to 1000)
     * @return kotlin.collections.List<kotlin.Int>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun bulkMetadata(includeInfo: kotlin.Boolean? = true, includeObjectives: kotlin.Boolean? = null, includeMidBoss: kotlin.Boolean? = null, includePlayerInfo: kotlin.Boolean? = null, includePlayerItems: kotlin.Boolean? = null, includePlayerStats: kotlin.Boolean? = null, includePlayerDeathDetails: kotlin.Boolean? = null, matchIds: kotlin.collections.List<kotlin.Long>? = null, minUnixTimestamp: kotlin.Long? = null, maxUnixTimestamp: kotlin.Long? = null, minDurationS: kotlin.Long? = null, maxDurationS: kotlin.Long? = null, minAverageBadge: kotlin.Int? = null, maxAverageBadge: kotlin.Int? = null, minMatchId: kotlin.Long? = null, maxMatchId: kotlin.Long? = null, isHighSkillRangeParties: kotlin.Boolean? = null, isLowPriPool: kotlin.Boolean? = null, isNewPlayerPool: kotlin.Boolean? = null, accountIds: kotlin.collections.List<kotlin.Int>? = null, heroIds: kotlin.String? = null, orderBy: OrderByBulkMetadata? = null, orderDirection: OrderDirectionBulkMetadata? = null, limit: kotlin.Int? = 1000) : kotlin.collections.List<kotlin.Int> {
        val localVarResponse = bulkMetadataWithHttpInfo(includeInfo = includeInfo, includeObjectives = includeObjectives, includeMidBoss = includeMidBoss, includePlayerInfo = includePlayerInfo, includePlayerItems = includePlayerItems, includePlayerStats = includePlayerStats, includePlayerDeathDetails = includePlayerDeathDetails, matchIds = matchIds, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, isHighSkillRangeParties = isHighSkillRangeParties, isLowPriPool = isLowPriPool, isNewPlayerPool = isNewPlayerPool, accountIds = accountIds, heroIds = heroIds, orderBy = orderBy, orderDirection = orderDirection, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Int>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/matches/metadata
     * Bulk Metadata
     *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
     * @param includeInfo Include match info in the response. (optional, default to true)
     * @param includeObjectives Include objectives in the response. (optional)
     * @param includeMidBoss Include midboss in the response. (optional)
     * @param includePlayerInfo Include player info in the response. (optional)
     * @param includePlayerItems Include player items in the response. (optional)
     * @param includePlayerStats Include player stats in the response. (optional)
     * @param includePlayerDeathDetails Include player death details in the response. (optional)
     * @param matchIds Comma separated list of match ids, limited by &#x60;limit&#x60; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param isHighSkillRangeParties Filter matches based on whether they are in the high skill range. (optional)
     * @param isLowPriPool Filter matches based on whether they are in the low priority pool. (optional)
     * @param isNewPlayerPool Filter matches based on whether they are in the new player pool. (optional)
     * @param accountIds Filter matches by account IDs of players that participated in the match. (optional)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param orderBy The field to order the results by. (optional)
     * @param orderDirection The direction to order the results by. (optional)
     * @param limit The maximum number of matches to return. (optional, default to 1000)
     * @return ApiResponse<kotlin.collections.List<kotlin.Int>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun bulkMetadataWithHttpInfo(includeInfo: kotlin.Boolean?, includeObjectives: kotlin.Boolean?, includeMidBoss: kotlin.Boolean?, includePlayerInfo: kotlin.Boolean?, includePlayerItems: kotlin.Boolean?, includePlayerStats: kotlin.Boolean?, includePlayerDeathDetails: kotlin.Boolean?, matchIds: kotlin.collections.List<kotlin.Long>?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, isHighSkillRangeParties: kotlin.Boolean?, isLowPriPool: kotlin.Boolean?, isNewPlayerPool: kotlin.Boolean?, accountIds: kotlin.collections.List<kotlin.Int>?, heroIds: kotlin.String?, orderBy: OrderByBulkMetadata?, orderDirection: OrderDirectionBulkMetadata?, limit: kotlin.Int?) : ApiResponse<kotlin.collections.List<kotlin.Int>?> {
        val localVariableConfig = bulkMetadataRequestConfig(includeInfo = includeInfo, includeObjectives = includeObjectives, includeMidBoss = includeMidBoss, includePlayerInfo = includePlayerInfo, includePlayerItems = includePlayerItems, includePlayerStats = includePlayerStats, includePlayerDeathDetails = includePlayerDeathDetails, matchIds = matchIds, minUnixTimestamp = minUnixTimestamp, maxUnixTimestamp = maxUnixTimestamp, minDurationS = minDurationS, maxDurationS = maxDurationS, minAverageBadge = minAverageBadge, maxAverageBadge = maxAverageBadge, minMatchId = minMatchId, maxMatchId = maxMatchId, isHighSkillRangeParties = isHighSkillRangeParties, isLowPriPool = isLowPriPool, isNewPlayerPool = isNewPlayerPool, accountIds = accountIds, heroIds = heroIds, orderBy = orderBy, orderDirection = orderDirection, limit = limit)

        return request<Unit, kotlin.collections.List<kotlin.Int>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation bulkMetadata
     *
     * @param includeInfo Include match info in the response. (optional, default to true)
     * @param includeObjectives Include objectives in the response. (optional)
     * @param includeMidBoss Include midboss in the response. (optional)
     * @param includePlayerInfo Include player info in the response. (optional)
     * @param includePlayerItems Include player items in the response. (optional)
     * @param includePlayerStats Include player stats in the response. (optional)
     * @param includePlayerDeathDetails Include player death details in the response. (optional)
     * @param matchIds Comma separated list of match ids, limited by &#x60;limit&#x60; (optional)
     * @param minUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param maxUnixTimestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param minDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param maxDurationS Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param minAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param maxAverageBadge Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param minMatchId Filter matches based on their ID. (optional)
     * @param maxMatchId Filter matches based on their ID. (optional)
     * @param isHighSkillRangeParties Filter matches based on whether they are in the high skill range. (optional)
     * @param isLowPriPool Filter matches based on whether they are in the low priority pool. (optional)
     * @param isNewPlayerPool Filter matches based on whether they are in the new player pool. (optional)
     * @param accountIds Filter matches by account IDs of players that participated in the match. (optional)
     * @param heroIds Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param orderBy The field to order the results by. (optional)
     * @param orderDirection The direction to order the results by. (optional)
     * @param limit The maximum number of matches to return. (optional, default to 1000)
     * @return RequestConfig
     */
    fun bulkMetadataRequestConfig(includeInfo: kotlin.Boolean?, includeObjectives: kotlin.Boolean?, includeMidBoss: kotlin.Boolean?, includePlayerInfo: kotlin.Boolean?, includePlayerItems: kotlin.Boolean?, includePlayerStats: kotlin.Boolean?, includePlayerDeathDetails: kotlin.Boolean?, matchIds: kotlin.collections.List<kotlin.Long>?, minUnixTimestamp: kotlin.Long?, maxUnixTimestamp: kotlin.Long?, minDurationS: kotlin.Long?, maxDurationS: kotlin.Long?, minAverageBadge: kotlin.Int?, maxAverageBadge: kotlin.Int?, minMatchId: kotlin.Long?, maxMatchId: kotlin.Long?, isHighSkillRangeParties: kotlin.Boolean?, isLowPriPool: kotlin.Boolean?, isNewPlayerPool: kotlin.Boolean?, accountIds: kotlin.collections.List<kotlin.Int>?, heroIds: kotlin.String?, orderBy: OrderByBulkMetadata?, orderDirection: OrderDirectionBulkMetadata?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (includeInfo != null) {
                    put("include_info", listOf(includeInfo.toString()))
                }
                if (includeObjectives != null) {
                    put("include_objectives", listOf(includeObjectives.toString()))
                }
                if (includeMidBoss != null) {
                    put("include_mid_boss", listOf(includeMidBoss.toString()))
                }
                if (includePlayerInfo != null) {
                    put("include_player_info", listOf(includePlayerInfo.toString()))
                }
                if (includePlayerItems != null) {
                    put("include_player_items", listOf(includePlayerItems.toString()))
                }
                if (includePlayerStats != null) {
                    put("include_player_stats", listOf(includePlayerStats.toString()))
                }
                if (includePlayerDeathDetails != null) {
                    put("include_player_death_details", listOf(includePlayerDeathDetails.toString()))
                }
                if (matchIds != null) {
                    put("match_ids", toMultiValue(matchIds.toList(), "multi"))
                }
                if (minUnixTimestamp != null) {
                    put("min_unix_timestamp", listOf(minUnixTimestamp.toString()))
                }
                if (maxUnixTimestamp != null) {
                    put("max_unix_timestamp", listOf(maxUnixTimestamp.toString()))
                }
                if (minDurationS != null) {
                    put("min_duration_s", listOf(minDurationS.toString()))
                }
                if (maxDurationS != null) {
                    put("max_duration_s", listOf(maxDurationS.toString()))
                }
                if (minAverageBadge != null) {
                    put("min_average_badge", listOf(minAverageBadge.toString()))
                }
                if (maxAverageBadge != null) {
                    put("max_average_badge", listOf(maxAverageBadge.toString()))
                }
                if (minMatchId != null) {
                    put("min_match_id", listOf(minMatchId.toString()))
                }
                if (maxMatchId != null) {
                    put("max_match_id", listOf(maxMatchId.toString()))
                }
                if (isHighSkillRangeParties != null) {
                    put("is_high_skill_range_parties", listOf(isHighSkillRangeParties.toString()))
                }
                if (isLowPriPool != null) {
                    put("is_low_pri_pool", listOf(isLowPriPool.toString()))
                }
                if (isNewPlayerPool != null) {
                    put("is_new_player_pool", listOf(isNewPlayerPool.toString()))
                }
                if (accountIds != null) {
                    put("account_ids", toMultiValue(accountIds.toList(), "multi"))
                }
                if (heroIds != null) {
                    put("hero_ids", listOf(heroIds.toString()))
                }
                if (orderBy != null) {
                    put("order_by", listOf(orderBy.value))
                }
                if (orderDirection != null) {
                    put("order_direction", listOf(orderDirection.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/octet-stream"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/matches/metadata",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/matches/{match_id}/metadata
     * Metadata
     *  This endpoint returns the match metadata for the given &#x60;match_id&#x60; parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 10req/30mins | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 10req/min | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 10req/10s |     
     * @param matchId The match ID
     * @param isCustom  (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun metadata(matchId: kotlin.Long, isCustom: kotlin.Boolean? = null) : Unit {
        val localVarResponse = metadataWithHttpInfo(matchId = matchId, isCustom = isCustom)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/matches/{match_id}/metadata
     * Metadata
     *  This endpoint returns the match metadata for the given &#x60;match_id&#x60; parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 10req/30mins | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 10req/min | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 10req/10s |     
     * @param matchId The match ID
     * @param isCustom  (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun metadataWithHttpInfo(matchId: kotlin.Long, isCustom: kotlin.Boolean?) : ApiResponse<Unit?> {
        val localVariableConfig = metadataRequestConfig(matchId = matchId, isCustom = isCustom)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation metadata
     *
     * @param matchId The match ID
     * @param isCustom  (optional)
     * @return RequestConfig
     */
    fun metadataRequestConfig(matchId: kotlin.Long, isCustom: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (isCustom != null) {
                    put("is_custom", listOf(isCustom.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/matches/{match_id}/metadata".replace("{"+"match_id"+"}", encodeURIComponent(matchId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/matches/{match_id}/metadata/raw
     * Metadata as Protobuf
     *  This endpoints returns the raw .meta.bz2 file for the given &#x60;match_id&#x60;.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 10req/30mins | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 10req/min | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 10req/10s |     
     * @param matchId The match ID
     * @param isCustom  (optional)
     * @return kotlin.collections.List<kotlin.Int>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun metadataRaw(matchId: kotlin.Long, isCustom: kotlin.Boolean? = null) : kotlin.collections.List<kotlin.Int> {
        val localVarResponse = metadataRawWithHttpInfo(matchId = matchId, isCustom = isCustom)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<kotlin.Int>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/matches/{match_id}/metadata/raw
     * Metadata as Protobuf
     *  This endpoints returns the raw .meta.bz2 file for the given &#x60;match_id&#x60;.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 10req/30mins | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 10req/min | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 10req/10s |     
     * @param matchId The match ID
     * @param isCustom  (optional)
     * @return ApiResponse<kotlin.collections.List<kotlin.Int>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun metadataRawWithHttpInfo(matchId: kotlin.Long, isCustom: kotlin.Boolean?) : ApiResponse<kotlin.collections.List<kotlin.Int>?> {
        val localVariableConfig = metadataRawRequestConfig(matchId = matchId, isCustom = isCustom)

        return request<Unit, kotlin.collections.List<kotlin.Int>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation metadataRaw
     *
     * @param matchId The match ID
     * @param isCustom  (optional)
     * @return RequestConfig
     */
    fun metadataRawRequestConfig(matchId: kotlin.Long, isCustom: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (isCustom != null) {
                    put("is_custom", listOf(isCustom.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/octet-stream"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/matches/{match_id}/metadata/raw".replace("{"+"match_id"+"}", encodeURIComponent(matchId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/matches/recently-fetched
     * Recently Fetched
     *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @return kotlin.collections.List<ClickhouseMatchInfo>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun recentlyFetched() : kotlin.collections.List<ClickhouseMatchInfo> {
        val localVarResponse = recentlyFetchedWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ClickhouseMatchInfo>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/matches/recently-fetched
     * Recently Fetched
     *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @return ApiResponse<kotlin.collections.List<ClickhouseMatchInfo>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun recentlyFetchedWithHttpInfo() : ApiResponse<kotlin.collections.List<ClickhouseMatchInfo>?> {
        val localVariableConfig = recentlyFetchedRequestConfig()

        return request<Unit, kotlin.collections.List<ClickhouseMatchInfo>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation recentlyFetched
     *
     * @return RequestConfig
     */
    fun recentlyFetchedRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/matches/recently-fetched",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/matches/{match_id}/salts
     * Salts
     *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s&lt;br&gt;From Steam: 10req/30mins | | Key | From DB: -&lt;br&gt;From Steam: 10req/min | | Global | From DB: -&lt;br&gt;From Steam: 10req/10s |     
     * @param matchId The match ID
     * @return MatchSaltsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun salts(matchId: kotlin.Long) : MatchSaltsResponse {
        val localVarResponse = saltsWithHttpInfo(matchId = matchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MatchSaltsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/matches/{match_id}/salts
     * Salts
     *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s&lt;br&gt;From Steam: 10req/30mins | | Key | From DB: -&lt;br&gt;From Steam: 10req/min | | Global | From DB: -&lt;br&gt;From Steam: 10req/10s |     
     * @param matchId The match ID
     * @return ApiResponse<MatchSaltsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun saltsWithHttpInfo(matchId: kotlin.Long) : ApiResponse<MatchSaltsResponse?> {
        val localVariableConfig = saltsRequestConfig(matchId = matchId)

        return request<Unit, MatchSaltsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation salts
     *
     * @param matchId The match ID
     * @return RequestConfig
     */
    fun saltsRequestConfig(matchId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/matches/{match_id}/salts".replace("{"+"match_id"+"}", encodeURIComponent(matchId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/matches/{match_id}/live/url
     * Live Broadcast URL
     *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
     * @param matchId The match ID
     * @return MatchSpectateResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun url(matchId: kotlin.Long) : MatchSpectateResponse {
        val localVarResponse = urlWithHttpInfo(matchId = matchId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MatchSpectateResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/matches/{match_id}/live/url
     * Live Broadcast URL
     *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
     * @param matchId The match ID
     * @return ApiResponse<MatchSpectateResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun urlWithHttpInfo(matchId: kotlin.Long) : ApiResponse<MatchSpectateResponse?> {
        val localVariableConfig = urlRequestConfig(matchId = matchId)

        return request<Unit, MatchSpectateResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation url
     *
     * @param matchId The match ID
     * @return RequestConfig
     */
    fun urlRequestConfig(matchId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/matches/{match_id}/live/url".replace("{"+"match_id"+"}", encodeURIComponent(matchId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
