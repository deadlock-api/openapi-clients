// <auto-generated>
/*
 * Deadlock API
 *
 *  ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using DeadlockApiClient.Client;
using DeadlockApiClient.Model;
using System.Diagnostics.CodeAnalysis;

namespace DeadlockApiClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IMMRApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        MMRApiEvents Events { get; }

        /// <summary>
        /// Batch Hero MMR
        /// </summary>
        /// <remarks>
        ///  Batch Player Hero MMR 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrApiResponse"/>&gt;</returns>
        Task<IHeroMmrApiResponse> HeroMmrAsync(List<int> accountIds, int heroId, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Batch Hero MMR
        /// </summary>
        /// <remarks>
        ///  Batch Player Hero MMR 
        /// </remarks>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrApiResponse"/>?&gt;</returns>
        Task<IHeroMmrApiResponse?> HeroMmrOrDefaultAsync(List<int> accountIds, int heroId, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero MMR Distribution
        /// </summary>
        /// <remarks>
        ///  Player Hero MMR Distribution 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1767484800)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrDistributionApiResponse"/>&gt;</returns>
        Task<IHeroMmrDistributionApiResponse> HeroMmrDistributionAsync(int heroId, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero MMR Distribution
        /// </summary>
        /// <remarks>
        ///  Player Hero MMR Distribution 
        /// </remarks>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1767484800)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrDistributionApiResponse"/>?&gt;</returns>
        Task<IHeroMmrDistributionApiResponse?> HeroMmrDistributionOrDefaultAsync(int heroId, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero MMR History
        /// </summary>
        /// <remarks>
        /// Player Hero MMR History
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrHistoryApiResponse"/>&gt;</returns>
        Task<IHeroMmrHistoryApiResponse> HeroMmrHistoryAsync(int accountId, int heroId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero MMR History
        /// </summary>
        /// <remarks>
        /// Player Hero MMR History
        /// </remarks>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrHistoryApiResponse"/>?&gt;</returns>
        Task<IHeroMmrHistoryApiResponse?> HeroMmrHistoryOrDefaultAsync(int accountId, int heroId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Batch MMR
        /// </summary>
        /// <remarks>
        ///  Batch Player MMR 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrApiResponse"/>&gt;</returns>
        Task<IMmrApiResponse> MmrAsync(List<int> accountIds, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Batch MMR
        /// </summary>
        /// <remarks>
        ///  Batch Player MMR 
        /// </remarks>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrApiResponse"/>?&gt;</returns>
        Task<IMmrApiResponse?> MmrOrDefaultAsync(List<int> accountIds, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// MMR Distribution
        /// </summary>
        /// <remarks>
        ///  Player MMR Distribution 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1767484800)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrDistributionApiResponse"/>&gt;</returns>
        Task<IMmrDistributionApiResponse> MmrDistributionAsync(Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// MMR Distribution
        /// </summary>
        /// <remarks>
        ///  Player MMR Distribution 
        /// </remarks>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1767484800)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrDistributionApiResponse"/>?&gt;</returns>
        Task<IMmrDistributionApiResponse?> MmrDistributionOrDefaultAsync(Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// MMR History
        /// </summary>
        /// <remarks>
        /// Player MMR History
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrHistoryApiResponse"/>&gt;</returns>
        Task<IMmrHistoryApiResponse> MmrHistoryAsync(int accountId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// MMR History
        /// </summary>
        /// <remarks>
        /// Player MMR History
        /// </remarks>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrHistoryApiResponse"/>?&gt;</returns>
        Task<IMmrHistoryApiResponse?> MmrHistoryOrDefaultAsync(int accountId, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IHeroMmrApiResponse"/>
    /// </summary>
    public interface IHeroMmrApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<MMRHistory>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IHeroMmrDistributionApiResponse"/>
    /// </summary>
    public interface IHeroMmrDistributionApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<DistributionEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IHeroMmrHistoryApiResponse"/>
    /// </summary>
    public interface IHeroMmrHistoryApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<MMRHistory>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IMmrApiResponse"/>
    /// </summary>
    public interface IMmrApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<MMRHistory>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IMmrDistributionApiResponse"/>
    /// </summary>
    public interface IMmrDistributionApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<DistributionEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IMmrHistoryApiResponse"/>
    /// </summary>
    public interface IMmrHistoryApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<MMRHistory>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class MMRApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnHeroMmr;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorHeroMmr;

        internal void ExecuteOnHeroMmr(MMRApi.HeroMmrApiResponse apiResponse)
        {
            OnHeroMmr?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorHeroMmr(Exception exception)
        {
            OnErrorHeroMmr?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnHeroMmrDistribution;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorHeroMmrDistribution;

        internal void ExecuteOnHeroMmrDistribution(MMRApi.HeroMmrDistributionApiResponse apiResponse)
        {
            OnHeroMmrDistribution?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorHeroMmrDistribution(Exception exception)
        {
            OnErrorHeroMmrDistribution?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnHeroMmrHistory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorHeroMmrHistory;

        internal void ExecuteOnHeroMmrHistory(MMRApi.HeroMmrHistoryApiResponse apiResponse)
        {
            OnHeroMmrHistory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorHeroMmrHistory(Exception exception)
        {
            OnErrorHeroMmrHistory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnMmr;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorMmr;

        internal void ExecuteOnMmr(MMRApi.MmrApiResponse apiResponse)
        {
            OnMmr?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMmr(Exception exception)
        {
            OnErrorMmr?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnMmrDistribution;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorMmrDistribution;

        internal void ExecuteOnMmrDistribution(MMRApi.MmrDistributionApiResponse apiResponse)
        {
            OnMmrDistribution?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMmrDistribution(Exception exception)
        {
            OnErrorMmrDistribution?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnMmrHistory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorMmrHistory;

        internal void ExecuteOnMmrHistory(MMRApi.MmrHistoryApiResponse apiResponse)
        {
            OnMmrHistory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMmrHistory(Exception exception)
        {
            OnErrorMmrHistory?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class MMRApi : IMMRApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<MMRApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public MMRApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MMRApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MMRApi(ILogger<MMRApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, MMRApiEvents mMRApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<MMRApi>();
            HttpClient = httpClient;
            Events = mMRApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatHeroMmr(List<int> accountIds, ref int heroId, ref Option<long?> maxMatchId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accountIds"></param>
        /// <returns></returns>
        private void ValidateHeroMmr(List<int> accountIds)
        {
            if (accountIds == null)
                throw new ArgumentNullException(nameof(accountIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroId"></param>
        /// <param name="maxMatchId"></param>
        private void AfterHeroMmrDefaultImplementation(IHeroMmrApiResponse apiResponseLocalVar, List<int> accountIds, int heroId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLog = false;
            AfterHeroMmr(ref suppressDefaultLog, apiResponseLocalVar, accountIds, heroId, maxMatchId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroId"></param>
        /// <param name="maxMatchId"></param>
        partial void AfterHeroMmr(ref bool suppressDefaultLog, IHeroMmrApiResponse apiResponseLocalVar, List<int> accountIds, int heroId, Option<long?> maxMatchId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroId"></param>
        /// <param name="maxMatchId"></param>
        private void OnErrorHeroMmrDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<int> accountIds, int heroId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorHeroMmr(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountIds, heroId, maxMatchId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroId"></param>
        /// <param name="maxMatchId"></param>
        partial void OnErrorHeroMmr(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<int> accountIds, int heroId, Option<long?> maxMatchId);

        /// <summary>
        /// Batch Hero MMR  Batch Player Hero MMR 
        /// </summary>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrApiResponse"/>&gt;</returns>
        public async Task<IHeroMmrApiResponse?> HeroMmrOrDefaultAsync(List<int> accountIds, int heroId, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await HeroMmrAsync(accountIds, heroId, maxMatchId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Batch Hero MMR  Batch Player Hero MMR 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrApiResponse"/>&gt;</returns>
        public async Task<IHeroMmrApiResponse> HeroMmrAsync(List<int> accountIds, int heroId, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateHeroMmr(accountIds);

                FormatHeroMmr(accountIds, ref heroId, ref maxMatchId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/mmr/{hero_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/mmr/{hero_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bhero_id%7D", Uri.EscapeDataString(heroId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<HeroMmrApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<HeroMmrApiResponse>();
                        HeroMmrApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/mmr/{hero_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterHeroMmrDefaultImplementation(apiResponseLocalVar, accountIds, heroId, maxMatchId);

                        Events.ExecuteOnHeroMmr(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorHeroMmrDefaultImplementation(e, "/v1/players/mmr/{hero_id}", uriBuilderLocalVar.Path, accountIds, heroId, maxMatchId);
                Events.ExecuteOnErrorHeroMmr(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="HeroMmrApiResponse"/>
        /// </summary>
        public partial class HeroMmrApiResponse : DeadlockApiClient.Client.ApiResponse, IHeroMmrApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<HeroMmrApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="HeroMmrApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroMmrApiResponse(ILogger<HeroMmrApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="HeroMmrApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroMmrApiResponse(ILogger<HeroMmrApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MMRHistory>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MMRHistory>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MMRHistory>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatHeroMmrDistribution(ref int heroId, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<bool?> isHighSkillRangeParties, ref Option<bool?> isLowPriPool, ref Option<bool?> isNewPlayerPool, ref Option<long?> minMatchId, ref Option<long?> maxMatchId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void AfterHeroMmrDistributionDefaultImplementation(IHeroMmrDistributionApiResponse apiResponseLocalVar, int heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLog = false;
            AfterHeroMmrDistribution(ref suppressDefaultLog, apiResponseLocalVar, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void AfterHeroMmrDistribution(ref bool suppressDefaultLog, IHeroMmrDistributionApiResponse apiResponseLocalVar, int heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void OnErrorHeroMmrDistributionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorHeroMmrDistribution(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void OnErrorHeroMmrDistribution(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// Hero MMR Distribution  Player Hero MMR Distribution 
        /// </summary>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1767484800)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrDistributionApiResponse"/>&gt;</returns>
        public async Task<IHeroMmrDistributionApiResponse?> HeroMmrDistributionOrDefaultAsync(int heroId, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await HeroMmrDistributionAsync(heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Hero MMR Distribution  Player Hero MMR Distribution 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1767484800)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrDistributionApiResponse"/>&gt;</returns>
        public async Task<IHeroMmrDistributionApiResponse> HeroMmrDistributionAsync(int heroId, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatHeroMmrDistribution(ref heroId, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref isHighSkillRangeParties, ref isLowPriPool, ref isNewPlayerPool, ref minMatchId, ref maxMatchId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/mmr/distribution/{hero_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/mmr/distribution/{hero_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bhero_id%7D", Uri.EscapeDataString(heroId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (isHighSkillRangeParties.IsSet)
                        parseQueryStringLocalVar["is_high_skill_range_parties"] = ClientUtils.ParameterToString(isHighSkillRangeParties.Value);

                    if (isLowPriPool.IsSet)
                        parseQueryStringLocalVar["is_low_pri_pool"] = ClientUtils.ParameterToString(isLowPriPool.Value);

                    if (isNewPlayerPool.IsSet)
                        parseQueryStringLocalVar["is_new_player_pool"] = ClientUtils.ParameterToString(isNewPlayerPool.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<HeroMmrDistributionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<HeroMmrDistributionApiResponse>();
                        HeroMmrDistributionApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/mmr/distribution/{hero_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterHeroMmrDistributionDefaultImplementation(apiResponseLocalVar, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);

                        Events.ExecuteOnHeroMmrDistribution(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorHeroMmrDistributionDefaultImplementation(e, "/v1/players/mmr/distribution/{hero_id}", uriBuilderLocalVar.Path, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);
                Events.ExecuteOnErrorHeroMmrDistribution(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="HeroMmrDistributionApiResponse"/>
        /// </summary>
        public partial class HeroMmrDistributionApiResponse : DeadlockApiClient.Client.ApiResponse, IHeroMmrDistributionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<HeroMmrDistributionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="HeroMmrDistributionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroMmrDistributionApiResponse(ILogger<HeroMmrDistributionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="HeroMmrDistributionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroMmrDistributionApiResponse(ILogger<HeroMmrDistributionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<DistributionEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<DistributionEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<DistributionEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatHeroMmrHistory(ref int accountId, ref int heroId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="heroId"></param>
        private void AfterHeroMmrHistoryDefaultImplementation(IHeroMmrHistoryApiResponse apiResponseLocalVar, int accountId, int heroId)
        {
            bool suppressDefaultLog = false;
            AfterHeroMmrHistory(ref suppressDefaultLog, apiResponseLocalVar, accountId, heroId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="heroId"></param>
        partial void AfterHeroMmrHistory(ref bool suppressDefaultLog, IHeroMmrHistoryApiResponse apiResponseLocalVar, int accountId, int heroId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="heroId"></param>
        private void OnErrorHeroMmrHistoryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, int heroId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorHeroMmrHistory(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, heroId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="heroId"></param>
        partial void OnErrorHeroMmrHistory(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, int heroId);

        /// <summary>
        /// Hero MMR History Player Hero MMR History
        /// </summary>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrHistoryApiResponse"/>&gt;</returns>
        public async Task<IHeroMmrHistoryApiResponse?> HeroMmrHistoryOrDefaultAsync(int accountId, int heroId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await HeroMmrHistoryAsync(accountId, heroId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Hero MMR History Player Hero MMR History
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="heroId">The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroMmrHistoryApiResponse"/>&gt;</returns>
        public async Task<IHeroMmrHistoryApiResponse> HeroMmrHistoryAsync(int accountId, int heroId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatHeroMmrHistory(ref accountId, ref heroId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/{account_id}/mmr-history/{hero_id}"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/{account_id}/mmr-history/{hero_id}");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baccount_id%7D", Uri.EscapeDataString(accountId.ToString()));
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bhero_id%7D", Uri.EscapeDataString(heroId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<HeroMmrHistoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<HeroMmrHistoryApiResponse>();
                        HeroMmrHistoryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/{account_id}/mmr-history/{hero_id}", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterHeroMmrHistoryDefaultImplementation(apiResponseLocalVar, accountId, heroId);

                        Events.ExecuteOnHeroMmrHistory(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorHeroMmrHistoryDefaultImplementation(e, "/v1/players/{account_id}/mmr-history/{hero_id}", uriBuilderLocalVar.Path, accountId, heroId);
                Events.ExecuteOnErrorHeroMmrHistory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="HeroMmrHistoryApiResponse"/>
        /// </summary>
        public partial class HeroMmrHistoryApiResponse : DeadlockApiClient.Client.ApiResponse, IHeroMmrHistoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<HeroMmrHistoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="HeroMmrHistoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroMmrHistoryApiResponse(ILogger<HeroMmrHistoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="HeroMmrHistoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroMmrHistoryApiResponse(ILogger<HeroMmrHistoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MMRHistory>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MMRHistory>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MMRHistory>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMmr(List<int> accountIds, ref Option<long?> maxMatchId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accountIds"></param>
        /// <returns></returns>
        private void ValidateMmr(List<int> accountIds)
        {
            if (accountIds == null)
                throw new ArgumentNullException(nameof(accountIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="maxMatchId"></param>
        private void AfterMmrDefaultImplementation(IMmrApiResponse apiResponseLocalVar, List<int> accountIds, Option<long?> maxMatchId)
        {
            bool suppressDefaultLog = false;
            AfterMmr(ref suppressDefaultLog, apiResponseLocalVar, accountIds, maxMatchId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="maxMatchId"></param>
        partial void AfterMmr(ref bool suppressDefaultLog, IMmrApiResponse apiResponseLocalVar, List<int> accountIds, Option<long?> maxMatchId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="maxMatchId"></param>
        private void OnErrorMmrDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<int> accountIds, Option<long?> maxMatchId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMmr(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountIds, maxMatchId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="maxMatchId"></param>
        partial void OnErrorMmr(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<int> accountIds, Option<long?> maxMatchId);

        /// <summary>
        /// Batch MMR  Batch Player MMR 
        /// </summary>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrApiResponse"/>&gt;</returns>
        public async Task<IMmrApiResponse?> MmrOrDefaultAsync(List<int> accountIds, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MmrAsync(accountIds, maxMatchId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Batch MMR  Batch Player MMR 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrApiResponse"/>&gt;</returns>
        public async Task<IMmrApiResponse> MmrAsync(List<int> accountIds, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateMmr(accountIds);

                FormatMmr(accountIds, ref maxMatchId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/mmr"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/mmr");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<MmrApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MmrApiResponse>();
                        MmrApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/mmr", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterMmrDefaultImplementation(apiResponseLocalVar, accountIds, maxMatchId);

                        Events.ExecuteOnMmr(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMmrDefaultImplementation(e, "/v1/players/mmr", uriBuilderLocalVar.Path, accountIds, maxMatchId);
                Events.ExecuteOnErrorMmr(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MmrApiResponse"/>
        /// </summary>
        public partial class MmrApiResponse : DeadlockApiClient.Client.ApiResponse, IMmrApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MmrApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MmrApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MmrApiResponse(ILogger<MmrApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="MmrApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MmrApiResponse(ILogger<MmrApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MMRHistory>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MMRHistory>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MMRHistory>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMmrDistribution(ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<bool?> isHighSkillRangeParties, ref Option<bool?> isLowPriPool, ref Option<bool?> isNewPlayerPool, ref Option<long?> minMatchId, ref Option<long?> maxMatchId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void AfterMmrDistributionDefaultImplementation(IMmrDistributionApiResponse apiResponseLocalVar, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLog = false;
            AfterMmrDistribution(ref suppressDefaultLog, apiResponseLocalVar, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void AfterMmrDistribution(ref bool suppressDefaultLog, IMmrDistributionApiResponse apiResponseLocalVar, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void OnErrorMmrDistributionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMmrDistribution(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void OnErrorMmrDistribution(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// MMR Distribution  Player MMR Distribution 
        /// </summary>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1767484800)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrDistributionApiResponse"/>&gt;</returns>
        public async Task<IMmrDistributionApiResponse?> MmrDistributionOrDefaultAsync(Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MmrDistributionAsync(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// MMR Distribution  Player MMR Distribution 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1767484800)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrDistributionApiResponse"/>&gt;</returns>
        public async Task<IMmrDistributionApiResponse> MmrDistributionAsync(Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatMmrDistribution(ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref isHighSkillRangeParties, ref isLowPriPool, ref isNewPlayerPool, ref minMatchId, ref maxMatchId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/mmr/distribution"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/mmr/distribution");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (isHighSkillRangeParties.IsSet)
                        parseQueryStringLocalVar["is_high_skill_range_parties"] = ClientUtils.ParameterToString(isHighSkillRangeParties.Value);

                    if (isLowPriPool.IsSet)
                        parseQueryStringLocalVar["is_low_pri_pool"] = ClientUtils.ParameterToString(isLowPriPool.Value);

                    if (isNewPlayerPool.IsSet)
                        parseQueryStringLocalVar["is_new_player_pool"] = ClientUtils.ParameterToString(isNewPlayerPool.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<MmrDistributionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MmrDistributionApiResponse>();
                        MmrDistributionApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/mmr/distribution", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterMmrDistributionDefaultImplementation(apiResponseLocalVar, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);

                        Events.ExecuteOnMmrDistribution(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMmrDistributionDefaultImplementation(e, "/v1/players/mmr/distribution", uriBuilderLocalVar.Path, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);
                Events.ExecuteOnErrorMmrDistribution(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MmrDistributionApiResponse"/>
        /// </summary>
        public partial class MmrDistributionApiResponse : DeadlockApiClient.Client.ApiResponse, IMmrDistributionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MmrDistributionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MmrDistributionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MmrDistributionApiResponse(ILogger<MmrDistributionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="MmrDistributionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MmrDistributionApiResponse(ILogger<MmrDistributionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<DistributionEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<DistributionEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<DistributionEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMmrHistory(ref int accountId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        private void AfterMmrHistoryDefaultImplementation(IMmrHistoryApiResponse apiResponseLocalVar, int accountId)
        {
            bool suppressDefaultLog = false;
            AfterMmrHistory(ref suppressDefaultLog, apiResponseLocalVar, accountId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        partial void AfterMmrHistory(ref bool suppressDefaultLog, IMmrHistoryApiResponse apiResponseLocalVar, int accountId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        private void OnErrorMmrHistoryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMmrHistory(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        partial void OnErrorMmrHistory(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId);

        /// <summary>
        /// MMR History Player MMR History
        /// </summary>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrHistoryApiResponse"/>&gt;</returns>
        public async Task<IMmrHistoryApiResponse?> MmrHistoryOrDefaultAsync(int accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MmrHistoryAsync(accountId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// MMR History Player MMR History
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMmrHistoryApiResponse"/>&gt;</returns>
        public async Task<IMmrHistoryApiResponse> MmrHistoryAsync(int accountId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatMmrHistory(ref accountId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/{account_id}/mmr-history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/{account_id}/mmr-history");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baccount_id%7D", Uri.EscapeDataString(accountId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<MmrHistoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MmrHistoryApiResponse>();
                        MmrHistoryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/{account_id}/mmr-history", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterMmrHistoryDefaultImplementation(apiResponseLocalVar, accountId);

                        Events.ExecuteOnMmrHistory(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMmrHistoryDefaultImplementation(e, "/v1/players/{account_id}/mmr-history", uriBuilderLocalVar.Path, accountId);
                Events.ExecuteOnErrorMmrHistory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MmrHistoryApiResponse"/>
        /// </summary>
        public partial class MmrHistoryApiResponse : DeadlockApiClient.Client.ApiResponse, IMmrHistoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MmrHistoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MmrHistoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MmrHistoryApiResponse(ILogger<MmrHistoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="MmrHistoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MmrHistoryApiResponse(ILogger<MmrHistoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MMRHistory>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MMRHistory>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MMRHistory>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
