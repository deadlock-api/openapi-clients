// <auto-generated>
/*
 * Deadlock API
 *
 *  ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using DeadlockApiClient.Client;
using DeadlockApiClient.Model;
using System.Diagnostics.CodeAnalysis;

namespace DeadlockApiClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IPlayersApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        PlayersApiEvents Events { get; }

        /// <summary>
        /// Enemy Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="maxMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnemyStatsApiResponse"/>&gt;</returns>
        Task<IEnemyStatsApiResponse> EnemyStatsAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minMatchesPlayed = default, Option<long?> maxMatchesPlayed = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Enemy Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="maxMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnemyStatsApiResponse"/>?&gt;</returns>
        Task<IEnemyStatsApiResponse?> EnemyStatsOrDefaultAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minMatchesPlayed = default, Option<long?> maxMatchesPlayed = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Match History
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the player match history for the given &#x60;account_id&#x60;.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 5req/min&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: 100req/s&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Key | 50req/min &amp; 1000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Global | 2000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 10req/h |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="forceRefetch">Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit. (optional)</param>
        /// <param name="onlyStoredHistory">Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMatchHistoryApiResponse"/>&gt;</returns>
        Task<IMatchHistoryApiResponse> MatchHistoryAsync(int accountId, Option<bool> forceRefetch = default, Option<bool> onlyStoredHistory = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Match History
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the player match history for the given &#x60;account_id&#x60;.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 5req/min&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: 100req/s&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Key | 50req/min &amp; 1000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Global | 2000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 10req/h |     
        /// </remarks>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="forceRefetch">Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit. (optional)</param>
        /// <param name="onlyStoredHistory">Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMatchHistoryApiResponse"/>?&gt;</returns>
        Task<IMatchHistoryApiResponse?> MatchHistoryOrDefaultAsync(int accountId, Option<bool> forceRefetch = default, Option<bool> onlyStoredHistory = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Mate Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="maxMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="sameParty">Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMateStatsApiResponse"/>&gt;</returns>
        Task<IMateStatsApiResponse> MateStatsAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minMatchesPlayed = default, Option<long?> maxMatchesPlayed = default, Option<bool> sameParty = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Mate Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="maxMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="sameParty">Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMateStatsApiResponse"/>?&gt;</returns>
        Task<IMateStatsApiResponse?> MateStatsOrDefaultAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minMatchesPlayed = default, Option<long?> maxMatchesPlayed = default, Option<bool> sameParty = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Party Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPartyStatsApiResponse"/>&gt;</returns>
        Task<IPartyStatsApiResponse> PartyStatsAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Party Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPartyStatsApiResponse"/>?&gt;</returns>
        Task<IPartyStatsApiResponse?> PartyStatsOrDefaultAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerHeroStatsApiResponse"/>&gt;</returns>
        Task<IPlayerHeroStatsApiResponse> PlayerHeroStatsAsync(List<int> accountIds, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerHeroStatsApiResponse"/>?&gt;</returns>
        Task<IPlayerHeroStatsApiResponse?> PlayerHeroStatsOrDefaultAsync(List<int> accountIds, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Batch Steam Profile
        /// </summary>
        /// <remarks>
        ///  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISteamApiResponse"/>&gt;</returns>
        Task<ISteamApiResponse> SteamAsync(List<long> accountIds, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Batch Steam Profile
        /// </summary>
        /// <remarks>
        ///  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISteamApiResponse"/>?&gt;</returns>
        Task<ISteamApiResponse?> SteamOrDefaultAsync(List<long> accountIds, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Steam Profile Search
        /// </summary>
        /// <remarks>
        ///  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchQuery">Search query for Steam profiles.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISteamSearchApiResponse"/>&gt;</returns>
        Task<ISteamSearchApiResponse> SteamSearchAsync(string searchQuery, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Steam Profile Search
        /// </summary>
        /// <remarks>
        ///  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="searchQuery">Search query for Steam profiles.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISteamSearchApiResponse"/>?&gt;</returns>
        Task<ISteamSearchApiResponse?> SteamSearchOrDefaultAsync(string searchQuery, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IEnemyStatsApiResponse"/>
    /// </summary>
    public interface IEnemyStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<EnemyStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IMatchHistoryApiResponse"/>
    /// </summary>
    public interface IMatchHistoryApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<PlayerMatchHistoryEntry>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IMateStatsApiResponse"/>
    /// </summary>
    public interface IMateStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<MateStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPartyStatsApiResponse"/>
    /// </summary>
    public interface IPartyStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<PartyStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPlayerHeroStatsApiResponse"/>
    /// </summary>
    public interface IPlayerHeroStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<HeroStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISteamApiResponse"/>
    /// </summary>
    public interface ISteamApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<SteamProfile>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISteamSearchApiResponse"/>
    /// </summary>
    public interface ISteamSearchApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<SteamProfile>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class PlayersApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnEnemyStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorEnemyStats;

        internal void ExecuteOnEnemyStats(PlayersApi.EnemyStatsApiResponse apiResponse)
        {
            OnEnemyStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorEnemyStats(Exception exception)
        {
            OnErrorEnemyStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnMatchHistory;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorMatchHistory;

        internal void ExecuteOnMatchHistory(PlayersApi.MatchHistoryApiResponse apiResponse)
        {
            OnMatchHistory?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMatchHistory(Exception exception)
        {
            OnErrorMatchHistory?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnMateStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorMateStats;

        internal void ExecuteOnMateStats(PlayersApi.MateStatsApiResponse apiResponse)
        {
            OnMateStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMateStats(Exception exception)
        {
            OnErrorMateStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPartyStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPartyStats;

        internal void ExecuteOnPartyStats(PlayersApi.PartyStatsApiResponse apiResponse)
        {
            OnPartyStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPartyStats(Exception exception)
        {
            OnErrorPartyStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPlayerHeroStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPlayerHeroStats;

        internal void ExecuteOnPlayerHeroStats(PlayersApi.PlayerHeroStatsApiResponse apiResponse)
        {
            OnPlayerHeroStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPlayerHeroStats(Exception exception)
        {
            OnErrorPlayerHeroStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSteam;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSteam;

        internal void ExecuteOnSteam(PlayersApi.SteamApiResponse apiResponse)
        {
            OnSteam?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSteam(Exception exception)
        {
            OnErrorSteam?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSteamSearch;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSteamSearch;

        internal void ExecuteOnSteamSearch(PlayersApi.SteamSearchApiResponse apiResponse)
        {
            OnSteamSearch?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSteamSearch(Exception exception)
        {
            OnErrorSteamSearch?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class PlayersApi : IPlayersApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<PlayersApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public PlayersApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="PlayersApi"/> class.
        /// </summary>
        /// <returns></returns>
        public PlayersApi(ILogger<PlayersApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, PlayersApiEvents playersApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<PlayersApi>();
            HttpClient = httpClient;
            Events = playersApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatEnemyStats(ref int accountId, ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<long?> minMatchesPlayed, ref Option<long?> maxMatchesPlayed);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatchesPlayed"></param>
        /// <param name="maxMatchesPlayed"></param>
        private void AfterEnemyStatsDefaultImplementation(IEnemyStatsApiResponse apiResponseLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minMatchesPlayed, Option<long?> maxMatchesPlayed)
        {
            bool suppressDefaultLog = false;
            AfterEnemyStats(ref suppressDefaultLog, apiResponseLocalVar, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatchesPlayed"></param>
        /// <param name="maxMatchesPlayed"></param>
        partial void AfterEnemyStats(ref bool suppressDefaultLog, IEnemyStatsApiResponse apiResponseLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minMatchesPlayed, Option<long?> maxMatchesPlayed);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatchesPlayed"></param>
        /// <param name="maxMatchesPlayed"></param>
        private void OnErrorEnemyStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minMatchesPlayed, Option<long?> maxMatchesPlayed)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorEnemyStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatchesPlayed"></param>
        /// <param name="maxMatchesPlayed"></param>
        partial void OnErrorEnemyStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minMatchesPlayed, Option<long?> maxMatchesPlayed);

        /// <summary>
        /// Enemy Stats  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="maxMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnemyStatsApiResponse"/>&gt;</returns>
        public async Task<IEnemyStatsApiResponse?> EnemyStatsOrDefaultAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minMatchesPlayed = default, Option<long?> maxMatchesPlayed = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await EnemyStatsAsync(accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Enemy Stats  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="maxMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IEnemyStatsApiResponse"/>&gt;</returns>
        public async Task<IEnemyStatsApiResponse> EnemyStatsAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minMatchesPlayed = default, Option<long?> maxMatchesPlayed = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatEnemyStats(ref accountId, ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minMatchId, ref maxMatchId, ref minMatchesPlayed, ref maxMatchesPlayed);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/{account_id}/enemy-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/{account_id}/enemy-stats");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baccount_id%7D", Uri.EscapeDataString(accountId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (minMatchesPlayed.IsSet)
                        parseQueryStringLocalVar["min_matches_played"] = ClientUtils.ParameterToString(minMatchesPlayed.Value);

                    if (maxMatchesPlayed.IsSet)
                        parseQueryStringLocalVar["max_matches_played"] = ClientUtils.ParameterToString(maxMatchesPlayed.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<EnemyStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<EnemyStatsApiResponse>();
                        EnemyStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/{account_id}/enemy-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterEnemyStatsDefaultImplementation(apiResponseLocalVar, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed);

                        Events.ExecuteOnEnemyStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorEnemyStatsDefaultImplementation(e, "/v1/players/{account_id}/enemy-stats", uriBuilderLocalVar.Path, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed);
                Events.ExecuteOnErrorEnemyStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="EnemyStatsApiResponse"/>
        /// </summary>
        public partial class EnemyStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IEnemyStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<EnemyStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="EnemyStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EnemyStatsApiResponse(ILogger<EnemyStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="EnemyStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public EnemyStatsApiResponse(ILogger<EnemyStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<EnemyStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<EnemyStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<EnemyStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMatchHistory(ref int accountId, ref Option<bool> forceRefetch, ref Option<bool> onlyStoredHistory);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="forceRefetch"></param>
        /// <param name="onlyStoredHistory"></param>
        private void AfterMatchHistoryDefaultImplementation(IMatchHistoryApiResponse apiResponseLocalVar, int accountId, Option<bool> forceRefetch, Option<bool> onlyStoredHistory)
        {
            bool suppressDefaultLog = false;
            AfterMatchHistory(ref suppressDefaultLog, apiResponseLocalVar, accountId, forceRefetch, onlyStoredHistory);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="forceRefetch"></param>
        /// <param name="onlyStoredHistory"></param>
        partial void AfterMatchHistory(ref bool suppressDefaultLog, IMatchHistoryApiResponse apiResponseLocalVar, int accountId, Option<bool> forceRefetch, Option<bool> onlyStoredHistory);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="forceRefetch"></param>
        /// <param name="onlyStoredHistory"></param>
        private void OnErrorMatchHistoryDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, Option<bool> forceRefetch, Option<bool> onlyStoredHistory)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMatchHistory(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, forceRefetch, onlyStoredHistory);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="forceRefetch"></param>
        /// <param name="onlyStoredHistory"></param>
        partial void OnErrorMatchHistory(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, Option<bool> forceRefetch, Option<bool> onlyStoredHistory);

        /// <summary>
        /// Match History  This endpoint returns the player match history for the given &#x60;account_id&#x60;.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 5req/min&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: 100req/s&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Key | 50req/min &amp; 1000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Global | 2000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 10req/h |     
        /// </summary>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="forceRefetch">Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit. (optional)</param>
        /// <param name="onlyStoredHistory">Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMatchHistoryApiResponse"/>&gt;</returns>
        public async Task<IMatchHistoryApiResponse?> MatchHistoryOrDefaultAsync(int accountId, Option<bool> forceRefetch = default, Option<bool> onlyStoredHistory = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MatchHistoryAsync(accountId, forceRefetch, onlyStoredHistory, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Match History  This endpoint returns the player match history for the given &#x60;account_id&#x60;.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 5req/min&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: 100req/s&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Key | 50req/min &amp; 1000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 5req/h | | Global | 2000req/h&lt;br&gt;With &#x60;only_stored_history&#x3D;true&#x60;: -&lt;br&gt;With &#x60;force_refetch&#x3D;true&#x60;: 10req/h |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="forceRefetch">Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit. (optional)</param>
        /// <param name="onlyStoredHistory">Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMatchHistoryApiResponse"/>&gt;</returns>
        public async Task<IMatchHistoryApiResponse> MatchHistoryAsync(int accountId, Option<bool> forceRefetch = default, Option<bool> onlyStoredHistory = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatMatchHistory(ref accountId, ref forceRefetch, ref onlyStoredHistory);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/{account_id}/match-history"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/{account_id}/match-history");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baccount_id%7D", Uri.EscapeDataString(accountId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (forceRefetch.IsSet)
                        parseQueryStringLocalVar["force_refetch"] = ClientUtils.ParameterToString(forceRefetch.Value);

                    if (onlyStoredHistory.IsSet)
                        parseQueryStringLocalVar["only_stored_history"] = ClientUtils.ParameterToString(onlyStoredHistory.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<MatchHistoryApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MatchHistoryApiResponse>();
                        MatchHistoryApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/{account_id}/match-history", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterMatchHistoryDefaultImplementation(apiResponseLocalVar, accountId, forceRefetch, onlyStoredHistory);

                        Events.ExecuteOnMatchHistory(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMatchHistoryDefaultImplementation(e, "/v1/players/{account_id}/match-history", uriBuilderLocalVar.Path, accountId, forceRefetch, onlyStoredHistory);
                Events.ExecuteOnErrorMatchHistory(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MatchHistoryApiResponse"/>
        /// </summary>
        public partial class MatchHistoryApiResponse : DeadlockApiClient.Client.ApiResponse, IMatchHistoryApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MatchHistoryApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MatchHistoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MatchHistoryApiResponse(ILogger<MatchHistoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="MatchHistoryApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MatchHistoryApiResponse(ILogger<MatchHistoryApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<PlayerMatchHistoryEntry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<PlayerMatchHistoryEntry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<PlayerMatchHistoryEntry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMateStats(ref int accountId, ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<long?> minMatchesPlayed, ref Option<long?> maxMatchesPlayed, ref Option<bool> sameParty);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatchesPlayed"></param>
        /// <param name="maxMatchesPlayed"></param>
        /// <param name="sameParty"></param>
        private void AfterMateStatsDefaultImplementation(IMateStatsApiResponse apiResponseLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minMatchesPlayed, Option<long?> maxMatchesPlayed, Option<bool> sameParty)
        {
            bool suppressDefaultLog = false;
            AfterMateStats(ref suppressDefaultLog, apiResponseLocalVar, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, sameParty);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatchesPlayed"></param>
        /// <param name="maxMatchesPlayed"></param>
        /// <param name="sameParty"></param>
        partial void AfterMateStats(ref bool suppressDefaultLog, IMateStatsApiResponse apiResponseLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minMatchesPlayed, Option<long?> maxMatchesPlayed, Option<bool> sameParty);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatchesPlayed"></param>
        /// <param name="maxMatchesPlayed"></param>
        /// <param name="sameParty"></param>
        private void OnErrorMateStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minMatchesPlayed, Option<long?> maxMatchesPlayed, Option<bool> sameParty)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMateStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, sameParty);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatchesPlayed"></param>
        /// <param name="maxMatchesPlayed"></param>
        /// <param name="sameParty"></param>
        partial void OnErrorMateStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minMatchesPlayed, Option<long?> maxMatchesPlayed, Option<bool> sameParty);

        /// <summary>
        /// Mate Stats  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="maxMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="sameParty">Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMateStatsApiResponse"/>&gt;</returns>
        public async Task<IMateStatsApiResponse?> MateStatsOrDefaultAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minMatchesPlayed = default, Option<long?> maxMatchesPlayed = default, Option<bool> sameParty = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MateStatsAsync(accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, sameParty, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Mate Stats  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="maxMatchesPlayed">Filter based on the number of matches played. (optional)</param>
        /// <param name="sameParty">Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches. (optional, default to true)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMateStatsApiResponse"/>&gt;</returns>
        public async Task<IMateStatsApiResponse> MateStatsAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minMatchesPlayed = default, Option<long?> maxMatchesPlayed = default, Option<bool> sameParty = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatMateStats(ref accountId, ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minMatchId, ref maxMatchId, ref minMatchesPlayed, ref maxMatchesPlayed, ref sameParty);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/{account_id}/mate-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/{account_id}/mate-stats");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baccount_id%7D", Uri.EscapeDataString(accountId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (minMatchesPlayed.IsSet)
                        parseQueryStringLocalVar["min_matches_played"] = ClientUtils.ParameterToString(minMatchesPlayed.Value);

                    if (maxMatchesPlayed.IsSet)
                        parseQueryStringLocalVar["max_matches_played"] = ClientUtils.ParameterToString(maxMatchesPlayed.Value);

                    if (sameParty.IsSet)
                        parseQueryStringLocalVar["same_party"] = ClientUtils.ParameterToString(sameParty.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<MateStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MateStatsApiResponse>();
                        MateStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/{account_id}/mate-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterMateStatsDefaultImplementation(apiResponseLocalVar, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, sameParty);

                        Events.ExecuteOnMateStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMateStatsDefaultImplementation(e, "/v1/players/{account_id}/mate-stats", uriBuilderLocalVar.Path, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, sameParty);
                Events.ExecuteOnErrorMateStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MateStatsApiResponse"/>
        /// </summary>
        public partial class MateStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IMateStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MateStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MateStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MateStatsApiResponse(ILogger<MateStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="MateStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MateStatsApiResponse(ILogger<MateStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<MateStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<MateStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<MateStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPartyStats(ref int accountId, ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minMatchId, ref Option<long?> maxMatchId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void AfterPartyStatsDefaultImplementation(IPartyStatsApiResponse apiResponseLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLog = false;
            AfterPartyStats(ref suppressDefaultLog, apiResponseLocalVar, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void AfterPartyStats(ref bool suppressDefaultLog, IPartyStatsApiResponse apiResponseLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void OnErrorPartyStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPartyStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void OnErrorPartyStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int accountId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// Party Stats  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPartyStatsApiResponse"/>&gt;</returns>
        public async Task<IPartyStatsApiResponse?> PartyStatsOrDefaultAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PartyStatsAsync(accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Party Stats  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The players &#x60;SteamID3&#x60;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPartyStatsApiResponse"/>&gt;</returns>
        public async Task<IPartyStatsApiResponse> PartyStatsAsync(int accountId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatPartyStats(ref accountId, ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minMatchId, ref maxMatchId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/{account_id}/party-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/{account_id}/party-stats");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Baccount_id%7D", Uri.EscapeDataString(accountId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<PartyStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PartyStatsApiResponse>();
                        PartyStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/{account_id}/party-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterPartyStatsDefaultImplementation(apiResponseLocalVar, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId);

                        Events.ExecuteOnPartyStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPartyStatsDefaultImplementation(e, "/v1/players/{account_id}/party-stats", uriBuilderLocalVar.Path, accountId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId);
                Events.ExecuteOnErrorPartyStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PartyStatsApiResponse"/>
        /// </summary>
        public partial class PartyStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IPartyStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PartyStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PartyStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PartyStatsApiResponse(ILogger<PartyStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="PartyStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PartyStatsApiResponse(ILogger<PartyStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<PartyStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<PartyStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<PartyStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPlayerHeroStats(List<int> accountIds, ref Option<string?> gameMode, ref Option<string?> heroIds, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accountIds"></param>
        /// <returns></returns>
        private void ValidatePlayerHeroStats(List<int> accountIds)
        {
            if (accountIds == null)
                throw new ArgumentNullException(nameof(accountIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void AfterPlayerHeroStatsDefaultImplementation(IPlayerHeroStatsApiResponse apiResponseLocalVar, List<int> accountIds, Option<string?> gameMode, Option<string?> heroIds, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLog = false;
            AfterPlayerHeroStats(ref suppressDefaultLog, apiResponseLocalVar, accountIds, gameMode, heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void AfterPlayerHeroStats(ref bool suppressDefaultLog, IPlayerHeroStatsApiResponse apiResponseLocalVar, List<int> accountIds, Option<string?> gameMode, Option<string?> heroIds, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void OnErrorPlayerHeroStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<int> accountIds, Option<string?> gameMode, Option<string?> heroIds, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPlayerHeroStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountIds, gameMode, heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountIds"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void OnErrorPlayerHeroStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<int> accountIds, Option<string?> gameMode, Option<string?> heroIds, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// Hero Stats  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerHeroStatsApiResponse"/>&gt;</returns>
        public async Task<IPlayerHeroStatsApiResponse?> PlayerHeroStatsOrDefaultAsync(List<int> accountIds, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PlayerHeroStatsAsync(accountIds, gameMode, heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Hero Stats  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerHeroStatsApiResponse"/>&gt;</returns>
        public async Task<IPlayerHeroStatsApiResponse> PlayerHeroStatsAsync(List<int> accountIds, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePlayerHeroStats(accountIds);

                FormatPlayerHeroStats(accountIds, ref gameMode, ref heroIds, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/hero-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/hero-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (heroIds.IsSet)
                        parseQueryStringLocalVar["hero_ids"] = ClientUtils.ParameterToString(heroIds.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<PlayerHeroStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PlayerHeroStatsApiResponse>();
                        PlayerHeroStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/hero-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterPlayerHeroStatsDefaultImplementation(apiResponseLocalVar, accountIds, gameMode, heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId);

                        Events.ExecuteOnPlayerHeroStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPlayerHeroStatsDefaultImplementation(e, "/v1/players/hero-stats", uriBuilderLocalVar.Path, accountIds, gameMode, heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId);
                Events.ExecuteOnErrorPlayerHeroStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PlayerHeroStatsApiResponse"/>
        /// </summary>
        public partial class PlayerHeroStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IPlayerHeroStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PlayerHeroStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PlayerHeroStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PlayerHeroStatsApiResponse(ILogger<PlayerHeroStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="PlayerHeroStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PlayerHeroStatsApiResponse(ILogger<PlayerHeroStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<HeroStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<HeroStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<HeroStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSteam(List<long> accountIds);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="accountIds"></param>
        /// <returns></returns>
        private void ValidateSteam(List<long> accountIds)
        {
            if (accountIds == null)
                throw new ArgumentNullException(nameof(accountIds));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountIds"></param>
        private void AfterSteamDefaultImplementation(ISteamApiResponse apiResponseLocalVar, List<long> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterSteam(ref suppressDefaultLog, apiResponseLocalVar, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountIds"></param>
        partial void AfterSteam(ref bool suppressDefaultLog, ISteamApiResponse apiResponseLocalVar, List<long> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountIds"></param>
        private void OnErrorSteamDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<long> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSteam(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorSteam(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<long> accountIds);

        /// <summary>
        /// Batch Steam Profile  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISteamApiResponse"/>&gt;</returns>
        public async Task<ISteamApiResponse?> SteamOrDefaultAsync(List<long> accountIds, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SteamAsync(accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Batch Steam Profile  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountIds">Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISteamApiResponse"/>&gt;</returns>
        public async Task<ISteamApiResponse> SteamAsync(List<long> accountIds, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSteam(accountIds);

                FormatSteam(accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/steam"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/steam");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SteamApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SteamApiResponse>();
                        SteamApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/steam", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSteamDefaultImplementation(apiResponseLocalVar, accountIds);

                        Events.ExecuteOnSteam(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSteamDefaultImplementation(e, "/v1/players/steam", uriBuilderLocalVar.Path, accountIds);
                Events.ExecuteOnErrorSteam(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SteamApiResponse"/>
        /// </summary>
        public partial class SteamApiResponse : DeadlockApiClient.Client.ApiResponse, ISteamApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SteamApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SteamApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SteamApiResponse(ILogger<SteamApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SteamApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SteamApiResponse(ILogger<SteamApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<SteamProfile>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<SteamProfile>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<SteamProfile>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSteamSearch(ref string searchQuery);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="searchQuery"></param>
        /// <returns></returns>
        private void ValidateSteamSearch(string searchQuery)
        {
            if (searchQuery == null)
                throw new ArgumentNullException(nameof(searchQuery));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchQuery"></param>
        private void AfterSteamSearchDefaultImplementation(ISteamSearchApiResponse apiResponseLocalVar, string searchQuery)
        {
            bool suppressDefaultLog = false;
            AfterSteamSearch(ref suppressDefaultLog, apiResponseLocalVar, searchQuery);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="searchQuery"></param>
        partial void AfterSteamSearch(ref bool suppressDefaultLog, ISteamSearchApiResponse apiResponseLocalVar, string searchQuery);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="searchQuery"></param>
        private void OnErrorSteamSearchDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string searchQuery)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSteamSearch(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, searchQuery);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="searchQuery"></param>
        partial void OnErrorSteamSearch(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string searchQuery);

        /// <summary>
        /// Steam Profile Search  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="searchQuery">Search query for Steam profiles.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISteamSearchApiResponse"/>&gt;</returns>
        public async Task<ISteamSearchApiResponse?> SteamSearchOrDefaultAsync(string searchQuery, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SteamSearchAsync(searchQuery, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Steam Profile Search  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="searchQuery">Search query for Steam profiles.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISteamSearchApiResponse"/>&gt;</returns>
        public async Task<ISteamSearchApiResponse> SteamSearchAsync(string searchQuery, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateSteamSearch(searchQuery);

                FormatSteamSearch(ref searchQuery);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/players/steam-search"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/players/steam-search");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["search_query"] = ClientUtils.ParameterToString(searchQuery);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SteamSearchApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SteamSearchApiResponse>();
                        SteamSearchApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/players/steam-search", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSteamSearchDefaultImplementation(apiResponseLocalVar, searchQuery);

                        Events.ExecuteOnSteamSearch(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSteamSearchDefaultImplementation(e, "/v1/players/steam-search", uriBuilderLocalVar.Path, searchQuery);
                Events.ExecuteOnErrorSteamSearch(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SteamSearchApiResponse"/>
        /// </summary>
        public partial class SteamSearchApiResponse : DeadlockApiClient.Client.ApiResponse, ISteamSearchApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SteamSearchApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SteamSearchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SteamSearchApiResponse(ILogger<SteamSearchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SteamSearchApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SteamSearchApiResponse(ILogger<SteamSearchApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<SteamProfile>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<SteamProfile>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<SteamProfile>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
