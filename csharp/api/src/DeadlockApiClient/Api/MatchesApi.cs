// <auto-generated>
/*
 * Deadlock API
 *
 *  ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using DeadlockApiClient.Client;
using DeadlockApiClient.Model;
using System.Diagnostics.CodeAnalysis;

namespace DeadlockApiClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IMatchesApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        MatchesApiEvents Events { get; }

        /// <summary>
        /// Active
        /// </summary>
        /// <remarks>
        ///  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account ID to filter active matches by (&#x60;SteamID3&#x60;) (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IActiveMatchesApiResponse"/>&gt;</returns>
        Task<IActiveMatchesApiResponse> ActiveMatchesAsync(Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Active
        /// </summary>
        /// <remarks>
        ///  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="accountId">The account ID to filter active matches by (&#x60;SteamID3&#x60;) (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IActiveMatchesApiResponse"/>?&gt;</returns>
        Task<IActiveMatchesApiResponse?> ActiveMatchesOrDefaultAsync(Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Active as Protobuf
        /// </summary>
        /// <remarks>
        ///  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IActiveMatchesRawApiResponse"/>&gt;</returns>
        Task<IActiveMatchesRawApiResponse> ActiveMatchesRawAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Active as Protobuf
        /// </summary>
        /// <remarks>
        ///  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IActiveMatchesRawApiResponse"/>?&gt;</returns>
        Task<IActiveMatchesRawApiResponse?> ActiveMatchesRawOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Bulk Metadata
        /// </summary>
        /// <remarks>
        ///  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeInfo">Include match info in the response. (optional, default to true)</param>
        /// <param name="includeMoreInfo">Include more match info in the response. (optional)</param>
        /// <param name="includeObjectives">Include objectives in the response. (optional)</param>
        /// <param name="includeMidBoss">Include midboss in the response. (optional)</param>
        /// <param name="includePlayerInfo">Include player info in the response. (optional)</param>
        /// <param name="includePlayerItems">Include player items in the response. (optional)</param>
        /// <param name="includePlayerStats">Include player stats in the response. (optional)</param>
        /// <param name="includePlayerDeathDetails">Include player death details in the response. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="matchIds">Comma separated list of match ids, limited by &#x60;limit&#x60; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="accountIds">Filter matches by account IDs of players that participated in the match. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="orderBy">The field to order the results by. (optional)</param>
        /// <param name="orderDirection">The direction to order the results by. (optional)</param>
        /// <param name="limit">The maximum number of matches to return. (optional, default to 1000)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBulkMetadataApiResponse"/>&gt;</returns>
        Task<IBulkMetadataApiResponse> BulkMetadataAsync(Option<bool> includeInfo = default, Option<bool> includeMoreInfo = default, Option<bool> includeObjectives = default, Option<bool> includeMidBoss = default, Option<bool> includePlayerInfo = default, Option<bool> includePlayerItems = default, Option<bool> includePlayerStats = default, Option<bool> includePlayerDeathDetails = default, Option<string?> gameMode = default, Option<List<long>?> matchIds = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<List<int>?> accountIds = default, Option<string?> heroIds = default, Option<string> orderBy = default, Option<string> orderDirection = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Bulk Metadata
        /// </summary>
        /// <remarks>
        ///  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
        /// </remarks>
        /// <param name="includeInfo">Include match info in the response. (optional, default to true)</param>
        /// <param name="includeMoreInfo">Include more match info in the response. (optional)</param>
        /// <param name="includeObjectives">Include objectives in the response. (optional)</param>
        /// <param name="includeMidBoss">Include midboss in the response. (optional)</param>
        /// <param name="includePlayerInfo">Include player info in the response. (optional)</param>
        /// <param name="includePlayerItems">Include player items in the response. (optional)</param>
        /// <param name="includePlayerStats">Include player stats in the response. (optional)</param>
        /// <param name="includePlayerDeathDetails">Include player death details in the response. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="matchIds">Comma separated list of match ids, limited by &#x60;limit&#x60; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="accountIds">Filter matches by account IDs of players that participated in the match. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="orderBy">The field to order the results by. (optional)</param>
        /// <param name="orderDirection">The direction to order the results by. (optional)</param>
        /// <param name="limit">The maximum number of matches to return. (optional, default to 1000)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBulkMetadataApiResponse"/>?&gt;</returns>
        Task<IBulkMetadataApiResponse?> BulkMetadataOrDefaultAsync(Option<bool> includeInfo = default, Option<bool> includeMoreInfo = default, Option<bool> includeObjectives = default, Option<bool> includeMidBoss = default, Option<bool> includePlayerInfo = default, Option<bool> includePlayerItems = default, Option<bool> includePlayerStats = default, Option<bool> includePlayerDeathDetails = default, Option<string?> gameMode = default, Option<List<long>?> matchIds = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<List<int>?> accountIds = default, Option<string?> heroIds = default, Option<string> orderBy = default, Option<string> orderDirection = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Metadata
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the match metadata for the given &#x60;match_id&#x60; parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 5req/h | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 400req/h | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 2000req/h |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId">The match ID</param>
        /// <param name="isCustom"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMetadataApiResponse"/>&gt;</returns>
        Task<IMetadataApiResponse> MetadataAsync(long matchId, Option<bool?> isCustom = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Metadata
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the match metadata for the given &#x60;match_id&#x60; parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 5req/h | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 400req/h | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 2000req/h |     
        /// </remarks>
        /// <param name="matchId">The match ID</param>
        /// <param name="isCustom"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMetadataApiResponse"/>?&gt;</returns>
        Task<IMetadataApiResponse?> MetadataOrDefaultAsync(long matchId, Option<bool?> isCustom = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Metadata as Protobuf
        /// </summary>
        /// <remarks>
        ///  This endpoints returns the raw .meta.bz2 file for the given &#x60;match_id&#x60;.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 5req/h | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 400req/h | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 2000req/h |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId">The match ID</param>
        /// <param name="isCustom"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMetadataRawApiResponse"/>&gt;</returns>
        Task<IMetadataRawApiResponse> MetadataRawAsync(long matchId, Option<bool?> isCustom = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Metadata as Protobuf
        /// </summary>
        /// <remarks>
        ///  This endpoints returns the raw .meta.bz2 file for the given &#x60;match_id&#x60;.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 5req/h | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 400req/h | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 2000req/h |     
        /// </remarks>
        /// <param name="matchId">The match ID</param>
        /// <param name="isCustom"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMetadataRawApiResponse"/>?&gt;</returns>
        Task<IMetadataRawApiResponse?> MetadataRawOrDefaultAsync(long matchId, Option<bool?> isCustom = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Recently Fetched
        /// </summary>
        /// <remarks>
        ///  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerIngestedOnly">If true, only return matches that have been ingested by players. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRecentlyFetchedApiResponse"/>&gt;</returns>
        Task<IRecentlyFetchedApiResponse> RecentlyFetchedAsync(Option<bool?> playerIngestedOnly = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Recently Fetched
        /// </summary>
        /// <remarks>
        ///  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="playerIngestedOnly">If true, only return matches that have been ingested by players. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRecentlyFetchedApiResponse"/>?&gt;</returns>
        Task<IRecentlyFetchedApiResponse?> RecentlyFetchedOrDefaultAsync(Option<bool?> playerIngestedOnly = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Salts
        /// </summary>
        /// <remarks>
        ///  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From DB: 100req/s&lt;br&gt;From Steam: 10req/30mins | | Key | From DB: -&lt;br&gt;From Steam: 10req/min | | Global | From DB: -&lt;br&gt;From Steam: 10req/10s |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId">The match ID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaltsApiResponse"/>&gt;</returns>
        Task<ISaltsApiResponse> SaltsAsync(long matchId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Salts
        /// </summary>
        /// <remarks>
        ///  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From DB: 100req/s&lt;br&gt;From Steam: 10req/30mins | | Key | From DB: -&lt;br&gt;From Steam: 10req/min | | Global | From DB: -&lt;br&gt;From Steam: 10req/10s |     
        /// </remarks>
        /// <param name="matchId">The match ID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaltsApiResponse"/>?&gt;</returns>
        Task<ISaltsApiResponse?> SaltsOrDefaultAsync(long matchId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Live Broadcast URL
        /// </summary>
        /// <remarks>
        ///  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId">The match ID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUrlApiResponse"/>&gt;</returns>
        Task<IUrlApiResponse> UrlAsync(long matchId, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Live Broadcast URL
        /// </summary>
        /// <remarks>
        ///  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
        /// </remarks>
        /// <param name="matchId">The match ID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUrlApiResponse"/>?&gt;</returns>
        Task<IUrlApiResponse?> UrlOrDefaultAsync(long matchId, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IActiveMatchesApiResponse"/>
    /// </summary>
    public interface IActiveMatchesApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<ActiveMatch>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IActiveMatchesRawApiResponse"/>
    /// </summary>
    public interface IActiveMatchesRawApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<int>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IBulkMetadataApiResponse"/>
    /// </summary>
    public interface IBulkMetadataApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<int>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }
    }

    /// <summary>
    /// The <see cref="IMetadataApiResponse"/>
    /// </summary>
    public interface IMetadataApiResponse : DeadlockApiClient.Client.IApiResponse
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IMetadataRawApiResponse"/>
    /// </summary>
    public interface IMetadataRawApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<int>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 404 NotFound
        /// </summary>
        /// <returns></returns>
        bool IsNotFound { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IRecentlyFetchedApiResponse"/>
    /// </summary>
    public interface IRecentlyFetchedApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<ClickhouseMatchInfo>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="ISaltsApiResponse"/>
    /// </summary>
    public interface ISaltsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<DeadlockApiClient.Model.MatchSaltsResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IUrlApiResponse"/>
    /// </summary>
    public interface IUrlApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<DeadlockApiClient.Model.MatchSpectateResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 429 TooManyRequests
        /// </summary>
        /// <returns></returns>
        bool IsTooManyRequests { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class MatchesApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnActiveMatches;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorActiveMatches;

        internal void ExecuteOnActiveMatches(MatchesApi.ActiveMatchesApiResponse apiResponse)
        {
            OnActiveMatches?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorActiveMatches(Exception exception)
        {
            OnErrorActiveMatches?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnActiveMatchesRaw;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorActiveMatchesRaw;

        internal void ExecuteOnActiveMatchesRaw(MatchesApi.ActiveMatchesRawApiResponse apiResponse)
        {
            OnActiveMatchesRaw?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorActiveMatchesRaw(Exception exception)
        {
            OnErrorActiveMatchesRaw?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnBulkMetadata;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorBulkMetadata;

        internal void ExecuteOnBulkMetadata(MatchesApi.BulkMetadataApiResponse apiResponse)
        {
            OnBulkMetadata?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBulkMetadata(Exception exception)
        {
            OnErrorBulkMetadata?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnMetadata;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorMetadata;

        internal void ExecuteOnMetadata(MatchesApi.MetadataApiResponse apiResponse)
        {
            OnMetadata?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMetadata(Exception exception)
        {
            OnErrorMetadata?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnMetadataRaw;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorMetadataRaw;

        internal void ExecuteOnMetadataRaw(MatchesApi.MetadataRawApiResponse apiResponse)
        {
            OnMetadataRaw?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorMetadataRaw(Exception exception)
        {
            OnErrorMetadataRaw?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnRecentlyFetched;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorRecentlyFetched;

        internal void ExecuteOnRecentlyFetched(MatchesApi.RecentlyFetchedApiResponse apiResponse)
        {
            OnRecentlyFetched?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorRecentlyFetched(Exception exception)
        {
            OnErrorRecentlyFetched?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnSalts;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorSalts;

        internal void ExecuteOnSalts(MatchesApi.SaltsApiResponse apiResponse)
        {
            OnSalts?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorSalts(Exception exception)
        {
            OnErrorSalts?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnUrl;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorUrl;

        internal void ExecuteOnUrl(MatchesApi.UrlApiResponse apiResponse)
        {
            OnUrl?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorUrl(Exception exception)
        {
            OnErrorUrl?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class MatchesApi : IMatchesApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<MatchesApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public MatchesApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="MatchesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public MatchesApi(ILogger<MatchesApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, MatchesApiEvents matchesApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<MatchesApi>();
            HttpClient = httpClient;
            Events = matchesApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatActiveMatches(ref Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void AfterActiveMatchesDefaultImplementation(IActiveMatchesApiResponse apiResponseLocalVar, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterActiveMatches(ref suppressDefaultLog, apiResponseLocalVar, accountId, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void AfterActiveMatches(ref bool suppressDefaultLog, IActiveMatchesApiResponse apiResponseLocalVar, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void OnErrorActiveMatchesDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorActiveMatches(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, accountId, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorActiveMatches(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Active  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="accountId">The account ID to filter active matches by (&#x60;SteamID3&#x60;) (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IActiveMatchesApiResponse"/>&gt;</returns>
        public async Task<IActiveMatchesApiResponse?> ActiveMatchesOrDefaultAsync(Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ActiveMatchesAsync(accountId, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Active  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="accountId">The account ID to filter active matches by (&#x60;SteamID3&#x60;) (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IActiveMatchesApiResponse"/>&gt;</returns>
        public async Task<IActiveMatchesApiResponse> ActiveMatchesAsync(Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatActiveMatches(ref accountId, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/matches/active"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/matches/active");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["account_id"] = ClientUtils.ParameterToString(accountId.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ActiveMatchesApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ActiveMatchesApiResponse>();
                        ActiveMatchesApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/matches/active", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterActiveMatchesDefaultImplementation(apiResponseLocalVar, accountId, accountIds);

                        Events.ExecuteOnActiveMatches(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorActiveMatchesDefaultImplementation(e, "/v1/matches/active", uriBuilderLocalVar.Path, accountId, accountIds);
                Events.ExecuteOnErrorActiveMatches(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ActiveMatchesApiResponse"/>
        /// </summary>
        public partial class ActiveMatchesApiResponse : DeadlockApiClient.Client.ApiResponse, IActiveMatchesApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ActiveMatchesApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ActiveMatchesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ActiveMatchesApiResponse(ILogger<ActiveMatchesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ActiveMatchesApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ActiveMatchesApiResponse(ILogger<ActiveMatchesApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ActiveMatch>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ActiveMatch>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ActiveMatch>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        private void AfterActiveMatchesRawDefaultImplementation(IActiveMatchesRawApiResponse apiResponseLocalVar)
        {
            bool suppressDefaultLog = false;
            AfterActiveMatchesRaw(ref suppressDefaultLog, apiResponseLocalVar);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        partial void AfterActiveMatchesRaw(ref bool suppressDefaultLog, IActiveMatchesRawApiResponse apiResponseLocalVar);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        private void OnErrorActiveMatchesRawDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorActiveMatchesRaw(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        partial void OnErrorActiveMatchesRaw(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar);

        /// <summary>
        /// Active as Protobuf  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IActiveMatchesRawApiResponse"/>&gt;</returns>
        public async Task<IActiveMatchesRawApiResponse?> ActiveMatchesRawOrDefaultAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ActiveMatchesRawAsync(cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Active as Protobuf  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IActiveMatchesRawApiResponse"/>&gt;</returns>
        public async Task<IActiveMatchesRawApiResponse> ActiveMatchesRawAsync(System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/matches/active/raw"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/matches/active/raw");

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/octet-stream"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ActiveMatchesRawApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ActiveMatchesRawApiResponse>();
                        ActiveMatchesRawApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/matches/active/raw", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterActiveMatchesRawDefaultImplementation(apiResponseLocalVar);

                        Events.ExecuteOnActiveMatchesRaw(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorActiveMatchesRawDefaultImplementation(e, "/v1/matches/active/raw", uriBuilderLocalVar.Path);
                Events.ExecuteOnErrorActiveMatchesRaw(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ActiveMatchesRawApiResponse"/>
        /// </summary>
        public partial class ActiveMatchesRawApiResponse : DeadlockApiClient.Client.ApiResponse, IActiveMatchesRawApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ActiveMatchesRawApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ActiveMatchesRawApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ActiveMatchesRawApiResponse(ILogger<ActiveMatchesRawApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ActiveMatchesRawApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ActiveMatchesRawApiResponse(ILogger<ActiveMatchesRawApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<int>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<int>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<int>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBulkMetadata(ref Option<bool> includeInfo, ref Option<bool> includeMoreInfo, ref Option<bool> includeObjectives, ref Option<bool> includeMidBoss, ref Option<bool> includePlayerInfo, ref Option<bool> includePlayerItems, ref Option<bool> includePlayerStats, ref Option<bool> includePlayerDeathDetails, ref Option<string?> gameMode, Option<List<long>?> matchIds, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<bool?> isHighSkillRangeParties, ref Option<bool?> isLowPriPool, ref Option<bool?> isNewPlayerPool, Option<List<int>?> accountIds, ref Option<string?> heroIds, ref Option<string> orderBy, ref Option<string> orderDirection, ref Option<int> limit);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="orderBy"></param>
        /// <param name="orderDirection"></param>
        /// <returns></returns>
        private void ValidateBulkMetadata(Option<string> orderBy, Option<string> orderDirection)
        {
            if (orderBy.IsSet && orderBy.Value == null)
                throw new ArgumentNullException(nameof(orderBy));

            if (orderDirection.IsSet && orderDirection.Value == null)
                throw new ArgumentNullException(nameof(orderDirection));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="includeInfo"></param>
        /// <param name="includeMoreInfo"></param>
        /// <param name="includeObjectives"></param>
        /// <param name="includeMidBoss"></param>
        /// <param name="includePlayerInfo"></param>
        /// <param name="includePlayerItems"></param>
        /// <param name="includePlayerStats"></param>
        /// <param name="includePlayerDeathDetails"></param>
        /// <param name="gameMode"></param>
        /// <param name="matchIds"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroIds"></param>
        /// <param name="orderBy"></param>
        /// <param name="orderDirection"></param>
        /// <param name="limit"></param>
        private void AfterBulkMetadataDefaultImplementation(IBulkMetadataApiResponse apiResponseLocalVar, Option<bool> includeInfo, Option<bool> includeMoreInfo, Option<bool> includeObjectives, Option<bool> includeMidBoss, Option<bool> includePlayerInfo, Option<bool> includePlayerItems, Option<bool> includePlayerStats, Option<bool> includePlayerDeathDetails, Option<string?> gameMode, Option<List<long>?> matchIds, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<List<int>?> accountIds, Option<string?> heroIds, Option<string> orderBy, Option<string> orderDirection, Option<int> limit)
        {
            bool suppressDefaultLog = false;
            AfterBulkMetadata(ref suppressDefaultLog, apiResponseLocalVar, includeInfo, includeMoreInfo, includeObjectives, includeMidBoss, includePlayerInfo, includePlayerItems, includePlayerStats, includePlayerDeathDetails, gameMode, matchIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, accountIds, heroIds, orderBy, orderDirection, limit);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="includeInfo"></param>
        /// <param name="includeMoreInfo"></param>
        /// <param name="includeObjectives"></param>
        /// <param name="includeMidBoss"></param>
        /// <param name="includePlayerInfo"></param>
        /// <param name="includePlayerItems"></param>
        /// <param name="includePlayerStats"></param>
        /// <param name="includePlayerDeathDetails"></param>
        /// <param name="gameMode"></param>
        /// <param name="matchIds"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroIds"></param>
        /// <param name="orderBy"></param>
        /// <param name="orderDirection"></param>
        /// <param name="limit"></param>
        partial void AfterBulkMetadata(ref bool suppressDefaultLog, IBulkMetadataApiResponse apiResponseLocalVar, Option<bool> includeInfo, Option<bool> includeMoreInfo, Option<bool> includeObjectives, Option<bool> includeMidBoss, Option<bool> includePlayerInfo, Option<bool> includePlayerItems, Option<bool> includePlayerStats, Option<bool> includePlayerDeathDetails, Option<string?> gameMode, Option<List<long>?> matchIds, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<List<int>?> accountIds, Option<string?> heroIds, Option<string> orderBy, Option<string> orderDirection, Option<int> limit);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="includeInfo"></param>
        /// <param name="includeMoreInfo"></param>
        /// <param name="includeObjectives"></param>
        /// <param name="includeMidBoss"></param>
        /// <param name="includePlayerInfo"></param>
        /// <param name="includePlayerItems"></param>
        /// <param name="includePlayerStats"></param>
        /// <param name="includePlayerDeathDetails"></param>
        /// <param name="gameMode"></param>
        /// <param name="matchIds"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroIds"></param>
        /// <param name="orderBy"></param>
        /// <param name="orderDirection"></param>
        /// <param name="limit"></param>
        private void OnErrorBulkMetadataDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> includeInfo, Option<bool> includeMoreInfo, Option<bool> includeObjectives, Option<bool> includeMidBoss, Option<bool> includePlayerInfo, Option<bool> includePlayerItems, Option<bool> includePlayerStats, Option<bool> includePlayerDeathDetails, Option<string?> gameMode, Option<List<long>?> matchIds, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<List<int>?> accountIds, Option<string?> heroIds, Option<string> orderBy, Option<string> orderDirection, Option<int> limit)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorBulkMetadata(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, includeInfo, includeMoreInfo, includeObjectives, includeMidBoss, includePlayerInfo, includePlayerItems, includePlayerStats, includePlayerDeathDetails, gameMode, matchIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, accountIds, heroIds, orderBy, orderDirection, limit);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="includeInfo"></param>
        /// <param name="includeMoreInfo"></param>
        /// <param name="includeObjectives"></param>
        /// <param name="includeMidBoss"></param>
        /// <param name="includePlayerInfo"></param>
        /// <param name="includePlayerItems"></param>
        /// <param name="includePlayerStats"></param>
        /// <param name="includePlayerDeathDetails"></param>
        /// <param name="gameMode"></param>
        /// <param name="matchIds"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroIds"></param>
        /// <param name="orderBy"></param>
        /// <param name="orderDirection"></param>
        /// <param name="limit"></param>
        partial void OnErrorBulkMetadata(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool> includeInfo, Option<bool> includeMoreInfo, Option<bool> includeObjectives, Option<bool> includeMidBoss, Option<bool> includePlayerInfo, Option<bool> includePlayerItems, Option<bool> includePlayerStats, Option<bool> includePlayerDeathDetails, Option<string?> gameMode, Option<List<long>?> matchIds, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<List<int>?> accountIds, Option<string?> heroIds, Option<string> orderBy, Option<string> orderDirection, Option<int> limit);

        /// <summary>
        /// Bulk Metadata  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
        /// </summary>
        /// <param name="includeInfo">Include match info in the response. (optional, default to true)</param>
        /// <param name="includeMoreInfo">Include more match info in the response. (optional)</param>
        /// <param name="includeObjectives">Include objectives in the response. (optional)</param>
        /// <param name="includeMidBoss">Include midboss in the response. (optional)</param>
        /// <param name="includePlayerInfo">Include player info in the response. (optional)</param>
        /// <param name="includePlayerItems">Include player items in the response. (optional)</param>
        /// <param name="includePlayerStats">Include player stats in the response. (optional)</param>
        /// <param name="includePlayerDeathDetails">Include player death details in the response. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="matchIds">Comma separated list of match ids, limited by &#x60;limit&#x60; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="accountIds">Filter matches by account IDs of players that participated in the match. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="orderBy">The field to order the results by. (optional)</param>
        /// <param name="orderDirection">The direction to order the results by. (optional)</param>
        /// <param name="limit">The maximum number of matches to return. (optional, default to 1000)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBulkMetadataApiResponse"/>&gt;</returns>
        public async Task<IBulkMetadataApiResponse?> BulkMetadataOrDefaultAsync(Option<bool> includeInfo = default, Option<bool> includeMoreInfo = default, Option<bool> includeObjectives = default, Option<bool> includeMidBoss = default, Option<bool> includePlayerInfo = default, Option<bool> includePlayerItems = default, Option<bool> includePlayerStats = default, Option<bool> includePlayerDeathDetails = default, Option<string?> gameMode = default, Option<List<long>?> matchIds = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<List<int>?> accountIds = default, Option<string?> heroIds = default, Option<string> orderBy = default, Option<string> orderDirection = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BulkMetadataAsync(includeInfo, includeMoreInfo, includeObjectives, includeMidBoss, includePlayerInfo, includePlayerItems, includePlayerStats, includePlayerDeathDetails, gameMode, matchIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, accountIds, heroIds, orderBy, orderDirection, limit, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Bulk Metadata  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="includeInfo">Include match info in the response. (optional, default to true)</param>
        /// <param name="includeMoreInfo">Include more match info in the response. (optional)</param>
        /// <param name="includeObjectives">Include objectives in the response. (optional)</param>
        /// <param name="includeMidBoss">Include midboss in the response. (optional)</param>
        /// <param name="includePlayerInfo">Include player info in the response. (optional)</param>
        /// <param name="includePlayerItems">Include player items in the response. (optional)</param>
        /// <param name="includePlayerStats">Include player stats in the response. (optional)</param>
        /// <param name="includePlayerDeathDetails">Include player death details in the response. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="matchIds">Comma separated list of match ids, limited by &#x60;limit&#x60; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="accountIds">Filter matches by account IDs of players that participated in the match. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="orderBy">The field to order the results by. (optional)</param>
        /// <param name="orderDirection">The direction to order the results by. (optional)</param>
        /// <param name="limit">The maximum number of matches to return. (optional, default to 1000)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBulkMetadataApiResponse"/>&gt;</returns>
        public async Task<IBulkMetadataApiResponse> BulkMetadataAsync(Option<bool> includeInfo = default, Option<bool> includeMoreInfo = default, Option<bool> includeObjectives = default, Option<bool> includeMidBoss = default, Option<bool> includePlayerInfo = default, Option<bool> includePlayerItems = default, Option<bool> includePlayerStats = default, Option<bool> includePlayerDeathDetails = default, Option<string?> gameMode = default, Option<List<long>?> matchIds = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<List<int>?> accountIds = default, Option<string?> heroIds = default, Option<string> orderBy = default, Option<string> orderDirection = default, Option<int> limit = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateBulkMetadata(orderBy, orderDirection);

                FormatBulkMetadata(ref includeInfo, ref includeMoreInfo, ref includeObjectives, ref includeMidBoss, ref includePlayerInfo, ref includePlayerItems, ref includePlayerStats, ref includePlayerDeathDetails, ref gameMode, matchIds, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref isHighSkillRangeParties, ref isLowPriPool, ref isNewPlayerPool, accountIds, ref heroIds, ref orderBy, ref orderDirection, ref limit);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/matches/metadata"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/matches/metadata");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (includeInfo.IsSet)
                        parseQueryStringLocalVar["include_info"] = ClientUtils.ParameterToString(includeInfo.Value);

                    if (includeMoreInfo.IsSet)
                        parseQueryStringLocalVar["include_more_info"] = ClientUtils.ParameterToString(includeMoreInfo.Value);

                    if (includeObjectives.IsSet)
                        parseQueryStringLocalVar["include_objectives"] = ClientUtils.ParameterToString(includeObjectives.Value);

                    if (includeMidBoss.IsSet)
                        parseQueryStringLocalVar["include_mid_boss"] = ClientUtils.ParameterToString(includeMidBoss.Value);

                    if (includePlayerInfo.IsSet)
                        parseQueryStringLocalVar["include_player_info"] = ClientUtils.ParameterToString(includePlayerInfo.Value);

                    if (includePlayerItems.IsSet)
                        parseQueryStringLocalVar["include_player_items"] = ClientUtils.ParameterToString(includePlayerItems.Value);

                    if (includePlayerStats.IsSet)
                        parseQueryStringLocalVar["include_player_stats"] = ClientUtils.ParameterToString(includePlayerStats.Value);

                    if (includePlayerDeathDetails.IsSet)
                        parseQueryStringLocalVar["include_player_death_details"] = ClientUtils.ParameterToString(includePlayerDeathDetails.Value);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (matchIds.IsSet)
                        parseQueryStringLocalVar["match_ids"] = ClientUtils.ParameterToString(matchIds.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (isHighSkillRangeParties.IsSet)
                        parseQueryStringLocalVar["is_high_skill_range_parties"] = ClientUtils.ParameterToString(isHighSkillRangeParties.Value);

                    if (isLowPriPool.IsSet)
                        parseQueryStringLocalVar["is_low_pri_pool"] = ClientUtils.ParameterToString(isLowPriPool.Value);

                    if (isNewPlayerPool.IsSet)
                        parseQueryStringLocalVar["is_new_player_pool"] = ClientUtils.ParameterToString(isNewPlayerPool.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    if (heroIds.IsSet)
                        parseQueryStringLocalVar["hero_ids"] = ClientUtils.ParameterToString(heroIds.Value);

                    if (orderBy.IsSet)
                        parseQueryStringLocalVar["order_by"] = ClientUtils.ParameterToString(orderBy.Value);

                    if (orderDirection.IsSet)
                        parseQueryStringLocalVar["order_direction"] = ClientUtils.ParameterToString(orderDirection.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/octet-stream"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<BulkMetadataApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BulkMetadataApiResponse>();
                        BulkMetadataApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/matches/metadata", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterBulkMetadataDefaultImplementation(apiResponseLocalVar, includeInfo, includeMoreInfo, includeObjectives, includeMidBoss, includePlayerInfo, includePlayerItems, includePlayerStats, includePlayerDeathDetails, gameMode, matchIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, accountIds, heroIds, orderBy, orderDirection, limit);

                        Events.ExecuteOnBulkMetadata(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBulkMetadataDefaultImplementation(e, "/v1/matches/metadata", uriBuilderLocalVar.Path, includeInfo, includeMoreInfo, includeObjectives, includeMidBoss, includePlayerInfo, includePlayerItems, includePlayerStats, includePlayerDeathDetails, gameMode, matchIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, accountIds, heroIds, orderBy, orderDirection, limit);
                Events.ExecuteOnErrorBulkMetadata(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BulkMetadataApiResponse"/>
        /// </summary>
        public partial class BulkMetadataApiResponse : DeadlockApiClient.Client.ApiResponse, IBulkMetadataApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BulkMetadataApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BulkMetadataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BulkMetadataApiResponse(ILogger<BulkMetadataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="BulkMetadataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BulkMetadataApiResponse(ILogger<BulkMetadataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<int>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<int>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<int>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMetadata(ref long matchId, ref Option<bool?> isCustom);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="matchId"></param>
        /// <param name="isCustom"></param>
        private void AfterMetadataDefaultImplementation(IMetadataApiResponse apiResponseLocalVar, long matchId, Option<bool?> isCustom)
        {
            bool suppressDefaultLog = false;
            AfterMetadata(ref suppressDefaultLog, apiResponseLocalVar, matchId, isCustom);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="matchId"></param>
        /// <param name="isCustom"></param>
        partial void AfterMetadata(ref bool suppressDefaultLog, IMetadataApiResponse apiResponseLocalVar, long matchId, Option<bool?> isCustom);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="matchId"></param>
        /// <param name="isCustom"></param>
        private void OnErrorMetadataDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long matchId, Option<bool?> isCustom)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMetadata(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, matchId, isCustom);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="matchId"></param>
        /// <param name="isCustom"></param>
        partial void OnErrorMetadata(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long matchId, Option<bool?> isCustom);

        /// <summary>
        /// Metadata  This endpoint returns the match metadata for the given &#x60;match_id&#x60; parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 5req/h | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 400req/h | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 2000req/h |     
        /// </summary>
        /// <param name="matchId">The match ID</param>
        /// <param name="isCustom"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMetadataApiResponse"/>&gt;</returns>
        public async Task<IMetadataApiResponse?> MetadataOrDefaultAsync(long matchId, Option<bool?> isCustom = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MetadataAsync(matchId, isCustom, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Metadata  This endpoint returns the match metadata for the given &#x60;match_id&#x60; parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 5req/h | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 400req/h | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 2000req/h |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId">The match ID</param>
        /// <param name="isCustom"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMetadataApiResponse"/>&gt;</returns>
        public async Task<IMetadataApiResponse> MetadataAsync(long matchId, Option<bool?> isCustom = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatMetadata(ref matchId, ref isCustom);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/matches/{match_id}/metadata"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/matches/{match_id}/metadata");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bmatch_id%7D", Uri.EscapeDataString(matchId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (isCustom.IsSet)
                        parseQueryStringLocalVar["is_custom"] = ClientUtils.ParameterToString(isCustom.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<MetadataApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MetadataApiResponse>();
                        MetadataApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/matches/{match_id}/metadata", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterMetadataDefaultImplementation(apiResponseLocalVar, matchId, isCustom);

                        Events.ExecuteOnMetadata(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMetadataDefaultImplementation(e, "/v1/matches/{match_id}/metadata", uriBuilderLocalVar.Path, matchId, isCustom);
                Events.ExecuteOnErrorMetadata(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MetadataApiResponse"/>
        /// </summary>
        public partial class MetadataApiResponse : DeadlockApiClient.Client.ApiResponse, IMetadataApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MetadataApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MetadataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MetadataApiResponse(ILogger<MetadataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="MetadataApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MetadataApiResponse(ILogger<MetadataApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatMetadataRaw(ref long matchId, ref Option<bool?> isCustom);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="matchId"></param>
        /// <param name="isCustom"></param>
        private void AfterMetadataRawDefaultImplementation(IMetadataRawApiResponse apiResponseLocalVar, long matchId, Option<bool?> isCustom)
        {
            bool suppressDefaultLog = false;
            AfterMetadataRaw(ref suppressDefaultLog, apiResponseLocalVar, matchId, isCustom);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="matchId"></param>
        /// <param name="isCustom"></param>
        partial void AfterMetadataRaw(ref bool suppressDefaultLog, IMetadataRawApiResponse apiResponseLocalVar, long matchId, Option<bool?> isCustom);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="matchId"></param>
        /// <param name="isCustom"></param>
        private void OnErrorMetadataRawDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long matchId, Option<bool?> isCustom)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorMetadataRaw(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, matchId, isCustom);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="matchId"></param>
        /// <param name="isCustom"></param>
        partial void OnErrorMetadataRaw(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long matchId, Option<bool?> isCustom);

        /// <summary>
        /// Metadata as Protobuf  This endpoints returns the raw .meta.bz2 file for the given &#x60;match_id&#x60;.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 5req/h | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 400req/h | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 2000req/h |     
        /// </summary>
        /// <param name="matchId">The match ID</param>
        /// <param name="isCustom"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMetadataRawApiResponse"/>&gt;</returns>
        public async Task<IMetadataRawApiResponse?> MetadataRawOrDefaultAsync(long matchId, Option<bool?> isCustom = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await MetadataRawAsync(matchId, isCustom, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Metadata as Protobuf  This endpoints returns the raw .meta.bz2 file for the given &#x60;match_id&#x60;.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From Cache: 100req/s&lt;br&gt;From S3: 100req/10s&lt;br&gt;From Steam: 5req/h | | Key | From Cache: 100req/s&lt;br&gt;From S3: 100req/s&lt;br&gt;From Steam: 400req/h | | Global | From Cache: 100req/s&lt;br&gt;From S3: 700req/s&lt;br&gt;From Steam: 2000req/h |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId">The match ID</param>
        /// <param name="isCustom"> (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IMetadataRawApiResponse"/>&gt;</returns>
        public async Task<IMetadataRawApiResponse> MetadataRawAsync(long matchId, Option<bool?> isCustom = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatMetadataRaw(ref matchId, ref isCustom);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/matches/{match_id}/metadata/raw"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/matches/{match_id}/metadata/raw");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bmatch_id%7D", Uri.EscapeDataString(matchId.ToString()));

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (isCustom.IsSet)
                        parseQueryStringLocalVar["is_custom"] = ClientUtils.ParameterToString(isCustom.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/octet-stream"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<MetadataRawApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<MetadataRawApiResponse>();
                        MetadataRawApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/matches/{match_id}/metadata/raw", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterMetadataRawDefaultImplementation(apiResponseLocalVar, matchId, isCustom);

                        Events.ExecuteOnMetadataRaw(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorMetadataRawDefaultImplementation(e, "/v1/matches/{match_id}/metadata/raw", uriBuilderLocalVar.Path, matchId, isCustom);
                Events.ExecuteOnErrorMetadataRaw(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="MetadataRawApiResponse"/>
        /// </summary>
        public partial class MetadataRawApiResponse : DeadlockApiClient.Client.ApiResponse, IMetadataRawApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<MetadataRawApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="MetadataRawApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MetadataRawApiResponse(ILogger<MetadataRawApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="MetadataRawApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public MetadataRawApiResponse(ILogger<MetadataRawApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<int>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<int>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<int>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 404 NotFound
            /// </summary>
            /// <returns></returns>
            public bool IsNotFound => 404 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatRecentlyFetched(ref Option<bool?> playerIngestedOnly);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="playerIngestedOnly"></param>
        private void AfterRecentlyFetchedDefaultImplementation(IRecentlyFetchedApiResponse apiResponseLocalVar, Option<bool?> playerIngestedOnly)
        {
            bool suppressDefaultLog = false;
            AfterRecentlyFetched(ref suppressDefaultLog, apiResponseLocalVar, playerIngestedOnly);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="playerIngestedOnly"></param>
        partial void AfterRecentlyFetched(ref bool suppressDefaultLog, IRecentlyFetchedApiResponse apiResponseLocalVar, Option<bool?> playerIngestedOnly);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="playerIngestedOnly"></param>
        private void OnErrorRecentlyFetchedDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool?> playerIngestedOnly)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorRecentlyFetched(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, playerIngestedOnly);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="playerIngestedOnly"></param>
        partial void OnErrorRecentlyFetched(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<bool?> playerIngestedOnly);

        /// <summary>
        /// Recently Fetched  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="playerIngestedOnly">If true, only return matches that have been ingested by players. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRecentlyFetchedApiResponse"/>&gt;</returns>
        public async Task<IRecentlyFetchedApiResponse?> RecentlyFetchedOrDefaultAsync(Option<bool?> playerIngestedOnly = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await RecentlyFetchedAsync(playerIngestedOnly, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Recently Fetched  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="playerIngestedOnly">If true, only return matches that have been ingested by players. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IRecentlyFetchedApiResponse"/>&gt;</returns>
        public async Task<IRecentlyFetchedApiResponse> RecentlyFetchedAsync(Option<bool?> playerIngestedOnly = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatRecentlyFetched(ref playerIngestedOnly);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/matches/recently-fetched"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/matches/recently-fetched");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (playerIngestedOnly.IsSet)
                        parseQueryStringLocalVar["player_ingested_only"] = ClientUtils.ParameterToString(playerIngestedOnly.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<RecentlyFetchedApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<RecentlyFetchedApiResponse>();
                        RecentlyFetchedApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/matches/recently-fetched", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterRecentlyFetchedDefaultImplementation(apiResponseLocalVar, playerIngestedOnly);

                        Events.ExecuteOnRecentlyFetched(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorRecentlyFetchedDefaultImplementation(e, "/v1/matches/recently-fetched", uriBuilderLocalVar.Path, playerIngestedOnly);
                Events.ExecuteOnErrorRecentlyFetched(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="RecentlyFetchedApiResponse"/>
        /// </summary>
        public partial class RecentlyFetchedApiResponse : DeadlockApiClient.Client.ApiResponse, IRecentlyFetchedApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<RecentlyFetchedApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="RecentlyFetchedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RecentlyFetchedApiResponse(ILogger<RecentlyFetchedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="RecentlyFetchedApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public RecentlyFetchedApiResponse(ILogger<RecentlyFetchedApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ClickhouseMatchInfo>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ClickhouseMatchInfo>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ClickhouseMatchInfo>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatSalts(ref long matchId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="matchId"></param>
        private void AfterSaltsDefaultImplementation(ISaltsApiResponse apiResponseLocalVar, long matchId)
        {
            bool suppressDefaultLog = false;
            AfterSalts(ref suppressDefaultLog, apiResponseLocalVar, matchId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="matchId"></param>
        partial void AfterSalts(ref bool suppressDefaultLog, ISaltsApiResponse apiResponseLocalVar, long matchId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="matchId"></param>
        private void OnErrorSaltsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long matchId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorSalts(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, matchId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="matchId"></param>
        partial void OnErrorSalts(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long matchId);

        /// <summary>
        /// Salts  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From DB: 100req/s&lt;br&gt;From Steam: 10req/30mins | | Key | From DB: -&lt;br&gt;From Steam: 10req/min | | Global | From DB: -&lt;br&gt;From Steam: 10req/10s |     
        /// </summary>
        /// <param name="matchId">The match ID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaltsApiResponse"/>&gt;</returns>
        public async Task<ISaltsApiResponse?> SaltsOrDefaultAsync(long matchId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await SaltsAsync(matchId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Salts  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | From DB: 100req/s&lt;br&gt;From Steam: 10req/30mins | | Key | From DB: -&lt;br&gt;From Steam: 10req/min | | Global | From DB: -&lt;br&gt;From Steam: 10req/10s |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId">The match ID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ISaltsApiResponse"/>&gt;</returns>
        public async Task<ISaltsApiResponse> SaltsAsync(long matchId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatSalts(ref matchId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/matches/{match_id}/salts"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/matches/{match_id}/salts");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bmatch_id%7D", Uri.EscapeDataString(matchId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<SaltsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<SaltsApiResponse>();
                        SaltsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/matches/{match_id}/salts", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterSaltsDefaultImplementation(apiResponseLocalVar, matchId);

                        Events.ExecuteOnSalts(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorSaltsDefaultImplementation(e, "/v1/matches/{match_id}/salts", uriBuilderLocalVar.Path, matchId);
                Events.ExecuteOnErrorSalts(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="SaltsApiResponse"/>
        /// </summary>
        public partial class SaltsApiResponse : DeadlockApiClient.Client.ApiResponse, ISaltsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<SaltsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="SaltsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SaltsApiResponse(ILogger<SaltsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="SaltsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public SaltsApiResponse(ILogger<SaltsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public DeadlockApiClient.Model.MatchSaltsResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<DeadlockApiClient.Model.MatchSaltsResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out DeadlockApiClient.Model.MatchSaltsResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatUrl(ref long matchId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="matchId"></param>
        private void AfterUrlDefaultImplementation(IUrlApiResponse apiResponseLocalVar, long matchId)
        {
            bool suppressDefaultLog = false;
            AfterUrl(ref suppressDefaultLog, apiResponseLocalVar, matchId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="matchId"></param>
        partial void AfterUrl(ref bool suppressDefaultLog, IUrlApiResponse apiResponseLocalVar, long matchId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="matchId"></param>
        private void OnErrorUrlDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long matchId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorUrl(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, matchId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="matchId"></param>
        partial void OnErrorUrl(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, long matchId);

        /// <summary>
        /// Live Broadcast URL  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
        /// </summary>
        /// <param name="matchId">The match ID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUrlApiResponse"/>&gt;</returns>
        public async Task<IUrlApiResponse?> UrlOrDefaultAsync(long matchId, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await UrlAsync(matchId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Live Broadcast URL  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="matchId">The match ID</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IUrlApiResponse"/>&gt;</returns>
        public async Task<IUrlApiResponse> UrlAsync(long matchId, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatUrl(ref matchId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/matches/{match_id}/live/url"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/matches/{match_id}/live/url");
                    uriBuilderLocalVar.Path = uriBuilderLocalVar.Path.Replace("%7Bmatch_id%7D", Uri.EscapeDataString(matchId.ToString()));

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<UrlApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<UrlApiResponse>();
                        UrlApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/matches/{match_id}/live/url", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterUrlDefaultImplementation(apiResponseLocalVar, matchId);

                        Events.ExecuteOnUrl(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorUrlDefaultImplementation(e, "/v1/matches/{match_id}/live/url", uriBuilderLocalVar.Path, matchId);
                Events.ExecuteOnErrorUrl(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="UrlApiResponse"/>
        /// </summary>
        public partial class UrlApiResponse : DeadlockApiClient.Client.ApiResponse, IUrlApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<UrlApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="UrlApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UrlApiResponse(ILogger<UrlApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="UrlApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public UrlApiResponse(ILogger<UrlApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public DeadlockApiClient.Model.MatchSpectateResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<DeadlockApiClient.Model.MatchSpectateResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out DeadlockApiClient.Model.MatchSpectateResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 429 TooManyRequests
            /// </summary>
            /// <returns></returns>
            public bool IsTooManyRequests => 429 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
