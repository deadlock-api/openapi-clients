// <auto-generated>
/*
 * Deadlock API
 *
 *  ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Net;
using System.IO;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using DeadlockApiClient.Client;
using DeadlockApiClient.Model;
using System.Diagnostics.CodeAnalysis;

namespace DeadlockApiClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IAnalyticsApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        AnalyticsApiEvents Events { get; }

        /// <summary>
        /// Ability Order Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="heroId">See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minAbilityUpgrades">Filter players based on their minimum number of ability upgrades over the whole match. (optional)</param>
        /// <param name="maxAbilityUpgrades">Filter players based on their maximum number of ability upgrades over the whole match. (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAbilityOrderStatsApiResponse"/>&gt;</returns>
        Task<IAbilityOrderStatsApiResponse> AbilityOrderStatsAsync(int heroId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minAbilityUpgrades = default, Option<long?> maxAbilityUpgrades = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> minMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Ability Order Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="heroId">See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minAbilityUpgrades">Filter players based on their minimum number of ability upgrades over the whole match. (optional)</param>
        /// <param name="maxAbilityUpgrades">Filter players based on their maximum number of ability upgrades over the whole match. (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAbilityOrderStatsApiResponse"/>?&gt;</returns>
        Task<IAbilityOrderStatsApiResponse?> AbilityOrderStatsOrDefaultAsync(int heroId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minAbilityUpgrades = default, Option<long?> maxAbilityUpgrades = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> minMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Badge Distribution
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBadgeDistributionApiResponse"/>&gt;</returns>
        Task<IBadgeDistributionApiResponse> BadgeDistributionAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Badge Distribution
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBadgeDistributionApiResponse"/>?&gt;</returns>
        Task<IBadgeDistributionApiResponse?> BadgeDistributionOrDefaultAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Build Item Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="heroId">Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minLastUpdatedUnixTimestamp">Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxLastUpdatedUnixTimestamp">Filter builds based on their last updated time (Unix timestamp). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBuildItemStatsApiResponse"/>&gt;</returns>
        Task<IBuildItemStatsApiResponse> BuildItemStatsAsync(Option<int?> heroId = default, Option<long?> minLastUpdatedUnixTimestamp = default, Option<long?> maxLastUpdatedUnixTimestamp = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Build Item Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="heroId">Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minLastUpdatedUnixTimestamp">Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxLastUpdatedUnixTimestamp">Filter builds based on their last updated time (Unix timestamp). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBuildItemStatsApiResponse"/>?&gt;</returns>
        Task<IBuildItemStatsApiResponse?> BuildItemStatsOrDefaultAsync(Option<int?> heroId = default, Option<long?> minLastUpdatedUnixTimestamp = default, Option<long?> maxLastUpdatedUnixTimestamp = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Comb Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="includeHeroIds">Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="excludeHeroIds">Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="combSize">The combination size to return. (optional, default to 6)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroCombStatsApiResponse"/>&gt;</returns>
        Task<IHeroCombStatsApiResponse> HeroCombStatsAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<List<int>?> includeHeroIds = default, Option<List<int>?> excludeHeroIds = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<int?> combSize = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Comb Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="includeHeroIds">Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="excludeHeroIds">Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="combSize">The combination size to return. (optional, default to 6)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroCombStatsApiResponse"/>?&gt;</returns>
        Task<IHeroCombStatsApiResponse?> HeroCombStatsOrDefaultAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<List<int>?> includeHeroIds = default, Option<List<int>?> excludeHeroIds = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<int?> combSize = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Counter Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (&#x60;hero_id&#x60;) wins against an enemy hero (&#x60;enemy_hero_id&#x60;) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minEnemyNetworth">Filter enemy players based on their net worth. (optional)</param>
        /// <param name="maxEnemyNetworth">Filter enemy players based on their net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="sameLaneFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroCountersStatsApiResponse"/>&gt;</returns>
        Task<IHeroCountersStatsApiResponse> HeroCountersStatsAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<long?> minEnemyNetworth = default, Option<long?> maxEnemyNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> sameLaneFilter = default, Option<long?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Counter Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (&#x60;hero_id&#x60;) wins against an enemy hero (&#x60;enemy_hero_id&#x60;) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minEnemyNetworth">Filter enemy players based on their net worth. (optional)</param>
        /// <param name="maxEnemyNetworth">Filter enemy players based on their net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="sameLaneFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroCountersStatsApiResponse"/>?&gt;</returns>
        Task<IHeroCountersStatsApiResponse?> HeroCountersStatsOrDefaultAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<long?> minEnemyNetworth = default, Option<long?> maxEnemyNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> sameLaneFilter = default, Option<long?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Scoreboard
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">The field to sort by.</param>
        /// <param name="sortDirection">The direction to sort heroes in. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minMatches">Filter by min number of matches played. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroScoreboardApiResponse"/>&gt;</returns>
        Task<IHeroScoreboardApiResponse> HeroScoreboardAsync(string sortBy, Option<string> sortDirection = default, Option<string?> gameMode = default, Option<int?> minMatches = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Scoreboard
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="sortBy">The field to sort by.</param>
        /// <param name="sortDirection">The direction to sort heroes in. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minMatches">Filter by min number of matches played. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroScoreboardApiResponse"/>?&gt;</returns>
        Task<IHeroScoreboardApiResponse?> HeroScoreboardOrDefaultAsync(string sortBy, Option<string> sortDirection = default, Option<string?> gameMode = default, Option<int?> minMatches = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucket">Bucket allows you to group the stats by a specific field. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minHeroMatches">Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)</param>
        /// <param name="maxHeroMatches">Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)</param>
        /// <param name="minHeroMatchesTotal">Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)</param>
        /// <param name="maxHeroMatchesTotal">Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroStatsApiResponse"/>&gt;</returns>
        Task<IHeroStatsApiResponse> HeroStatsAsync(Option<string> bucket = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minHeroMatches = default, Option<long?> maxHeroMatches = default, Option<long?> minHeroMatchesTotal = default, Option<long?> maxHeroMatchesTotal = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="bucket">Bucket allows you to group the stats by a specific field. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minHeroMatches">Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)</param>
        /// <param name="maxHeroMatches">Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)</param>
        /// <param name="minHeroMatchesTotal">Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)</param>
        /// <param name="maxHeroMatchesTotal">Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroStatsApiResponse"/>?&gt;</returns>
        Task<IHeroStatsApiResponse?> HeroStatsOrDefaultAsync(Option<string> bucket = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minHeroMatches = default, Option<long?> maxHeroMatches = default, Option<long?> minHeroMatchesTotal = default, Option<long?> maxHeroMatchesTotal = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Synergy Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (&#x60;hero_id1&#x60; and &#x60;hero_id2&#x60;) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="sameLaneFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)</param>
        /// <param name="samePartyFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroSynergiesStatsApiResponse"/>&gt;</returns>
        Task<IHeroSynergiesStatsApiResponse> HeroSynergiesStatsAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> sameLaneFilter = default, Option<bool?> samePartyFilter = default, Option<long?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Hero Synergy Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (&#x60;hero_id1&#x60; and &#x60;hero_id2&#x60;) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="sameLaneFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)</param>
        /// <param name="samePartyFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroSynergiesStatsApiResponse"/>?&gt;</returns>
        Task<IHeroSynergiesStatsApiResponse?> HeroSynergiesStatsOrDefaultAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> sameLaneFilter = default, Option<bool?> samePartyFilter = default, Option<long?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Item Permutation Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="itemIds">Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="combSize">The combination size to return. (optional, default to 2)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IItemPermutationStatsApiResponse"/>&gt;</returns>
        Task<IItemPermutationStatsApiResponse> ItemPermutationStatsAsync(Option<List<int>?> itemIds = default, Option<int?> combSize = default, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<int?> heroId = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Item Permutation Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="itemIds">Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="combSize">The combination size to return. (optional, default to 2)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IItemPermutationStatsApiResponse"/>?&gt;</returns>
        Task<IItemPermutationStatsApiResponse?> ItemPermutationStatsOrDefaultAsync(Option<List<int>?> itemIds = default, Option<int?> combSize = default, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<int?> heroId = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Item Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucket">Bucket allows you to group the stats by a specific field. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for an item to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="minBoughtAtS">Filter items bought after this game time (seconds). (optional)</param>
        /// <param name="maxBoughtAtS">Filter items bought before this game time (seconds). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IItemStatsApiResponse"/>&gt;</returns>
        Task<IItemStatsApiResponse> ItemStatsAsync(Option<string> bucket = default, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<int?> heroId = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, Option<int?> minBoughtAtS = default, Option<int?> maxBoughtAtS = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Item Stats
        /// </summary>
        /// <remarks>
        ///  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="bucket">Bucket allows you to group the stats by a specific field. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for an item to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional) (deprecated)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="minBoughtAtS">Filter items bought after this game time (seconds). (optional)</param>
        /// <param name="maxBoughtAtS">Filter items bought before this game time (seconds). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IItemStatsApiResponse"/>?&gt;</returns>
        Task<IItemStatsApiResponse?> ItemStatsOrDefaultAsync(Option<string> bucket = default, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<int?> heroId = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, Option<int?> minBoughtAtS = default, Option<int?> maxBoughtAtS = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Kill Death Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the kill-death statistics across a 100x100 pixel raster.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="team">Filter by team number. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="accountIds">Filter matches by account IDs of players that participated in the match. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minKillsPerRaster">Filter Raster cells based on minimum kills. (optional)</param>
        /// <param name="maxKillsPerRaster">Filter Raster cells based on maximum kills. (optional)</param>
        /// <param name="minDeathsPerRaster">Filter Raster cells based on minimum deaths. (optional)</param>
        /// <param name="maxDeathsPerRaster">Filter Raster cells based on maximum deaths. (optional)</param>
        /// <param name="minGameTimeS">Filter kills based on their game time. (optional)</param>
        /// <param name="maxGameTimeS">Filter kills based on their game time. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKillDeathStatsApiResponse"/>&gt;</returns>
        Task<IKillDeathStatsApiResponse> KillDeathStatsAsync(Option<int?> team = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<List<int>?> accountIds = default, Option<string?> heroIds = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<int?> minKillsPerRaster = default, Option<int?> maxKillsPerRaster = default, Option<int?> minDeathsPerRaster = default, Option<int?> maxDeathsPerRaster = default, Option<int?> minGameTimeS = default, Option<int?> maxGameTimeS = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Kill Death Stats
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the kill-death statistics across a 100x100 pixel raster.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="team">Filter by team number. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="accountIds">Filter matches by account IDs of players that participated in the match. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minKillsPerRaster">Filter Raster cells based on minimum kills. (optional)</param>
        /// <param name="maxKillsPerRaster">Filter Raster cells based on maximum kills. (optional)</param>
        /// <param name="minDeathsPerRaster">Filter Raster cells based on minimum deaths. (optional)</param>
        /// <param name="maxDeathsPerRaster">Filter Raster cells based on maximum deaths. (optional)</param>
        /// <param name="minGameTimeS">Filter kills based on their game time. (optional)</param>
        /// <param name="maxGameTimeS">Filter kills based on their game time. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKillDeathStatsApiResponse"/>?&gt;</returns>
        Task<IKillDeathStatsApiResponse?> KillDeathStatsOrDefaultAsync(Option<int?> team = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<List<int>?> accountIds = default, Option<string?> heroIds = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<int?> minKillsPerRaster = default, Option<int?> maxKillsPerRaster = default, Option<int?> minDeathsPerRaster = default, Option<int?> maxDeathsPerRaster = default, Option<int?> minGameTimeS = default, Option<int?> maxGameTimeS = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Player Performance Curve
        /// </summary>
        /// <remarks>
        ///  Retrieves player performance statistics (net worth, kills, deaths, assists) over time throughout matches.  Results are cached for **1 hour** based on the unique combination of query parameters provided.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="resolution">Resolution for relative game times in percent (0-100). **Default:** 10 (buckets of 10%). Set to **0** to use absolute game time (seconds). (optional, default to 10)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerPerformanceCurveApiResponse"/>&gt;</returns>
        Task<IPlayerPerformanceCurveApiResponse> PlayerPerformanceCurveAsync(Option<int?> resolution = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<string?> heroIds = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Player Performance Curve
        /// </summary>
        /// <remarks>
        ///  Retrieves player performance statistics (net worth, kills, deaths, assists) over time throughout matches.  Results are cached for **1 hour** based on the unique combination of query parameters provided.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="resolution">Resolution for relative game times in percent (0-100). **Default:** 10 (buckets of 10%). Set to **0** to use absolute game time (seconds). (optional, default to 10)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerPerformanceCurveApiResponse"/>?&gt;</returns>
        Task<IPlayerPerformanceCurveApiResponse?> PlayerPerformanceCurveOrDefaultAsync(Option<int?> resolution = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<string?> heroIds = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Player Scoreboard
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">The field to sort by.</param>
        /// <param name="sortDirection">The direction to sort players in. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="start">The offset to start fetching players from. (optional)</param>
        /// <param name="limit">The maximum number of players to fetch. (optional, default to 100)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerScoreboardApiResponse"/>&gt;</returns>
        Task<IPlayerScoreboardApiResponse> PlayerScoreboardAsync(string sortBy, Option<string> sortDirection = default, Option<string?> gameMode = default, Option<int?> heroId = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> start = default, Option<int?> limit = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Player Scoreboard
        /// </summary>
        /// <remarks>
        ///  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="sortBy">The field to sort by.</param>
        /// <param name="sortDirection">The direction to sort players in. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="start">The offset to start fetching players from. (optional)</param>
        /// <param name="limit">The maximum number of players to fetch. (optional, default to 100)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerScoreboardApiResponse"/>?&gt;</returns>
        Task<IPlayerScoreboardApiResponse?> PlayerScoreboardOrDefaultAsync(string sortBy, Option<string> sortDirection = default, Option<string?> gameMode = default, Option<int?> heroId = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> start = default, Option<int?> limit = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Player Stats Metrics
        /// </summary>
        /// <remarks>
        ///  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  &gt; Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatches">The maximum number of matches to analyze. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerStatsMetricsApiResponse"/>&gt;</returns>
        Task<IPlayerStatsMetricsApiResponse> PlayerStatsMetricsAsync(Option<string?> heroIds = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> maxMatches = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Player Stats Metrics
        /// </summary>
        /// <remarks>
        ///  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  &gt; Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </remarks>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatches">The maximum number of matches to analyze. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerStatsMetricsApiResponse"/>?&gt;</returns>
        Task<IPlayerStatsMetricsApiResponse?> PlayerStatsMetricsOrDefaultAsync(Option<string?> heroIds = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> maxMatches = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IAbilityOrderStatsApiResponse"/>
    /// </summary>
    public interface IAbilityOrderStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<AnalyticsAbilityOrderStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IBadgeDistributionApiResponse"/>
    /// </summary>
    public interface IBadgeDistributionApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<BadgeDistribution>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IBuildItemStatsApiResponse"/>
    /// </summary>
    public interface IBuildItemStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<BuildItemStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IHeroCombStatsApiResponse"/>
    /// </summary>
    public interface IHeroCombStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<HeroCombStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IHeroCountersStatsApiResponse"/>
    /// </summary>
    public interface IHeroCountersStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<HeroCounterStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IHeroScoreboardApiResponse"/>
    /// </summary>
    public interface IHeroScoreboardApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<Entry>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IHeroStatsApiResponse"/>
    /// </summary>
    public interface IHeroStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<AnalyticsHeroStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IHeroSynergiesStatsApiResponse"/>
    /// </summary>
    public interface IHeroSynergiesStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<HeroSynergyStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IItemPermutationStatsApiResponse"/>
    /// </summary>
    public interface IItemPermutationStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<ItemPermutationStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IItemStatsApiResponse"/>
    /// </summary>
    public interface IItemStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<ItemStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IKillDeathStatsApiResponse"/>
    /// </summary>
    public interface IKillDeathStatsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<KillDeathStats>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPlayerPerformanceCurveApiResponse"/>
    /// </summary>
    public interface IPlayerPerformanceCurveApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<PlayerPerformanceCurvePoint>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPlayerScoreboardApiResponse"/>
    /// </summary>
    public interface IPlayerScoreboardApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<List<Entry>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IPlayerStatsMetricsApiResponse"/>
    /// </summary>
    public interface IPlayerStatsMetricsApiResponse : DeadlockApiClient.Client.IApiResponse, IOk<Dictionary<string, HashMapValue>?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class AnalyticsApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnAbilityOrderStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorAbilityOrderStats;

        internal void ExecuteOnAbilityOrderStats(AnalyticsApi.AbilityOrderStatsApiResponse apiResponse)
        {
            OnAbilityOrderStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorAbilityOrderStats(Exception exception)
        {
            OnErrorAbilityOrderStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnBadgeDistribution;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorBadgeDistribution;

        internal void ExecuteOnBadgeDistribution(AnalyticsApi.BadgeDistributionApiResponse apiResponse)
        {
            OnBadgeDistribution?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBadgeDistribution(Exception exception)
        {
            OnErrorBadgeDistribution?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnBuildItemStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorBuildItemStats;

        internal void ExecuteOnBuildItemStats(AnalyticsApi.BuildItemStatsApiResponse apiResponse)
        {
            OnBuildItemStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorBuildItemStats(Exception exception)
        {
            OnErrorBuildItemStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnHeroCombStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorHeroCombStats;

        internal void ExecuteOnHeroCombStats(AnalyticsApi.HeroCombStatsApiResponse apiResponse)
        {
            OnHeroCombStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorHeroCombStats(Exception exception)
        {
            OnErrorHeroCombStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnHeroCountersStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorHeroCountersStats;

        internal void ExecuteOnHeroCountersStats(AnalyticsApi.HeroCountersStatsApiResponse apiResponse)
        {
            OnHeroCountersStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorHeroCountersStats(Exception exception)
        {
            OnErrorHeroCountersStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnHeroScoreboard;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorHeroScoreboard;

        internal void ExecuteOnHeroScoreboard(AnalyticsApi.HeroScoreboardApiResponse apiResponse)
        {
            OnHeroScoreboard?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorHeroScoreboard(Exception exception)
        {
            OnErrorHeroScoreboard?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnHeroStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorHeroStats;

        internal void ExecuteOnHeroStats(AnalyticsApi.HeroStatsApiResponse apiResponse)
        {
            OnHeroStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorHeroStats(Exception exception)
        {
            OnErrorHeroStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnHeroSynergiesStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorHeroSynergiesStats;

        internal void ExecuteOnHeroSynergiesStats(AnalyticsApi.HeroSynergiesStatsApiResponse apiResponse)
        {
            OnHeroSynergiesStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorHeroSynergiesStats(Exception exception)
        {
            OnErrorHeroSynergiesStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnItemPermutationStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorItemPermutationStats;

        internal void ExecuteOnItemPermutationStats(AnalyticsApi.ItemPermutationStatsApiResponse apiResponse)
        {
            OnItemPermutationStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorItemPermutationStats(Exception exception)
        {
            OnErrorItemPermutationStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnItemStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorItemStats;

        internal void ExecuteOnItemStats(AnalyticsApi.ItemStatsApiResponse apiResponse)
        {
            OnItemStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorItemStats(Exception exception)
        {
            OnErrorItemStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnKillDeathStats;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorKillDeathStats;

        internal void ExecuteOnKillDeathStats(AnalyticsApi.KillDeathStatsApiResponse apiResponse)
        {
            OnKillDeathStats?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorKillDeathStats(Exception exception)
        {
            OnErrorKillDeathStats?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPlayerPerformanceCurve;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPlayerPerformanceCurve;

        internal void ExecuteOnPlayerPerformanceCurve(AnalyticsApi.PlayerPerformanceCurveApiResponse apiResponse)
        {
            OnPlayerPerformanceCurve?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPlayerPerformanceCurve(Exception exception)
        {
            OnErrorPlayerPerformanceCurve?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPlayerScoreboard;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPlayerScoreboard;

        internal void ExecuteOnPlayerScoreboard(AnalyticsApi.PlayerScoreboardApiResponse apiResponse)
        {
            OnPlayerScoreboard?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPlayerScoreboard(Exception exception)
        {
            OnErrorPlayerScoreboard?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnPlayerStatsMetrics;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorPlayerStatsMetrics;

        internal void ExecuteOnPlayerStatsMetrics(AnalyticsApi.PlayerStatsMetricsApiResponse apiResponse)
        {
            OnPlayerStatsMetrics?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorPlayerStatsMetrics(Exception exception)
        {
            OnErrorPlayerStatsMetrics?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class AnalyticsApi : IAnalyticsApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<AnalyticsApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public AnalyticsApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="ApiKeyProvider"/>
        /// </summary>
        public TokenProvider<ApiKeyToken> ApiKeyProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="AnalyticsApi"/> class.
        /// </summary>
        /// <returns></returns>
        public AnalyticsApi(ILogger<AnalyticsApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, AnalyticsApiEvents analyticsApiEvents,
            TokenProvider<ApiKeyToken> apiKeyProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<AnalyticsApi>();
            HttpClient = httpClient;
            Events = analyticsApiEvents;
            ApiKeyProvider = apiKeyProvider;
        }

        partial void FormatAbilityOrderStats(ref int heroId, ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minAbilityUpgrades, ref Option<long?> maxAbilityUpgrades, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<int?> minMatches, ref Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minAbilityUpgrades"></param>
        /// <param name="maxAbilityUpgrades"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void AfterAbilityOrderStatsDefaultImplementation(IAbilityOrderStatsApiResponse apiResponseLocalVar, int heroId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minAbilityUpgrades, Option<long?> maxAbilityUpgrades, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> minMatches, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterAbilityOrderStats(ref suppressDefaultLog, apiResponseLocalVar, heroId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAbilityUpgrades, maxAbilityUpgrades, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatches, accountId, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minAbilityUpgrades"></param>
        /// <param name="maxAbilityUpgrades"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void AfterAbilityOrderStats(ref bool suppressDefaultLog, IAbilityOrderStatsApiResponse apiResponseLocalVar, int heroId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minAbilityUpgrades, Option<long?> maxAbilityUpgrades, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> minMatches, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minAbilityUpgrades"></param>
        /// <param name="maxAbilityUpgrades"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void OnErrorAbilityOrderStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int heroId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minAbilityUpgrades, Option<long?> maxAbilityUpgrades, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> minMatches, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorAbilityOrderStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, heroId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAbilityUpgrades, maxAbilityUpgrades, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatches, accountId, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minAbilityUpgrades"></param>
        /// <param name="maxAbilityUpgrades"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorAbilityOrderStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, int heroId, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minAbilityUpgrades, Option<long?> maxAbilityUpgrades, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> minMatches, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Ability Order Stats  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="heroId">See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minAbilityUpgrades">Filter players based on their minimum number of ability upgrades over the whole match. (optional)</param>
        /// <param name="maxAbilityUpgrades">Filter players based on their maximum number of ability upgrades over the whole match. (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAbilityOrderStatsApiResponse"/>&gt;</returns>
        public async Task<IAbilityOrderStatsApiResponse?> AbilityOrderStatsOrDefaultAsync(int heroId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minAbilityUpgrades = default, Option<long?> maxAbilityUpgrades = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> minMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await AbilityOrderStatsAsync(heroId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAbilityUpgrades, maxAbilityUpgrades, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatches, accountId, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Ability Order Stats  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="heroId">See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minAbilityUpgrades">Filter players based on their minimum number of ability upgrades over the whole match. (optional)</param>
        /// <param name="maxAbilityUpgrades">Filter players based on their maximum number of ability upgrades over the whole match. (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IAbilityOrderStatsApiResponse"/>&gt;</returns>
        public async Task<IAbilityOrderStatsApiResponse> AbilityOrderStatsAsync(int heroId, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minAbilityUpgrades = default, Option<long?> maxAbilityUpgrades = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> minMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatAbilityOrderStats(ref heroId, ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minAbilityUpgrades, ref maxAbilityUpgrades, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref minMatches, ref accountId, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/ability-order-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/ability-order-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["hero_id"] = ClientUtils.ParameterToString(heroId);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minAbilityUpgrades.IsSet)
                        parseQueryStringLocalVar["min_ability_upgrades"] = ClientUtils.ParameterToString(minAbilityUpgrades.Value);

                    if (maxAbilityUpgrades.IsSet)
                        parseQueryStringLocalVar["max_ability_upgrades"] = ClientUtils.ParameterToString(maxAbilityUpgrades.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (minMatches.IsSet)
                        parseQueryStringLocalVar["min_matches"] = ClientUtils.ParameterToString(minMatches.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["account_id"] = ClientUtils.ParameterToString(accountId.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<AbilityOrderStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<AbilityOrderStatsApiResponse>();
                        AbilityOrderStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/ability-order-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterAbilityOrderStatsDefaultImplementation(apiResponseLocalVar, heroId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAbilityUpgrades, maxAbilityUpgrades, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatches, accountId, accountIds);

                        Events.ExecuteOnAbilityOrderStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorAbilityOrderStatsDefaultImplementation(e, "/v1/analytics/ability-order-stats", uriBuilderLocalVar.Path, heroId, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAbilityUpgrades, maxAbilityUpgrades, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatches, accountId, accountIds);
                Events.ExecuteOnErrorAbilityOrderStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="AbilityOrderStatsApiResponse"/>
        /// </summary>
        public partial class AbilityOrderStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IAbilityOrderStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<AbilityOrderStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="AbilityOrderStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AbilityOrderStatsApiResponse(ILogger<AbilityOrderStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="AbilityOrderStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public AbilityOrderStatsApiResponse(ILogger<AbilityOrderStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<AnalyticsAbilityOrderStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<AnalyticsAbilityOrderStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<AnalyticsAbilityOrderStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBadgeDistribution(ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<bool?> isHighSkillRangeParties, ref Option<bool?> isLowPriPool, ref Option<bool?> isNewPlayerPool, ref Option<long?> minMatchId, ref Option<long?> maxMatchId);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void AfterBadgeDistributionDefaultImplementation(IBadgeDistributionApiResponse apiResponseLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLog = false;
            AfterBadgeDistribution(ref suppressDefaultLog, apiResponseLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void AfterBadgeDistribution(ref bool suppressDefaultLog, IBadgeDistributionApiResponse apiResponseLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        private void OnErrorBadgeDistributionDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorBadgeDistribution(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        partial void OnErrorBadgeDistribution(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId);

        /// <summary>
        /// Badge Distribution  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBadgeDistributionApiResponse"/>&gt;</returns>
        public async Task<IBadgeDistributionApiResponse?> BadgeDistributionOrDefaultAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BadgeDistributionAsync(gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Badge Distribution  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBadgeDistributionApiResponse"/>&gt;</returns>
        public async Task<IBadgeDistributionApiResponse> BadgeDistributionAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatBadgeDistribution(ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref isHighSkillRangeParties, ref isLowPriPool, ref isNewPlayerPool, ref minMatchId, ref maxMatchId);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/badge-distribution"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/badge-distribution");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (isHighSkillRangeParties.IsSet)
                        parseQueryStringLocalVar["is_high_skill_range_parties"] = ClientUtils.ParameterToString(isHighSkillRangeParties.Value);

                    if (isLowPriPool.IsSet)
                        parseQueryStringLocalVar["is_low_pri_pool"] = ClientUtils.ParameterToString(isLowPriPool.Value);

                    if (isNewPlayerPool.IsSet)
                        parseQueryStringLocalVar["is_new_player_pool"] = ClientUtils.ParameterToString(isNewPlayerPool.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<BadgeDistributionApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BadgeDistributionApiResponse>();
                        BadgeDistributionApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/badge-distribution", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterBadgeDistributionDefaultImplementation(apiResponseLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);

                        Events.ExecuteOnBadgeDistribution(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBadgeDistributionDefaultImplementation(e, "/v1/analytics/badge-distribution", uriBuilderLocalVar.Path, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId);
                Events.ExecuteOnErrorBadgeDistribution(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BadgeDistributionApiResponse"/>
        /// </summary>
        public partial class BadgeDistributionApiResponse : DeadlockApiClient.Client.ApiResponse, IBadgeDistributionApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BadgeDistributionApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BadgeDistributionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BadgeDistributionApiResponse(ILogger<BadgeDistributionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="BadgeDistributionApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BadgeDistributionApiResponse(ILogger<BadgeDistributionApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<BadgeDistribution>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<BadgeDistribution>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<BadgeDistribution>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatBuildItemStats(ref Option<int?> heroId, ref Option<long?> minLastUpdatedUnixTimestamp, ref Option<long?> maxLastUpdatedUnixTimestamp);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="minLastUpdatedUnixTimestamp"></param>
        /// <param name="maxLastUpdatedUnixTimestamp"></param>
        private void AfterBuildItemStatsDefaultImplementation(IBuildItemStatsApiResponse apiResponseLocalVar, Option<int?> heroId, Option<long?> minLastUpdatedUnixTimestamp, Option<long?> maxLastUpdatedUnixTimestamp)
        {
            bool suppressDefaultLog = false;
            AfterBuildItemStats(ref suppressDefaultLog, apiResponseLocalVar, heroId, minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="minLastUpdatedUnixTimestamp"></param>
        /// <param name="maxLastUpdatedUnixTimestamp"></param>
        partial void AfterBuildItemStats(ref bool suppressDefaultLog, IBuildItemStatsApiResponse apiResponseLocalVar, Option<int?> heroId, Option<long?> minLastUpdatedUnixTimestamp, Option<long?> maxLastUpdatedUnixTimestamp);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="minLastUpdatedUnixTimestamp"></param>
        /// <param name="maxLastUpdatedUnixTimestamp"></param>
        private void OnErrorBuildItemStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> heroId, Option<long?> minLastUpdatedUnixTimestamp, Option<long?> maxLastUpdatedUnixTimestamp)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorBuildItemStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, heroId, minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="heroId"></param>
        /// <param name="minLastUpdatedUnixTimestamp"></param>
        /// <param name="maxLastUpdatedUnixTimestamp"></param>
        partial void OnErrorBuildItemStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> heroId, Option<long?> minLastUpdatedUnixTimestamp, Option<long?> maxLastUpdatedUnixTimestamp);

        /// <summary>
        /// Build Item Stats  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="heroId">Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minLastUpdatedUnixTimestamp">Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxLastUpdatedUnixTimestamp">Filter builds based on their last updated time (Unix timestamp). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBuildItemStatsApiResponse"/>&gt;</returns>
        public async Task<IBuildItemStatsApiResponse?> BuildItemStatsOrDefaultAsync(Option<int?> heroId = default, Option<long?> minLastUpdatedUnixTimestamp = default, Option<long?> maxLastUpdatedUnixTimestamp = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await BuildItemStatsAsync(heroId, minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Build Item Stats  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="heroId">Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minLastUpdatedUnixTimestamp">Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxLastUpdatedUnixTimestamp">Filter builds based on their last updated time (Unix timestamp). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IBuildItemStatsApiResponse"/>&gt;</returns>
        public async Task<IBuildItemStatsApiResponse> BuildItemStatsAsync(Option<int?> heroId = default, Option<long?> minLastUpdatedUnixTimestamp = default, Option<long?> maxLastUpdatedUnixTimestamp = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatBuildItemStats(ref heroId, ref minLastUpdatedUnixTimestamp, ref maxLastUpdatedUnixTimestamp);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/build-item-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/build-item-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (heroId.IsSet)
                        parseQueryStringLocalVar["hero_id"] = ClientUtils.ParameterToString(heroId.Value);

                    if (minLastUpdatedUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_last_updated_unix_timestamp"] = ClientUtils.ParameterToString(minLastUpdatedUnixTimestamp.Value);

                    if (maxLastUpdatedUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_last_updated_unix_timestamp"] = ClientUtils.ParameterToString(maxLastUpdatedUnixTimestamp.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<BuildItemStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<BuildItemStatsApiResponse>();
                        BuildItemStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/build-item-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterBuildItemStatsDefaultImplementation(apiResponseLocalVar, heroId, minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp);

                        Events.ExecuteOnBuildItemStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorBuildItemStatsDefaultImplementation(e, "/v1/analytics/build-item-stats", uriBuilderLocalVar.Path, heroId, minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp);
                Events.ExecuteOnErrorBuildItemStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="BuildItemStatsApiResponse"/>
        /// </summary>
        public partial class BuildItemStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IBuildItemStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<BuildItemStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="BuildItemStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BuildItemStatsApiResponse(ILogger<BuildItemStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="BuildItemStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public BuildItemStatsApiResponse(ILogger<BuildItemStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<BuildItemStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<BuildItemStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<BuildItemStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatHeroCombStats(ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, Option<List<int>?> includeHeroIds, Option<List<int>?> excludeHeroIds, ref Option<int?> minMatches, ref Option<int?> maxMatches, ref Option<int?> combSize, ref Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="includeHeroIds"></param>
        /// <param name="excludeHeroIds"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="combSize"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void AfterHeroCombStatsDefaultImplementation(IHeroCombStatsApiResponse apiResponseLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<List<int>?> includeHeroIds, Option<List<int>?> excludeHeroIds, Option<int?> minMatches, Option<int?> maxMatches, Option<int?> combSize, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterHeroCombStats(ref suppressDefaultLog, apiResponseLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeHeroIds, excludeHeroIds, minMatches, maxMatches, combSize, accountId, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="includeHeroIds"></param>
        /// <param name="excludeHeroIds"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="combSize"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void AfterHeroCombStats(ref bool suppressDefaultLog, IHeroCombStatsApiResponse apiResponseLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<List<int>?> includeHeroIds, Option<List<int>?> excludeHeroIds, Option<int?> minMatches, Option<int?> maxMatches, Option<int?> combSize, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="includeHeroIds"></param>
        /// <param name="excludeHeroIds"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="combSize"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void OnErrorHeroCombStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<List<int>?> includeHeroIds, Option<List<int>?> excludeHeroIds, Option<int?> minMatches, Option<int?> maxMatches, Option<int?> combSize, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorHeroCombStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeHeroIds, excludeHeroIds, minMatches, maxMatches, combSize, accountId, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="includeHeroIds"></param>
        /// <param name="excludeHeroIds"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="combSize"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorHeroCombStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<List<int>?> includeHeroIds, Option<List<int>?> excludeHeroIds, Option<int?> minMatches, Option<int?> maxMatches, Option<int?> combSize, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Hero Comb Stats  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="includeHeroIds">Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="excludeHeroIds">Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="combSize">The combination size to return. (optional, default to 6)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroCombStatsApiResponse"/>&gt;</returns>
        public async Task<IHeroCombStatsApiResponse?> HeroCombStatsOrDefaultAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<List<int>?> includeHeroIds = default, Option<List<int>?> excludeHeroIds = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<int?> combSize = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await HeroCombStatsAsync(gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeHeroIds, excludeHeroIds, minMatches, maxMatches, combSize, accountId, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Hero Comb Stats  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="includeHeroIds">Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="excludeHeroIds">Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="combSize">The combination size to return. (optional, default to 6)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroCombStatsApiResponse"/>&gt;</returns>
        public async Task<IHeroCombStatsApiResponse> HeroCombStatsAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<List<int>?> includeHeroIds = default, Option<List<int>?> excludeHeroIds = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<int?> combSize = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatHeroCombStats(ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, includeHeroIds, excludeHeroIds, ref minMatches, ref maxMatches, ref combSize, ref accountId, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/hero-comb-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/hero-comb-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (includeHeroIds.IsSet)
                        parseQueryStringLocalVar["include_hero_ids"] = ClientUtils.ParameterToString(includeHeroIds.Value);

                    if (excludeHeroIds.IsSet)
                        parseQueryStringLocalVar["exclude_hero_ids"] = ClientUtils.ParameterToString(excludeHeroIds.Value);

                    if (minMatches.IsSet)
                        parseQueryStringLocalVar["min_matches"] = ClientUtils.ParameterToString(minMatches.Value);

                    if (maxMatches.IsSet)
                        parseQueryStringLocalVar["max_matches"] = ClientUtils.ParameterToString(maxMatches.Value);

                    if (combSize.IsSet)
                        parseQueryStringLocalVar["comb_size"] = ClientUtils.ParameterToString(combSize.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["account_id"] = ClientUtils.ParameterToString(accountId.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<HeroCombStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<HeroCombStatsApiResponse>();
                        HeroCombStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/hero-comb-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterHeroCombStatsDefaultImplementation(apiResponseLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeHeroIds, excludeHeroIds, minMatches, maxMatches, combSize, accountId, accountIds);

                        Events.ExecuteOnHeroCombStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorHeroCombStatsDefaultImplementation(e, "/v1/analytics/hero-comb-stats", uriBuilderLocalVar.Path, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeHeroIds, excludeHeroIds, minMatches, maxMatches, combSize, accountId, accountIds);
                Events.ExecuteOnErrorHeroCombStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="HeroCombStatsApiResponse"/>
        /// </summary>
        public partial class HeroCombStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IHeroCombStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<HeroCombStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="HeroCombStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroCombStatsApiResponse(ILogger<HeroCombStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="HeroCombStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroCombStatsApiResponse(ILogger<HeroCombStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<HeroCombStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<HeroCombStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<HeroCombStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatHeroCountersStats(ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<long?> minEnemyNetworth, ref Option<long?> maxEnemyNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<bool?> sameLaneFilter, ref Option<long?> minMatches, ref Option<int?> maxMatches, ref Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minEnemyNetworth"></param>
        /// <param name="maxEnemyNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="sameLaneFilter"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void AfterHeroCountersStatsDefaultImplementation(IHeroCountersStatsApiResponse apiResponseLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<long?> minEnemyNetworth, Option<long?> maxEnemyNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> sameLaneFilter, Option<long?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterHeroCountersStats(ref suppressDefaultLog, apiResponseLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minEnemyNetworth, maxEnemyNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, minMatches, maxMatches, accountId, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minEnemyNetworth"></param>
        /// <param name="maxEnemyNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="sameLaneFilter"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void AfterHeroCountersStats(ref bool suppressDefaultLog, IHeroCountersStatsApiResponse apiResponseLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<long?> minEnemyNetworth, Option<long?> maxEnemyNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> sameLaneFilter, Option<long?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minEnemyNetworth"></param>
        /// <param name="maxEnemyNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="sameLaneFilter"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void OnErrorHeroCountersStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<long?> minEnemyNetworth, Option<long?> maxEnemyNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> sameLaneFilter, Option<long?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorHeroCountersStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minEnemyNetworth, maxEnemyNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, minMatches, maxMatches, accountId, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minEnemyNetworth"></param>
        /// <param name="maxEnemyNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="sameLaneFilter"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorHeroCountersStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<long?> minEnemyNetworth, Option<long?> maxEnemyNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> sameLaneFilter, Option<long?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Hero Counter Stats  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (&#x60;hero_id&#x60;) wins against an enemy hero (&#x60;enemy_hero_id&#x60;) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minEnemyNetworth">Filter enemy players based on their net worth. (optional)</param>
        /// <param name="maxEnemyNetworth">Filter enemy players based on their net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="sameLaneFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroCountersStatsApiResponse"/>&gt;</returns>
        public async Task<IHeroCountersStatsApiResponse?> HeroCountersStatsOrDefaultAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<long?> minEnemyNetworth = default, Option<long?> maxEnemyNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> sameLaneFilter = default, Option<long?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await HeroCountersStatsAsync(gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minEnemyNetworth, maxEnemyNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, minMatches, maxMatches, accountId, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Hero Counter Stats  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (&#x60;hero_id&#x60;) wins against an enemy hero (&#x60;enemy_hero_id&#x60;) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minEnemyNetworth">Filter enemy players based on their net worth. (optional)</param>
        /// <param name="maxEnemyNetworth">Filter enemy players based on their net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="sameLaneFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroCountersStatsApiResponse"/>&gt;</returns>
        public async Task<IHeroCountersStatsApiResponse> HeroCountersStatsAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<long?> minEnemyNetworth = default, Option<long?> maxEnemyNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> sameLaneFilter = default, Option<long?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatHeroCountersStats(ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minEnemyNetworth, ref maxEnemyNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref sameLaneFilter, ref minMatches, ref maxMatches, ref accountId, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/hero-counter-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/hero-counter-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minEnemyNetworth.IsSet)
                        parseQueryStringLocalVar["min_enemy_networth"] = ClientUtils.ParameterToString(minEnemyNetworth.Value);

                    if (maxEnemyNetworth.IsSet)
                        parseQueryStringLocalVar["max_enemy_networth"] = ClientUtils.ParameterToString(maxEnemyNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (sameLaneFilter.IsSet)
                        parseQueryStringLocalVar["same_lane_filter"] = ClientUtils.ParameterToString(sameLaneFilter.Value);

                    if (minMatches.IsSet)
                        parseQueryStringLocalVar["min_matches"] = ClientUtils.ParameterToString(minMatches.Value);

                    if (maxMatches.IsSet)
                        parseQueryStringLocalVar["max_matches"] = ClientUtils.ParameterToString(maxMatches.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["account_id"] = ClientUtils.ParameterToString(accountId.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<HeroCountersStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<HeroCountersStatsApiResponse>();
                        HeroCountersStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/hero-counter-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterHeroCountersStatsDefaultImplementation(apiResponseLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minEnemyNetworth, maxEnemyNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, minMatches, maxMatches, accountId, accountIds);

                        Events.ExecuteOnHeroCountersStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorHeroCountersStatsDefaultImplementation(e, "/v1/analytics/hero-counter-stats", uriBuilderLocalVar.Path, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minEnemyNetworth, maxEnemyNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, minMatches, maxMatches, accountId, accountIds);
                Events.ExecuteOnErrorHeroCountersStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="HeroCountersStatsApiResponse"/>
        /// </summary>
        public partial class HeroCountersStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IHeroCountersStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<HeroCountersStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="HeroCountersStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroCountersStatsApiResponse(ILogger<HeroCountersStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="HeroCountersStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroCountersStatsApiResponse(ILogger<HeroCountersStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<HeroCounterStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<HeroCounterStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<HeroCounterStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatHeroScoreboard(ref string sortBy, ref Option<string> sortDirection, ref Option<string?> gameMode, ref Option<int?> minMatches, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <returns></returns>
        private void ValidateHeroScoreboard(string sortBy, Option<string> sortDirection)
        {
            if (sortBy == null)
                throw new ArgumentNullException(nameof(sortBy));

            if (sortDirection.IsSet && sortDirection.Value == null)
                throw new ArgumentNullException(nameof(sortDirection));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <param name="gameMode"></param>
        /// <param name="minMatches"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void AfterHeroScoreboardDefaultImplementation(IHeroScoreboardApiResponse apiResponseLocalVar, string sortBy, Option<string> sortDirection, Option<string?> gameMode, Option<int?> minMatches, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterHeroScoreboard(ref suppressDefaultLog, apiResponseLocalVar, sortBy, sortDirection, gameMode, minMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <param name="gameMode"></param>
        /// <param name="minMatches"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void AfterHeroScoreboard(ref bool suppressDefaultLog, IHeroScoreboardApiResponse apiResponseLocalVar, string sortBy, Option<string> sortDirection, Option<string?> gameMode, Option<int?> minMatches, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <param name="gameMode"></param>
        /// <param name="minMatches"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void OnErrorHeroScoreboardDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string sortBy, Option<string> sortDirection, Option<string?> gameMode, Option<int?> minMatches, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorHeroScoreboard(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, sortBy, sortDirection, gameMode, minMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <param name="gameMode"></param>
        /// <param name="minMatches"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorHeroScoreboard(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string sortBy, Option<string> sortDirection, Option<string?> gameMode, Option<int?> minMatches, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Hero Scoreboard  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="sortBy">The field to sort by.</param>
        /// <param name="sortDirection">The direction to sort heroes in. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minMatches">Filter by min number of matches played. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroScoreboardApiResponse"/>&gt;</returns>
        public async Task<IHeroScoreboardApiResponse?> HeroScoreboardOrDefaultAsync(string sortBy, Option<string> sortDirection = default, Option<string?> gameMode = default, Option<int?> minMatches = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await HeroScoreboardAsync(sortBy, sortDirection, gameMode, minMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Hero Scoreboard  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">The field to sort by.</param>
        /// <param name="sortDirection">The direction to sort heroes in. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minMatches">Filter by min number of matches played. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroScoreboardApiResponse"/>&gt;</returns>
        public async Task<IHeroScoreboardApiResponse> HeroScoreboardAsync(string sortBy, Option<string> sortDirection = default, Option<string?> gameMode = default, Option<int?> minMatches = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateHeroScoreboard(sortBy, sortDirection);

                FormatHeroScoreboard(ref sortBy, ref sortDirection, ref gameMode, ref minMatches, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref accountId, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/scoreboards/heroes"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/scoreboards/heroes");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["sort_by"] = ClientUtils.ParameterToString(sortBy);

                    if (sortDirection.IsSet)
                        parseQueryStringLocalVar["sort_direction"] = ClientUtils.ParameterToString(sortDirection.Value);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minMatches.IsSet)
                        parseQueryStringLocalVar["min_matches"] = ClientUtils.ParameterToString(minMatches.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["account_id"] = ClientUtils.ParameterToString(accountId.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<HeroScoreboardApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<HeroScoreboardApiResponse>();
                        HeroScoreboardApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/scoreboards/heroes", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterHeroScoreboardDefaultImplementation(apiResponseLocalVar, sortBy, sortDirection, gameMode, minMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds);

                        Events.ExecuteOnHeroScoreboard(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorHeroScoreboardDefaultImplementation(e, "/v1/analytics/scoreboards/heroes", uriBuilderLocalVar.Path, sortBy, sortDirection, gameMode, minMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds);
                Events.ExecuteOnErrorHeroScoreboard(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="HeroScoreboardApiResponse"/>
        /// </summary>
        public partial class HeroScoreboardApiResponse : DeadlockApiClient.Client.ApiResponse, IHeroScoreboardApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<HeroScoreboardApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="HeroScoreboardApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroScoreboardApiResponse(ILogger<HeroScoreboardApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="HeroScoreboardApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroScoreboardApiResponse(ILogger<HeroScoreboardApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Entry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Entry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Entry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatHeroStats(ref Option<string> bucket, ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<long?> minHeroMatches, ref Option<long?> maxHeroMatches, ref Option<long?> minHeroMatchesTotal, ref Option<long?> maxHeroMatchesTotal, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, ref Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucket"></param>
        /// <returns></returns>
        private void ValidateHeroStats(Option<string> bucket)
        {
            if (bucket.IsSet && bucket.Value == null)
                throw new ArgumentNullException(nameof(bucket));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="bucket"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minHeroMatches"></param>
        /// <param name="maxHeroMatches"></param>
        /// <param name="minHeroMatchesTotal"></param>
        /// <param name="maxHeroMatchesTotal"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void AfterHeroStatsDefaultImplementation(IHeroStatsApiResponse apiResponseLocalVar, Option<string> bucket, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minHeroMatches, Option<long?> maxHeroMatches, Option<long?> minHeroMatchesTotal, Option<long?> maxHeroMatchesTotal, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterHeroStats(ref suppressDefaultLog, apiResponseLocalVar, bucket, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minHeroMatches, maxHeroMatches, minHeroMatchesTotal, maxHeroMatchesTotal, includeItemIds, excludeItemIds, accountId, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="bucket"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minHeroMatches"></param>
        /// <param name="maxHeroMatches"></param>
        /// <param name="minHeroMatchesTotal"></param>
        /// <param name="maxHeroMatchesTotal"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void AfterHeroStats(ref bool suppressDefaultLog, IHeroStatsApiResponse apiResponseLocalVar, Option<string> bucket, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minHeroMatches, Option<long?> maxHeroMatches, Option<long?> minHeroMatchesTotal, Option<long?> maxHeroMatchesTotal, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="bucket"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minHeroMatches"></param>
        /// <param name="maxHeroMatches"></param>
        /// <param name="minHeroMatchesTotal"></param>
        /// <param name="maxHeroMatchesTotal"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void OnErrorHeroStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> bucket, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minHeroMatches, Option<long?> maxHeroMatches, Option<long?> minHeroMatchesTotal, Option<long?> maxHeroMatchesTotal, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorHeroStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, bucket, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minHeroMatches, maxHeroMatches, minHeroMatchesTotal, maxHeroMatchesTotal, includeItemIds, excludeItemIds, accountId, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="bucket"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minHeroMatches"></param>
        /// <param name="maxHeroMatches"></param>
        /// <param name="minHeroMatchesTotal"></param>
        /// <param name="maxHeroMatchesTotal"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorHeroStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> bucket, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<long?> minHeroMatches, Option<long?> maxHeroMatches, Option<long?> minHeroMatchesTotal, Option<long?> maxHeroMatchesTotal, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Hero Stats  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="bucket">Bucket allows you to group the stats by a specific field. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minHeroMatches">Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)</param>
        /// <param name="maxHeroMatches">Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)</param>
        /// <param name="minHeroMatchesTotal">Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)</param>
        /// <param name="maxHeroMatchesTotal">Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroStatsApiResponse"/>&gt;</returns>
        public async Task<IHeroStatsApiResponse?> HeroStatsOrDefaultAsync(Option<string> bucket = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minHeroMatches = default, Option<long?> maxHeroMatches = default, Option<long?> minHeroMatchesTotal = default, Option<long?> maxHeroMatchesTotal = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await HeroStatsAsync(bucket, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minHeroMatches, maxHeroMatches, minHeroMatchesTotal, maxHeroMatchesTotal, includeItemIds, excludeItemIds, accountId, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Hero Stats  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucket">Bucket allows you to group the stats by a specific field. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minHeroMatches">Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)</param>
        /// <param name="maxHeroMatches">Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)</param>
        /// <param name="minHeroMatchesTotal">Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)</param>
        /// <param name="maxHeroMatchesTotal">Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroStatsApiResponse"/>&gt;</returns>
        public async Task<IHeroStatsApiResponse> HeroStatsAsync(Option<string> bucket = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<long?> minHeroMatches = default, Option<long?> maxHeroMatches = default, Option<long?> minHeroMatchesTotal = default, Option<long?> maxHeroMatchesTotal = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateHeroStats(bucket);

                FormatHeroStats(ref bucket, ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref minHeroMatches, ref maxHeroMatches, ref minHeroMatchesTotal, ref maxHeroMatchesTotal, includeItemIds, excludeItemIds, ref accountId, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/hero-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/hero-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (bucket.IsSet)
                        parseQueryStringLocalVar["bucket"] = ClientUtils.ParameterToString(bucket.Value);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (minHeroMatches.IsSet)
                        parseQueryStringLocalVar["min_hero_matches"] = ClientUtils.ParameterToString(minHeroMatches.Value);

                    if (maxHeroMatches.IsSet)
                        parseQueryStringLocalVar["max_hero_matches"] = ClientUtils.ParameterToString(maxHeroMatches.Value);

                    if (minHeroMatchesTotal.IsSet)
                        parseQueryStringLocalVar["min_hero_matches_total"] = ClientUtils.ParameterToString(minHeroMatchesTotal.Value);

                    if (maxHeroMatchesTotal.IsSet)
                        parseQueryStringLocalVar["max_hero_matches_total"] = ClientUtils.ParameterToString(maxHeroMatchesTotal.Value);

                    if (includeItemIds.IsSet)
                        parseQueryStringLocalVar["include_item_ids"] = ClientUtils.ParameterToString(includeItemIds.Value);

                    if (excludeItemIds.IsSet)
                        parseQueryStringLocalVar["exclude_item_ids"] = ClientUtils.ParameterToString(excludeItemIds.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["account_id"] = ClientUtils.ParameterToString(accountId.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<HeroStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<HeroStatsApiResponse>();
                        HeroStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/hero-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterHeroStatsDefaultImplementation(apiResponseLocalVar, bucket, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minHeroMatches, maxHeroMatches, minHeroMatchesTotal, maxHeroMatchesTotal, includeItemIds, excludeItemIds, accountId, accountIds);

                        Events.ExecuteOnHeroStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorHeroStatsDefaultImplementation(e, "/v1/analytics/hero-stats", uriBuilderLocalVar.Path, bucket, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minHeroMatches, maxHeroMatches, minHeroMatchesTotal, maxHeroMatchesTotal, includeItemIds, excludeItemIds, accountId, accountIds);
                Events.ExecuteOnErrorHeroStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="HeroStatsApiResponse"/>
        /// </summary>
        public partial class HeroStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IHeroStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<HeroStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="HeroStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroStatsApiResponse(ILogger<HeroStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="HeroStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroStatsApiResponse(ILogger<HeroStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<AnalyticsHeroStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<AnalyticsHeroStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<AnalyticsHeroStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatHeroSynergiesStats(ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<bool?> sameLaneFilter, ref Option<bool?> samePartyFilter, ref Option<long?> minMatches, ref Option<int?> maxMatches, ref Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="sameLaneFilter"></param>
        /// <param name="samePartyFilter"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void AfterHeroSynergiesStatsDefaultImplementation(IHeroSynergiesStatsApiResponse apiResponseLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> sameLaneFilter, Option<bool?> samePartyFilter, Option<long?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterHeroSynergiesStats(ref suppressDefaultLog, apiResponseLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, samePartyFilter, minMatches, maxMatches, accountId, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="sameLaneFilter"></param>
        /// <param name="samePartyFilter"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void AfterHeroSynergiesStats(ref bool suppressDefaultLog, IHeroSynergiesStatsApiResponse apiResponseLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> sameLaneFilter, Option<bool?> samePartyFilter, Option<long?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="sameLaneFilter"></param>
        /// <param name="samePartyFilter"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void OnErrorHeroSynergiesStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> sameLaneFilter, Option<bool?> samePartyFilter, Option<long?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorHeroSynergiesStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, samePartyFilter, minMatches, maxMatches, accountId, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="sameLaneFilter"></param>
        /// <param name="samePartyFilter"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorHeroSynergiesStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<bool?> sameLaneFilter, Option<bool?> samePartyFilter, Option<long?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Hero Synergy Stats  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (&#x60;hero_id1&#x60; and &#x60;hero_id2&#x60;) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="sameLaneFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)</param>
        /// <param name="samePartyFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroSynergiesStatsApiResponse"/>&gt;</returns>
        public async Task<IHeroSynergiesStatsApiResponse?> HeroSynergiesStatsOrDefaultAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> sameLaneFilter = default, Option<bool?> samePartyFilter = default, Option<long?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await HeroSynergiesStatsAsync(gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, samePartyFilter, minMatches, maxMatches, accountId, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Hero Synergy Stats  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (&#x60;hero_id1&#x60; and &#x60;hero_id2&#x60;) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="sameLaneFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)</param>
        /// <param name="samePartyFilter">When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)</param>
        /// <param name="minMatches">The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IHeroSynergiesStatsApiResponse"/>&gt;</returns>
        public async Task<IHeroSynergiesStatsApiResponse> HeroSynergiesStatsAsync(Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<bool?> sameLaneFilter = default, Option<bool?> samePartyFilter = default, Option<long?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatHeroSynergiesStats(ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref sameLaneFilter, ref samePartyFilter, ref minMatches, ref maxMatches, ref accountId, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/hero-synergy-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/hero-synergy-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (sameLaneFilter.IsSet)
                        parseQueryStringLocalVar["same_lane_filter"] = ClientUtils.ParameterToString(sameLaneFilter.Value);

                    if (samePartyFilter.IsSet)
                        parseQueryStringLocalVar["same_party_filter"] = ClientUtils.ParameterToString(samePartyFilter.Value);

                    if (minMatches.IsSet)
                        parseQueryStringLocalVar["min_matches"] = ClientUtils.ParameterToString(minMatches.Value);

                    if (maxMatches.IsSet)
                        parseQueryStringLocalVar["max_matches"] = ClientUtils.ParameterToString(maxMatches.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["account_id"] = ClientUtils.ParameterToString(accountId.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<HeroSynergiesStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<HeroSynergiesStatsApiResponse>();
                        HeroSynergiesStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/hero-synergy-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterHeroSynergiesStatsDefaultImplementation(apiResponseLocalVar, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, samePartyFilter, minMatches, maxMatches, accountId, accountIds);

                        Events.ExecuteOnHeroSynergiesStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorHeroSynergiesStatsDefaultImplementation(e, "/v1/analytics/hero-synergy-stats", uriBuilderLocalVar.Path, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, samePartyFilter, minMatches, maxMatches, accountId, accountIds);
                Events.ExecuteOnErrorHeroSynergiesStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="HeroSynergiesStatsApiResponse"/>
        /// </summary>
        public partial class HeroSynergiesStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IHeroSynergiesStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<HeroSynergiesStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="HeroSynergiesStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroSynergiesStatsApiResponse(ILogger<HeroSynergiesStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="HeroSynergiesStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public HeroSynergiesStatsApiResponse(ILogger<HeroSynergiesStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<HeroSynergyStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<HeroSynergyStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<HeroSynergyStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatItemPermutationStats(Option<List<int>?> itemIds, ref Option<int?> combSize, ref Option<string?> gameMode, ref Option<string?> heroIds, ref Option<int?> heroId, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="itemIds"></param>
        /// <param name="combSize"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void AfterItemPermutationStatsDefaultImplementation(IItemPermutationStatsApiResponse apiResponseLocalVar, Option<List<int>?> itemIds, Option<int?> combSize, Option<string?> gameMode, Option<string?> heroIds, Option<int?> heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterItemPermutationStats(ref suppressDefaultLog, apiResponseLocalVar, itemIds, combSize, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="itemIds"></param>
        /// <param name="combSize"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void AfterItemPermutationStats(ref bool suppressDefaultLog, IItemPermutationStatsApiResponse apiResponseLocalVar, Option<List<int>?> itemIds, Option<int?> combSize, Option<string?> gameMode, Option<string?> heroIds, Option<int?> heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="itemIds"></param>
        /// <param name="combSize"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        private void OnErrorItemPermutationStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<int>?> itemIds, Option<int?> combSize, Option<string?> gameMode, Option<string?> heroIds, Option<int?> heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> accountId, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorItemPermutationStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, itemIds, combSize, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="itemIds"></param>
        /// <param name="combSize"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorItemPermutationStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<List<int>?> itemIds, Option<int?> combSize, Option<string?> gameMode, Option<string?> heroIds, Option<int?> heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> accountId, Option<List<int>?> accountIds);

        /// <summary>
        /// Item Permutation Stats  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="itemIds">Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="combSize">The combination size to return. (optional, default to 2)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IItemPermutationStatsApiResponse"/>&gt;</returns>
        public async Task<IItemPermutationStatsApiResponse?> ItemPermutationStatsOrDefaultAsync(Option<List<int>?> itemIds = default, Option<int?> combSize = default, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<int?> heroId = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ItemPermutationStatsAsync(itemIds, combSize, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Item Permutation Stats  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="itemIds">Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="combSize">The combination size to return. (optional, default to 2)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IItemPermutationStatsApiResponse"/>&gt;</returns>
        public async Task<IItemPermutationStatsApiResponse> ItemPermutationStatsAsync(Option<List<int>?> itemIds = default, Option<int?> combSize = default, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<int?> heroId = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatItemPermutationStats(itemIds, ref combSize, ref gameMode, ref heroIds, ref heroId, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref accountId, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/item-permutation-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/item-permutation-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (itemIds.IsSet)
                        parseQueryStringLocalVar["item_ids"] = ClientUtils.ParameterToString(itemIds.Value);

                    if (combSize.IsSet)
                        parseQueryStringLocalVar["comb_size"] = ClientUtils.ParameterToString(combSize.Value);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (heroIds.IsSet)
                        parseQueryStringLocalVar["hero_ids"] = ClientUtils.ParameterToString(heroIds.Value);

                    if (heroId.IsSet)
                        parseQueryStringLocalVar["hero_id"] = ClientUtils.ParameterToString(heroId.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["account_id"] = ClientUtils.ParameterToString(accountId.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ItemPermutationStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ItemPermutationStatsApiResponse>();
                        ItemPermutationStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/item-permutation-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterItemPermutationStatsDefaultImplementation(apiResponseLocalVar, itemIds, combSize, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds);

                        Events.ExecuteOnItemPermutationStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorItemPermutationStatsDefaultImplementation(e, "/v1/analytics/item-permutation-stats", uriBuilderLocalVar.Path, itemIds, combSize, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds);
                Events.ExecuteOnErrorItemPermutationStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ItemPermutationStatsApiResponse"/>
        /// </summary>
        public partial class ItemPermutationStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IItemPermutationStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ItemPermutationStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ItemPermutationStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ItemPermutationStatsApiResponse(ILogger<ItemPermutationStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ItemPermutationStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ItemPermutationStatsApiResponse(ILogger<ItemPermutationStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ItemPermutationStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ItemPermutationStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ItemPermutationStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatItemStats(ref Option<string> bucket, ref Option<string?> gameMode, ref Option<string?> heroIds, ref Option<int?> heroId, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, ref Option<int?> minMatches, ref Option<int?> maxMatches, ref Option<int?> accountId, Option<List<int>?> accountIds, ref Option<int?> minBoughtAtS, ref Option<int?> maxBoughtAtS);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="bucket"></param>
        /// <returns></returns>
        private void ValidateItemStats(Option<string> bucket)
        {
            if (bucket.IsSet && bucket.Value == null)
                throw new ArgumentNullException(nameof(bucket));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="bucket"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        /// <param name="minBoughtAtS"></param>
        /// <param name="maxBoughtAtS"></param>
        private void AfterItemStatsDefaultImplementation(IItemStatsApiResponse apiResponseLocalVar, Option<string> bucket, Option<string?> gameMode, Option<string?> heroIds, Option<int?> heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<int?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds, Option<int?> minBoughtAtS, Option<int?> maxBoughtAtS)
        {
            bool suppressDefaultLog = false;
            AfterItemStats(ref suppressDefaultLog, apiResponseLocalVar, bucket, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, minMatches, maxMatches, accountId, accountIds, minBoughtAtS, maxBoughtAtS);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="bucket"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        /// <param name="minBoughtAtS"></param>
        /// <param name="maxBoughtAtS"></param>
        partial void AfterItemStats(ref bool suppressDefaultLog, IItemStatsApiResponse apiResponseLocalVar, Option<string> bucket, Option<string?> gameMode, Option<string?> heroIds, Option<int?> heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<int?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds, Option<int?> minBoughtAtS, Option<int?> maxBoughtAtS);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="bucket"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        /// <param name="minBoughtAtS"></param>
        /// <param name="maxBoughtAtS"></param>
        private void OnErrorItemStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> bucket, Option<string?> gameMode, Option<string?> heroIds, Option<int?> heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<int?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds, Option<int?> minBoughtAtS, Option<int?> maxBoughtAtS)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorItemStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, bucket, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, minMatches, maxMatches, accountId, accountIds, minBoughtAtS, maxBoughtAtS);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="bucket"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroIds"></param>
        /// <param name="heroId"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="accountId"></param>
        /// <param name="accountIds"></param>
        /// <param name="minBoughtAtS"></param>
        /// <param name="maxBoughtAtS"></param>
        partial void OnErrorItemStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string> bucket, Option<string?> gameMode, Option<string?> heroIds, Option<int?> heroId, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<int?> minMatches, Option<int?> maxMatches, Option<int?> accountId, Option<List<int>?> accountIds, Option<int?> minBoughtAtS, Option<int?> maxBoughtAtS);

        /// <summary>
        /// Item Stats  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="bucket">Bucket allows you to group the stats by a specific field. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for an item to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="minBoughtAtS">Filter items bought after this game time (seconds). (optional)</param>
        /// <param name="maxBoughtAtS">Filter items bought before this game time (seconds). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IItemStatsApiResponse"/>&gt;</returns>
        public async Task<IItemStatsApiResponse?> ItemStatsOrDefaultAsync(Option<string> bucket = default, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<int?> heroId = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, Option<int?> minBoughtAtS = default, Option<int?> maxBoughtAtS = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await ItemStatsAsync(bucket, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, minMatches, maxMatches, accountId, accountIds, minBoughtAtS, maxBoughtAtS, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Item Stats  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="bucket">Bucket allows you to group the stats by a specific field. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for an item to be included in the response. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="accountId">Filter for matches with a specific player account ID. (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="minBoughtAtS">Filter items bought after this game time (seconds). (optional)</param>
        /// <param name="maxBoughtAtS">Filter items bought before this game time (seconds). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IItemStatsApiResponse"/>&gt;</returns>
        public async Task<IItemStatsApiResponse> ItemStatsAsync(Option<string> bucket = default, Option<string?> gameMode = default, Option<string?> heroIds = default, Option<int?> heroId = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<int?> accountId = default, Option<List<int>?> accountIds = default, Option<int?> minBoughtAtS = default, Option<int?> maxBoughtAtS = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateItemStats(bucket);

                FormatItemStats(ref bucket, ref gameMode, ref heroIds, ref heroId, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, includeItemIds, excludeItemIds, ref minMatches, ref maxMatches, ref accountId, accountIds, ref minBoughtAtS, ref maxBoughtAtS);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/item-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/item-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (bucket.IsSet)
                        parseQueryStringLocalVar["bucket"] = ClientUtils.ParameterToString(bucket.Value);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (heroIds.IsSet)
                        parseQueryStringLocalVar["hero_ids"] = ClientUtils.ParameterToString(heroIds.Value);

                    if (heroId.IsSet)
                        parseQueryStringLocalVar["hero_id"] = ClientUtils.ParameterToString(heroId.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (includeItemIds.IsSet)
                        parseQueryStringLocalVar["include_item_ids"] = ClientUtils.ParameterToString(includeItemIds.Value);

                    if (excludeItemIds.IsSet)
                        parseQueryStringLocalVar["exclude_item_ids"] = ClientUtils.ParameterToString(excludeItemIds.Value);

                    if (minMatches.IsSet)
                        parseQueryStringLocalVar["min_matches"] = ClientUtils.ParameterToString(minMatches.Value);

                    if (maxMatches.IsSet)
                        parseQueryStringLocalVar["max_matches"] = ClientUtils.ParameterToString(maxMatches.Value);

                    if (accountId.IsSet)
                        parseQueryStringLocalVar["account_id"] = ClientUtils.ParameterToString(accountId.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    if (minBoughtAtS.IsSet)
                        parseQueryStringLocalVar["min_bought_at_s"] = ClientUtils.ParameterToString(minBoughtAtS.Value);

                    if (maxBoughtAtS.IsSet)
                        parseQueryStringLocalVar["max_bought_at_s"] = ClientUtils.ParameterToString(maxBoughtAtS.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<ItemStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<ItemStatsApiResponse>();
                        ItemStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/item-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterItemStatsDefaultImplementation(apiResponseLocalVar, bucket, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, minMatches, maxMatches, accountId, accountIds, minBoughtAtS, maxBoughtAtS);

                        Events.ExecuteOnItemStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorItemStatsDefaultImplementation(e, "/v1/analytics/item-stats", uriBuilderLocalVar.Path, bucket, gameMode, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, minMatches, maxMatches, accountId, accountIds, minBoughtAtS, maxBoughtAtS);
                Events.ExecuteOnErrorItemStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="ItemStatsApiResponse"/>
        /// </summary>
        public partial class ItemStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IItemStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<ItemStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="ItemStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ItemStatsApiResponse(ILogger<ItemStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="ItemStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public ItemStatsApiResponse(ILogger<ItemStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<ItemStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<ItemStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<ItemStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatKillDeathStats(ref Option<int?> team, ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, Option<List<int>?> accountIds, ref Option<string?> heroIds, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<bool?> isHighSkillRangeParties, ref Option<bool?> isLowPriPool, ref Option<bool?> isNewPlayerPool, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<int?> minKillsPerRaster, ref Option<int?> maxKillsPerRaster, ref Option<int?> minDeathsPerRaster, ref Option<int?> maxDeathsPerRaster, ref Option<int?> minGameTimeS, ref Option<int?> maxGameTimeS);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="team"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroIds"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minKillsPerRaster"></param>
        /// <param name="maxKillsPerRaster"></param>
        /// <param name="minDeathsPerRaster"></param>
        /// <param name="maxDeathsPerRaster"></param>
        /// <param name="minGameTimeS"></param>
        /// <param name="maxGameTimeS"></param>
        private void AfterKillDeathStatsDefaultImplementation(IKillDeathStatsApiResponse apiResponseLocalVar, Option<int?> team, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<List<int>?> accountIds, Option<string?> heroIds, Option<long?> minNetworth, Option<long?> maxNetworth, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<int?> minKillsPerRaster, Option<int?> maxKillsPerRaster, Option<int?> minDeathsPerRaster, Option<int?> maxDeathsPerRaster, Option<int?> minGameTimeS, Option<int?> maxGameTimeS)
        {
            bool suppressDefaultLog = false;
            AfterKillDeathStats(ref suppressDefaultLog, apiResponseLocalVar, team, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, accountIds, heroIds, minNetworth, maxNetworth, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, minAverageBadge, maxAverageBadge, minKillsPerRaster, maxKillsPerRaster, minDeathsPerRaster, maxDeathsPerRaster, minGameTimeS, maxGameTimeS);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="team"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroIds"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minKillsPerRaster"></param>
        /// <param name="maxKillsPerRaster"></param>
        /// <param name="minDeathsPerRaster"></param>
        /// <param name="maxDeathsPerRaster"></param>
        /// <param name="minGameTimeS"></param>
        /// <param name="maxGameTimeS"></param>
        partial void AfterKillDeathStats(ref bool suppressDefaultLog, IKillDeathStatsApiResponse apiResponseLocalVar, Option<int?> team, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<List<int>?> accountIds, Option<string?> heroIds, Option<long?> minNetworth, Option<long?> maxNetworth, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<int?> minKillsPerRaster, Option<int?> maxKillsPerRaster, Option<int?> minDeathsPerRaster, Option<int?> maxDeathsPerRaster, Option<int?> minGameTimeS, Option<int?> maxGameTimeS);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="team"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroIds"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minKillsPerRaster"></param>
        /// <param name="maxKillsPerRaster"></param>
        /// <param name="minDeathsPerRaster"></param>
        /// <param name="maxDeathsPerRaster"></param>
        /// <param name="minGameTimeS"></param>
        /// <param name="maxGameTimeS"></param>
        private void OnErrorKillDeathStatsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> team, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<List<int>?> accountIds, Option<string?> heroIds, Option<long?> minNetworth, Option<long?> maxNetworth, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<int?> minKillsPerRaster, Option<int?> maxKillsPerRaster, Option<int?> minDeathsPerRaster, Option<int?> maxDeathsPerRaster, Option<int?> minGameTimeS, Option<int?> maxGameTimeS)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorKillDeathStats(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, team, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, accountIds, heroIds, minNetworth, maxNetworth, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, minAverageBadge, maxAverageBadge, minKillsPerRaster, maxKillsPerRaster, minDeathsPerRaster, maxDeathsPerRaster, minGameTimeS, maxGameTimeS);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="team"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="accountIds"></param>
        /// <param name="heroIds"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="isHighSkillRangeParties"></param>
        /// <param name="isLowPriPool"></param>
        /// <param name="isNewPlayerPool"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minKillsPerRaster"></param>
        /// <param name="maxKillsPerRaster"></param>
        /// <param name="minDeathsPerRaster"></param>
        /// <param name="maxDeathsPerRaster"></param>
        /// <param name="minGameTimeS"></param>
        /// <param name="maxGameTimeS"></param>
        partial void OnErrorKillDeathStats(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> team, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<List<int>?> accountIds, Option<string?> heroIds, Option<long?> minNetworth, Option<long?> maxNetworth, Option<bool?> isHighSkillRangeParties, Option<bool?> isLowPriPool, Option<bool?> isNewPlayerPool, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<int?> minKillsPerRaster, Option<int?> maxKillsPerRaster, Option<int?> minDeathsPerRaster, Option<int?> maxDeathsPerRaster, Option<int?> minGameTimeS, Option<int?> maxGameTimeS);

        /// <summary>
        /// Kill Death Stats  This endpoint returns the kill-death statistics across a 100x100 pixel raster.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="team">Filter by team number. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="accountIds">Filter matches by account IDs of players that participated in the match. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minKillsPerRaster">Filter Raster cells based on minimum kills. (optional)</param>
        /// <param name="maxKillsPerRaster">Filter Raster cells based on maximum kills. (optional)</param>
        /// <param name="minDeathsPerRaster">Filter Raster cells based on minimum deaths. (optional)</param>
        /// <param name="maxDeathsPerRaster">Filter Raster cells based on maximum deaths. (optional)</param>
        /// <param name="minGameTimeS">Filter kills based on their game time. (optional)</param>
        /// <param name="maxGameTimeS">Filter kills based on their game time. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKillDeathStatsApiResponse"/>&gt;</returns>
        public async Task<IKillDeathStatsApiResponse?> KillDeathStatsOrDefaultAsync(Option<int?> team = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<List<int>?> accountIds = default, Option<string?> heroIds = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<int?> minKillsPerRaster = default, Option<int?> maxKillsPerRaster = default, Option<int?> minDeathsPerRaster = default, Option<int?> maxDeathsPerRaster = default, Option<int?> minGameTimeS = default, Option<int?> maxGameTimeS = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await KillDeathStatsAsync(team, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, accountIds, heroIds, minNetworth, maxNetworth, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, minAverageBadge, maxAverageBadge, minKillsPerRaster, maxKillsPerRaster, minDeathsPerRaster, maxDeathsPerRaster, minGameTimeS, maxGameTimeS, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Kill Death Stats  This endpoint returns the kill-death statistics across a 100x100 pixel raster.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="team">Filter by team number. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="accountIds">Filter matches by account IDs of players that participated in the match. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="isHighSkillRangeParties">Filter matches based on whether they are in the high skill range. (optional)</param>
        /// <param name="isLowPriPool">Filter matches based on whether they are in the low priority pool. (optional)</param>
        /// <param name="isNewPlayerPool">Filter matches based on whether they are in the new player pool. (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minKillsPerRaster">Filter Raster cells based on minimum kills. (optional)</param>
        /// <param name="maxKillsPerRaster">Filter Raster cells based on maximum kills. (optional)</param>
        /// <param name="minDeathsPerRaster">Filter Raster cells based on minimum deaths. (optional)</param>
        /// <param name="maxDeathsPerRaster">Filter Raster cells based on maximum deaths. (optional)</param>
        /// <param name="minGameTimeS">Filter kills based on their game time. (optional)</param>
        /// <param name="maxGameTimeS">Filter kills based on their game time. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IKillDeathStatsApiResponse"/>&gt;</returns>
        public async Task<IKillDeathStatsApiResponse> KillDeathStatsAsync(Option<int?> team = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<List<int>?> accountIds = default, Option<string?> heroIds = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<bool?> isHighSkillRangeParties = default, Option<bool?> isLowPriPool = default, Option<bool?> isNewPlayerPool = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<int?> minKillsPerRaster = default, Option<int?> maxKillsPerRaster = default, Option<int?> minDeathsPerRaster = default, Option<int?> maxDeathsPerRaster = default, Option<int?> minGameTimeS = default, Option<int?> maxGameTimeS = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatKillDeathStats(ref team, ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, accountIds, ref heroIds, ref minNetworth, ref maxNetworth, ref isHighSkillRangeParties, ref isLowPriPool, ref isNewPlayerPool, ref minMatchId, ref maxMatchId, ref minAverageBadge, ref maxAverageBadge, ref minKillsPerRaster, ref maxKillsPerRaster, ref minDeathsPerRaster, ref maxDeathsPerRaster, ref minGameTimeS, ref maxGameTimeS);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/kill-death-stats"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/kill-death-stats");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (team.IsSet)
                        parseQueryStringLocalVar["team"] = ClientUtils.ParameterToString(team.Value);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    if (heroIds.IsSet)
                        parseQueryStringLocalVar["hero_ids"] = ClientUtils.ParameterToString(heroIds.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (isHighSkillRangeParties.IsSet)
                        parseQueryStringLocalVar["is_high_skill_range_parties"] = ClientUtils.ParameterToString(isHighSkillRangeParties.Value);

                    if (isLowPriPool.IsSet)
                        parseQueryStringLocalVar["is_low_pri_pool"] = ClientUtils.ParameterToString(isLowPriPool.Value);

                    if (isNewPlayerPool.IsSet)
                        parseQueryStringLocalVar["is_new_player_pool"] = ClientUtils.ParameterToString(isNewPlayerPool.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minKillsPerRaster.IsSet)
                        parseQueryStringLocalVar["min_kills_per_raster"] = ClientUtils.ParameterToString(minKillsPerRaster.Value);

                    if (maxKillsPerRaster.IsSet)
                        parseQueryStringLocalVar["max_kills_per_raster"] = ClientUtils.ParameterToString(maxKillsPerRaster.Value);

                    if (minDeathsPerRaster.IsSet)
                        parseQueryStringLocalVar["min_deaths_per_raster"] = ClientUtils.ParameterToString(minDeathsPerRaster.Value);

                    if (maxDeathsPerRaster.IsSet)
                        parseQueryStringLocalVar["max_deaths_per_raster"] = ClientUtils.ParameterToString(maxDeathsPerRaster.Value);

                    if (minGameTimeS.IsSet)
                        parseQueryStringLocalVar["min_game_time_s"] = ClientUtils.ParameterToString(minGameTimeS.Value);

                    if (maxGameTimeS.IsSet)
                        parseQueryStringLocalVar["max_game_time_s"] = ClientUtils.ParameterToString(maxGameTimeS.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<KillDeathStatsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<KillDeathStatsApiResponse>();
                        KillDeathStatsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/kill-death-stats", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterKillDeathStatsDefaultImplementation(apiResponseLocalVar, team, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, accountIds, heroIds, minNetworth, maxNetworth, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, minAverageBadge, maxAverageBadge, minKillsPerRaster, maxKillsPerRaster, minDeathsPerRaster, maxDeathsPerRaster, minGameTimeS, maxGameTimeS);

                        Events.ExecuteOnKillDeathStats(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorKillDeathStatsDefaultImplementation(e, "/v1/analytics/kill-death-stats", uriBuilderLocalVar.Path, team, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, accountIds, heroIds, minNetworth, maxNetworth, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, minAverageBadge, maxAverageBadge, minKillsPerRaster, maxKillsPerRaster, minDeathsPerRaster, maxDeathsPerRaster, minGameTimeS, maxGameTimeS);
                Events.ExecuteOnErrorKillDeathStats(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="KillDeathStatsApiResponse"/>
        /// </summary>
        public partial class KillDeathStatsApiResponse : DeadlockApiClient.Client.ApiResponse, IKillDeathStatsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<KillDeathStatsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="KillDeathStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KillDeathStatsApiResponse(ILogger<KillDeathStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="KillDeathStatsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public KillDeathStatsApiResponse(ILogger<KillDeathStatsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<KillDeathStats>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<KillDeathStats>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<KillDeathStats>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPlayerPerformanceCurve(ref Option<int?> resolution, ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<string?> heroIds, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="resolution"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="heroIds"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountIds"></param>
        private void AfterPlayerPerformanceCurveDefaultImplementation(IPlayerPerformanceCurveApiResponse apiResponseLocalVar, Option<int?> resolution, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<string?> heroIds, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterPlayerPerformanceCurve(ref suppressDefaultLog, apiResponseLocalVar, resolution, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, heroIds, includeItemIds, excludeItemIds, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="resolution"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="heroIds"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountIds"></param>
        partial void AfterPlayerPerformanceCurve(ref bool suppressDefaultLog, IPlayerPerformanceCurveApiResponse apiResponseLocalVar, Option<int?> resolution, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<string?> heroIds, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="resolution"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="heroIds"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountIds"></param>
        private void OnErrorPlayerPerformanceCurveDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> resolution, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<string?> heroIds, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPlayerPerformanceCurve(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, resolution, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, heroIds, includeItemIds, excludeItemIds, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="resolution"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="heroIds"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorPlayerPerformanceCurve(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<int?> resolution, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<string?> heroIds, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds);

        /// <summary>
        /// Player Performance Curve  Retrieves player performance statistics (net worth, kills, deaths, assists) over time throughout matches.  Results are cached for **1 hour** based on the unique combination of query parameters provided.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="resolution">Resolution for relative game times in percent (0-100). **Default:** 10 (buckets of 10%). Set to **0** to use absolute game time (seconds). (optional, default to 10)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerPerformanceCurveApiResponse"/>&gt;</returns>
        public async Task<IPlayerPerformanceCurveApiResponse?> PlayerPerformanceCurveOrDefaultAsync(Option<int?> resolution = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<string?> heroIds = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PlayerPerformanceCurveAsync(resolution, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, heroIds, includeItemIds, excludeItemIds, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Player Performance Curve  Retrieves player performance statistics (net worth, kills, deaths, assists) over time throughout matches.  Results are cached for **1 hour** based on the unique combination of query parameters provided.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="resolution">Resolution for relative game times in percent (0-100). **Default:** 10 (buckets of 10%). Set to **0** to use absolute game time (seconds). (optional, default to 10)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerPerformanceCurveApiResponse"/>&gt;</returns>
        public async Task<IPlayerPerformanceCurveApiResponse> PlayerPerformanceCurveAsync(Option<int?> resolution = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<string?> heroIds = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatPlayerPerformanceCurve(ref resolution, ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref heroIds, includeItemIds, excludeItemIds, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/player-performance-curve"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/player-performance-curve");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (resolution.IsSet)
                        parseQueryStringLocalVar["resolution"] = ClientUtils.ParameterToString(resolution.Value);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (heroIds.IsSet)
                        parseQueryStringLocalVar["hero_ids"] = ClientUtils.ParameterToString(heroIds.Value);

                    if (includeItemIds.IsSet)
                        parseQueryStringLocalVar["include_item_ids"] = ClientUtils.ParameterToString(includeItemIds.Value);

                    if (excludeItemIds.IsSet)
                        parseQueryStringLocalVar["exclude_item_ids"] = ClientUtils.ParameterToString(excludeItemIds.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<PlayerPerformanceCurveApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PlayerPerformanceCurveApiResponse>();
                        PlayerPerformanceCurveApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/player-performance-curve", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterPlayerPerformanceCurveDefaultImplementation(apiResponseLocalVar, resolution, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, heroIds, includeItemIds, excludeItemIds, accountIds);

                        Events.ExecuteOnPlayerPerformanceCurve(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPlayerPerformanceCurveDefaultImplementation(e, "/v1/analytics/player-performance-curve", uriBuilderLocalVar.Path, resolution, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, heroIds, includeItemIds, excludeItemIds, accountIds);
                Events.ExecuteOnErrorPlayerPerformanceCurve(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PlayerPerformanceCurveApiResponse"/>
        /// </summary>
        public partial class PlayerPerformanceCurveApiResponse : DeadlockApiClient.Client.ApiResponse, IPlayerPerformanceCurveApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PlayerPerformanceCurveApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PlayerPerformanceCurveApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PlayerPerformanceCurveApiResponse(ILogger<PlayerPerformanceCurveApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="PlayerPerformanceCurveApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PlayerPerformanceCurveApiResponse(ILogger<PlayerPerformanceCurveApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<PlayerPerformanceCurvePoint>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<PlayerPerformanceCurvePoint>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<PlayerPerformanceCurvePoint>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPlayerScoreboard(ref string sortBy, ref Option<string> sortDirection, ref Option<string?> gameMode, ref Option<int?> heroId, ref Option<int?> minMatches, ref Option<int?> maxMatches, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<int?> start, ref Option<int?> limit, Option<List<int>?> accountIds);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <returns></returns>
        private void ValidatePlayerScoreboard(string sortBy, Option<string> sortDirection)
        {
            if (sortBy == null)
                throw new ArgumentNullException(nameof(sortBy));

            if (sortDirection.IsSet && sortDirection.Value == null)
                throw new ArgumentNullException(nameof(sortDirection));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroId"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="accountIds"></param>
        private void AfterPlayerScoreboardDefaultImplementation(IPlayerScoreboardApiResponse apiResponseLocalVar, string sortBy, Option<string> sortDirection, Option<string?> gameMode, Option<int?> heroId, Option<int?> minMatches, Option<int?> maxMatches, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> start, Option<int?> limit, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterPlayerScoreboard(ref suppressDefaultLog, apiResponseLocalVar, sortBy, sortDirection, gameMode, heroId, minMatches, maxMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, start, limit, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroId"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="accountIds"></param>
        partial void AfterPlayerScoreboard(ref bool suppressDefaultLog, IPlayerScoreboardApiResponse apiResponseLocalVar, string sortBy, Option<string> sortDirection, Option<string?> gameMode, Option<int?> heroId, Option<int?> minMatches, Option<int?> maxMatches, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> start, Option<int?> limit, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroId"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="accountIds"></param>
        private void OnErrorPlayerScoreboardDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string sortBy, Option<string> sortDirection, Option<string?> gameMode, Option<int?> heroId, Option<int?> minMatches, Option<int?> maxMatches, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> start, Option<int?> limit, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPlayerScoreboard(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, sortBy, sortDirection, gameMode, heroId, minMatches, maxMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, start, limit, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="sortBy"></param>
        /// <param name="sortDirection"></param>
        /// <param name="gameMode"></param>
        /// <param name="heroId"></param>
        /// <param name="minMatches"></param>
        /// <param name="maxMatches"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="start"></param>
        /// <param name="limit"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorPlayerScoreboard(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, string sortBy, Option<string> sortDirection, Option<string?> gameMode, Option<int?> heroId, Option<int?> minMatches, Option<int?> maxMatches, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> start, Option<int?> limit, Option<List<int>?> accountIds);

        /// <summary>
        /// Player Scoreboard  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="sortBy">The field to sort by.</param>
        /// <param name="sortDirection">The direction to sort players in. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="start">The offset to start fetching players from. (optional)</param>
        /// <param name="limit">The maximum number of players to fetch. (optional, default to 100)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerScoreboardApiResponse"/>&gt;</returns>
        public async Task<IPlayerScoreboardApiResponse?> PlayerScoreboardOrDefaultAsync(string sortBy, Option<string> sortDirection = default, Option<string?> gameMode = default, Option<int?> heroId = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> start = default, Option<int?> limit = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PlayerScoreboardAsync(sortBy, sortDirection, gameMode, heroId, minMatches, maxMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, start, limit, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Player Scoreboard  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="sortBy">The field to sort by.</param>
        /// <param name="sortDirection">The direction to sort players in. (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="heroId">Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="minMatches">The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)</param>
        /// <param name="maxMatches">The maximum number of matches played for a hero combination to be included in the response. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="start">The offset to start fetching players from. (optional)</param>
        /// <param name="limit">The maximum number of players to fetch. (optional, default to 100)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerScoreboardApiResponse"/>&gt;</returns>
        public async Task<IPlayerScoreboardApiResponse> PlayerScoreboardAsync(string sortBy, Option<string> sortDirection = default, Option<string?> gameMode = default, Option<int?> heroId = default, Option<int?> minMatches = default, Option<int?> maxMatches = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> start = default, Option<int?> limit = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidatePlayerScoreboard(sortBy, sortDirection);

                FormatPlayerScoreboard(ref sortBy, ref sortDirection, ref gameMode, ref heroId, ref minMatches, ref maxMatches, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref start, ref limit, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/scoreboards/players"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/scoreboards/players");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["sort_by"] = ClientUtils.ParameterToString(sortBy);

                    if (sortDirection.IsSet)
                        parseQueryStringLocalVar["sort_direction"] = ClientUtils.ParameterToString(sortDirection.Value);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (heroId.IsSet)
                        parseQueryStringLocalVar["hero_id"] = ClientUtils.ParameterToString(heroId.Value);

                    if (minMatches.IsSet)
                        parseQueryStringLocalVar["min_matches"] = ClientUtils.ParameterToString(minMatches.Value);

                    if (maxMatches.IsSet)
                        parseQueryStringLocalVar["max_matches"] = ClientUtils.ParameterToString(maxMatches.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (start.IsSet)
                        parseQueryStringLocalVar["start"] = ClientUtils.ParameterToString(start.Value);

                    if (limit.IsSet)
                        parseQueryStringLocalVar["limit"] = ClientUtils.ParameterToString(limit.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<PlayerScoreboardApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PlayerScoreboardApiResponse>();
                        PlayerScoreboardApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/scoreboards/players", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterPlayerScoreboardDefaultImplementation(apiResponseLocalVar, sortBy, sortDirection, gameMode, heroId, minMatches, maxMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, start, limit, accountIds);

                        Events.ExecuteOnPlayerScoreboard(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPlayerScoreboardDefaultImplementation(e, "/v1/analytics/scoreboards/players", uriBuilderLocalVar.Path, sortBy, sortDirection, gameMode, heroId, minMatches, maxMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, start, limit, accountIds);
                Events.ExecuteOnErrorPlayerScoreboard(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PlayerScoreboardApiResponse"/>
        /// </summary>
        public partial class PlayerScoreboardApiResponse : DeadlockApiClient.Client.ApiResponse, IPlayerScoreboardApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PlayerScoreboardApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PlayerScoreboardApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PlayerScoreboardApiResponse(ILogger<PlayerScoreboardApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="PlayerScoreboardApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PlayerScoreboardApiResponse(ILogger<PlayerScoreboardApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public List<Entry>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<List<Entry>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out List<Entry>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatPlayerStatsMetrics(ref Option<string?> heroIds, ref Option<string?> gameMode, ref Option<long?> minUnixTimestamp, ref Option<long?> maxUnixTimestamp, ref Option<long?> minDurationS, ref Option<long?> maxDurationS, ref Option<long?> minNetworth, ref Option<long?> maxNetworth, ref Option<int?> minAverageBadge, ref Option<int?> maxAverageBadge, ref Option<long?> minMatchId, ref Option<long?> maxMatchId, ref Option<int?> maxMatches, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds);

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="heroIds"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="maxMatches"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountIds"></param>
        private void AfterPlayerStatsMetricsDefaultImplementation(IPlayerStatsMetricsApiResponse apiResponseLocalVar, Option<string?> heroIds, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> maxMatches, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLog = false;
            AfterPlayerStatsMetrics(ref suppressDefaultLog, apiResponseLocalVar, heroIds, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, maxMatches, includeItemIds, excludeItemIds, accountIds);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {2}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="heroIds"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="maxMatches"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountIds"></param>
        partial void AfterPlayerStatsMetrics(ref bool suppressDefaultLog, IPlayerStatsMetricsApiResponse apiResponseLocalVar, Option<string?> heroIds, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> maxMatches, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="heroIds"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="maxMatches"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountIds"></param>
        private void OnErrorPlayerStatsMetricsDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> heroIds, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> maxMatches, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorPlayerStatsMetrics(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, heroIds, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, maxMatches, includeItemIds, excludeItemIds, accountIds);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="heroIds"></param>
        /// <param name="gameMode"></param>
        /// <param name="minUnixTimestamp"></param>
        /// <param name="maxUnixTimestamp"></param>
        /// <param name="minDurationS"></param>
        /// <param name="maxDurationS"></param>
        /// <param name="minNetworth"></param>
        /// <param name="maxNetworth"></param>
        /// <param name="minAverageBadge"></param>
        /// <param name="maxAverageBadge"></param>
        /// <param name="minMatchId"></param>
        /// <param name="maxMatchId"></param>
        /// <param name="maxMatches"></param>
        /// <param name="includeItemIds"></param>
        /// <param name="excludeItemIds"></param>
        /// <param name="accountIds"></param>
        partial void OnErrorPlayerStatsMetrics(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, Option<string?> heroIds, Option<string?> gameMode, Option<long?> minUnixTimestamp, Option<long?> maxUnixTimestamp, Option<long?> minDurationS, Option<long?> maxDurationS, Option<long?> minNetworth, Option<long?> maxNetworth, Option<int?> minAverageBadge, Option<int?> maxAverageBadge, Option<long?> minMatchId, Option<long?> maxMatchId, Option<int?> maxMatches, Option<List<int>?> includeItemIds, Option<List<int>?> excludeItemIds, Option<List<int>?> accountIds);

        /// <summary>
        /// Player Stats Metrics  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  &gt; Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatches">The maximum number of matches to analyze. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerStatsMetricsApiResponse"/>&gt;</returns>
        public async Task<IPlayerStatsMetricsApiResponse?> PlayerStatsMetricsOrDefaultAsync(Option<string?> heroIds = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> maxMatches = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await PlayerStatsMetricsAsync(heroIds, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, maxMatches, includeItemIds, excludeItemIds, accountIds, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Player Stats Metrics  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  &gt; Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | - -- - | - -- -- | | IP | 100req/s | | Key | - | | Global | - |     
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="heroIds">Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)</param>
        /// <param name="gameMode">Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;. (optional)</param>
        /// <param name="minUnixTimestamp">Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1769126400)</param>
        /// <param name="maxUnixTimestamp">Filter matches based on their start time (Unix timestamp). (optional)</param>
        /// <param name="minDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="maxDurationS">Filter matches based on their duration in seconds (up to 7000s). (optional)</param>
        /// <param name="minNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="maxNetworth">Filter players based on their final net worth. (optional)</param>
        /// <param name="minAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="maxAverageBadge">Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)</param>
        /// <param name="minMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatchId">Filter matches based on their ID. (optional)</param>
        /// <param name="maxMatches">The maximum number of matches to analyze. (optional)</param>
        /// <param name="includeItemIds">Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="excludeItemIds">Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)</param>
        /// <param name="accountIds">Comma separated list of account ids to include (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IPlayerStatsMetricsApiResponse"/>&gt;</returns>
        public async Task<IPlayerStatsMetricsApiResponse> PlayerStatsMetricsAsync(Option<string?> heroIds = default, Option<string?> gameMode = default, Option<long?> minUnixTimestamp = default, Option<long?> maxUnixTimestamp = default, Option<long?> minDurationS = default, Option<long?> maxDurationS = default, Option<long?> minNetworth = default, Option<long?> maxNetworth = default, Option<int?> minAverageBadge = default, Option<int?> maxAverageBadge = default, Option<long?> minMatchId = default, Option<long?> maxMatchId = default, Option<int?> maxMatches = default, Option<List<int>?> includeItemIds = default, Option<List<int>?> excludeItemIds = default, Option<List<int>?> accountIds = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                FormatPlayerStatsMetrics(ref heroIds, ref gameMode, ref minUnixTimestamp, ref maxUnixTimestamp, ref minDurationS, ref maxDurationS, ref minNetworth, ref maxNetworth, ref minAverageBadge, ref maxAverageBadge, ref minMatchId, ref maxMatchId, ref maxMatches, includeItemIds, excludeItemIds, accountIds);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/v1/analytics/player-stats/metrics"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/v1/analytics/player-stats/metrics");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    if (heroIds.IsSet)
                        parseQueryStringLocalVar["hero_ids"] = ClientUtils.ParameterToString(heroIds.Value);

                    if (gameMode.IsSet)
                        parseQueryStringLocalVar["game_mode"] = ClientUtils.ParameterToString(gameMode.Value);

                    if (minUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["min_unix_timestamp"] = ClientUtils.ParameterToString(minUnixTimestamp.Value);

                    if (maxUnixTimestamp.IsSet)
                        parseQueryStringLocalVar["max_unix_timestamp"] = ClientUtils.ParameterToString(maxUnixTimestamp.Value);

                    if (minDurationS.IsSet)
                        parseQueryStringLocalVar["min_duration_s"] = ClientUtils.ParameterToString(minDurationS.Value);

                    if (maxDurationS.IsSet)
                        parseQueryStringLocalVar["max_duration_s"] = ClientUtils.ParameterToString(maxDurationS.Value);

                    if (minNetworth.IsSet)
                        parseQueryStringLocalVar["min_networth"] = ClientUtils.ParameterToString(minNetworth.Value);

                    if (maxNetworth.IsSet)
                        parseQueryStringLocalVar["max_networth"] = ClientUtils.ParameterToString(maxNetworth.Value);

                    if (minAverageBadge.IsSet)
                        parseQueryStringLocalVar["min_average_badge"] = ClientUtils.ParameterToString(minAverageBadge.Value);

                    if (maxAverageBadge.IsSet)
                        parseQueryStringLocalVar["max_average_badge"] = ClientUtils.ParameterToString(maxAverageBadge.Value);

                    if (minMatchId.IsSet)
                        parseQueryStringLocalVar["min_match_id"] = ClientUtils.ParameterToString(minMatchId.Value);

                    if (maxMatchId.IsSet)
                        parseQueryStringLocalVar["max_match_id"] = ClientUtils.ParameterToString(maxMatchId.Value);

                    if (maxMatches.IsSet)
                        parseQueryStringLocalVar["max_matches"] = ClientUtils.ParameterToString(maxMatches.Value);

                    if (includeItemIds.IsSet)
                        parseQueryStringLocalVar["include_item_ids"] = ClientUtils.ParameterToString(includeItemIds.Value);

                    if (excludeItemIds.IsSet)
                        parseQueryStringLocalVar["exclude_item_ids"] = ClientUtils.ParameterToString(excludeItemIds.Value);

                    if (accountIds.IsSet)
                        parseQueryStringLocalVar["account_ids"] = ClientUtils.ParameterToString(accountIds.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    IEnumerable<MediaTypeWithQualityHeaderValue> acceptHeaderValuesLocalVar = ClientUtils.SelectHeaderAcceptArray(acceptLocalVars);

                    foreach (var acceptLocalVar in acceptHeaderValuesLocalVar)
                        httpRequestMessageLocalVar.Headers.Accept.Add(acceptLocalVar);

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<PlayerStatsMetricsApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<PlayerStatsMetricsApiResponse>();
                        PlayerStatsMetricsApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/v1/analytics/player-stats/metrics", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterPlayerStatsMetricsDefaultImplementation(apiResponseLocalVar, heroIds, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, maxMatches, includeItemIds, excludeItemIds, accountIds);

                        Events.ExecuteOnPlayerStatsMetrics(apiResponseLocalVar);

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorPlayerStatsMetricsDefaultImplementation(e, "/v1/analytics/player-stats/metrics", uriBuilderLocalVar.Path, heroIds, gameMode, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, maxMatches, includeItemIds, excludeItemIds, accountIds);
                Events.ExecuteOnErrorPlayerStatsMetrics(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="PlayerStatsMetricsApiResponse"/>
        /// </summary>
        public partial class PlayerStatsMetricsApiResponse : DeadlockApiClient.Client.ApiResponse, IPlayerStatsMetricsApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<PlayerStatsMetricsApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="PlayerStatsMetricsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PlayerStatsMetricsApiResponse(ILogger<PlayerStatsMetricsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="PlayerStatsMetricsApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public PlayerStatsMetricsApiResponse(ILogger<PlayerStatsMetricsApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public Dictionary<string, HashMapValue>? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, HashMapValue>>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out Dictionary<string, HashMapValue>? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
