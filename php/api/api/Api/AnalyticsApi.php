<?php
/**
 * AnalyticsApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Deadlock API
 *
 * ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_
 *
 * The version of the OpenAPI document: 0.1.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.19.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * AnalyticsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class AnalyticsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'abilityOrderStats' => [
            'application/json',
        ],
        'badgeDistribution' => [
            'application/json',
        ],
        'buildItemStats' => [
            'application/json',
        ],
        'heroCombStats' => [
            'application/json',
        ],
        'heroCountersStats' => [
            'application/json',
        ],
        'heroScoreboard' => [
            'application/json',
        ],
        'heroStats' => [
            'application/json',
        ],
        'heroSynergiesStats' => [
            'application/json',
        ],
        'itemPermutationStats' => [
            'application/json',
        ],
        'itemStats' => [
            'application/json',
        ],
        'killDeathStats' => [
            'application/json',
        ],
        'playerPerformanceCurve' => [
            'application/json',
        ],
        'playerScoreboard' => [
            'application/json',
        ],
        'playerStatsMetrics' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation abilityOrderStats
     *
     * Ability Order Stats
     *
     * @param  int $hero_id See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (required)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_ability_upgrades Filter players based on their minimum number of ability upgrades over the whole match. (optional)
     * @param  int|null $max_ability_upgrades Filter players based on their maximum number of ability upgrades over the whole match. (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_matches The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abilityOrderStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AnalyticsAbilityOrderStats[]
     */
    public function abilityOrderStats($hero_id, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_ability_upgrades = null, $max_ability_upgrades = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_matches = 20, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['abilityOrderStats'][0])
    {
        list($response) = $this->abilityOrderStatsWithHttpInfo($hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_ability_upgrades, $max_ability_upgrades, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $min_matches, $account_id, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation abilityOrderStatsWithHttpInfo
     *
     * Ability Order Stats
     *
     * @param  int $hero_id See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (required)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_ability_upgrades Filter players based on their minimum number of ability upgrades over the whole match. (optional)
     * @param  int|null $max_ability_upgrades Filter players based on their maximum number of ability upgrades over the whole match. (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_matches The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abilityOrderStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AnalyticsAbilityOrderStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function abilityOrderStatsWithHttpInfo($hero_id, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_ability_upgrades = null, $max_ability_upgrades = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_matches = 20, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['abilityOrderStats'][0])
    {
        $request = $this->abilityOrderStatsRequest($hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_ability_upgrades, $max_ability_upgrades, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $min_matches, $account_id, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AnalyticsAbilityOrderStats[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AnalyticsAbilityOrderStats[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AnalyticsAbilityOrderStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation abilityOrderStatsAsync
     *
     * Ability Order Stats
     *
     * @param  int $hero_id See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (required)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_ability_upgrades Filter players based on their minimum number of ability upgrades over the whole match. (optional)
     * @param  int|null $max_ability_upgrades Filter players based on their maximum number of ability upgrades over the whole match. (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_matches The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abilityOrderStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function abilityOrderStatsAsync($hero_id, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_ability_upgrades = null, $max_ability_upgrades = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_matches = 20, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['abilityOrderStats'][0])
    {
        return $this->abilityOrderStatsAsyncWithHttpInfo($hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_ability_upgrades, $max_ability_upgrades, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $min_matches, $account_id, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation abilityOrderStatsAsyncWithHttpInfo
     *
     * Ability Order Stats
     *
     * @param  int $hero_id See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (required)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_ability_upgrades Filter players based on their minimum number of ability upgrades over the whole match. (optional)
     * @param  int|null $max_ability_upgrades Filter players based on their maximum number of ability upgrades over the whole match. (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_matches The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abilityOrderStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function abilityOrderStatsAsyncWithHttpInfo($hero_id, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_ability_upgrades = null, $max_ability_upgrades = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_matches = 20, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['abilityOrderStats'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AnalyticsAbilityOrderStats[]';
        $request = $this->abilityOrderStatsRequest($hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_ability_upgrades, $max_ability_upgrades, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $min_matches, $account_id, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'abilityOrderStats'
     *
     * @param  int $hero_id See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (required)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_ability_upgrades Filter players based on their minimum number of ability upgrades over the whole match. (optional)
     * @param  int|null $max_ability_upgrades Filter players based on their maximum number of ability upgrades over the whole match. (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_matches The minimum number of matches played for an ability order to be included in the response. (optional, default to 20)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['abilityOrderStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function abilityOrderStatsRequest($hero_id, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_ability_upgrades = null, $max_ability_upgrades = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_matches = 20, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['abilityOrderStats'][0])
    {

        // verify the required parameter 'hero_id' is set
        if ($hero_id === null || (is_array($hero_id) && count($hero_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $hero_id when calling abilityOrderStats'
            );
        }
        if ($hero_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$hero_id" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        


        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.abilityOrderStats, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.abilityOrderStats, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($min_ability_upgrades !== null && $min_ability_upgrades > 16) {
            throw new \InvalidArgumentException('invalid value for "$min_ability_upgrades" when calling AnalyticsApi.abilityOrderStats, must be smaller than or equal to 16.');
        }
        if ($min_ability_upgrades !== null && $min_ability_upgrades < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_ability_upgrades" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($max_ability_upgrades !== null && $max_ability_upgrades > 16) {
            throw new \InvalidArgumentException('invalid value for "$max_ability_upgrades" when calling AnalyticsApi.abilityOrderStats, must be smaller than or equal to 16.');
        }
        if ($max_ability_upgrades !== null && $max_ability_upgrades < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_ability_upgrades" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 1.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.abilityOrderStats, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.abilityOrderStats, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($min_matches !== null && $min_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$min_matches" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 1.');
        }
        
        if ($account_id !== null && $account_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$account_id" when calling AnalyticsApi.abilityOrderStats, must be bigger than or equal to 0.');
        }
        
        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.abilityOrderStats, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.abilityOrderStats, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/ability-order-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_id,
            'hero_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_ability_upgrades,
            'min_ability_upgrades', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_ability_upgrades,
            'max_ability_upgrades', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_matches,
            'min_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'account_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation badgeDistribution
     *
     * Badge Distribution
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['badgeDistribution'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadgeDistribution[]
     */
    public function badgeDistribution($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, string $contentType = self::contentTypes['badgeDistribution'][0])
    {
        list($response) = $this->badgeDistributionWithHttpInfo($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $is_high_skill_range_parties, $is_low_pri_pool, $is_new_player_pool, $min_match_id, $max_match_id, $contentType);
        return $response;
    }

    /**
     * Operation badgeDistributionWithHttpInfo
     *
     * Badge Distribution
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['badgeDistribution'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadgeDistribution[], HTTP status code, HTTP response headers (array of strings)
     */
    public function badgeDistributionWithHttpInfo($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, string $contentType = self::contentTypes['badgeDistribution'][0])
    {
        $request = $this->badgeDistributionRequest($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $is_high_skill_range_parties, $is_low_pri_pool, $is_new_player_pool, $min_match_id, $max_match_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BadgeDistribution[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BadgeDistribution[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadgeDistribution[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation badgeDistributionAsync
     *
     * Badge Distribution
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['badgeDistribution'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function badgeDistributionAsync($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, string $contentType = self::contentTypes['badgeDistribution'][0])
    {
        return $this->badgeDistributionAsyncWithHttpInfo($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $is_high_skill_range_parties, $is_low_pri_pool, $is_new_player_pool, $min_match_id, $max_match_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation badgeDistributionAsyncWithHttpInfo
     *
     * Badge Distribution
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['badgeDistribution'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function badgeDistributionAsyncWithHttpInfo($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, string $contentType = self::contentTypes['badgeDistribution'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BadgeDistribution[]';
        $request = $this->badgeDistributionRequest($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $is_high_skill_range_parties, $is_low_pri_pool, $is_new_player_pool, $min_match_id, $max_match_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'badgeDistribution'
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['badgeDistribution'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function badgeDistributionRequest($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, string $contentType = self::contentTypes['badgeDistribution'][0])
    {



        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.badgeDistribution, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.badgeDistribution, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.badgeDistribution, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.badgeDistribution, must be bigger than or equal to 0.');
        }
        



        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.badgeDistribution, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.badgeDistribution, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/v1/analytics/badge-distribution';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_high_skill_range_parties,
            'is_high_skill_range_parties', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_low_pri_pool,
            'is_low_pri_pool', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_new_player_pool,
            'is_new_player_pool', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation buildItemStats
     *
     * Build Item Stats
     *
     * @param  int|null $hero_id Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buildItemStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BuildItemStats[]
     */
    public function buildItemStats($hero_id = null, $min_last_updated_unix_timestamp = 1766275200, $max_last_updated_unix_timestamp = null, string $contentType = self::contentTypes['buildItemStats'][0])
    {
        list($response) = $this->buildItemStatsWithHttpInfo($hero_id, $min_last_updated_unix_timestamp, $max_last_updated_unix_timestamp, $contentType);
        return $response;
    }

    /**
     * Operation buildItemStatsWithHttpInfo
     *
     * Build Item Stats
     *
     * @param  int|null $hero_id Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buildItemStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BuildItemStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function buildItemStatsWithHttpInfo($hero_id = null, $min_last_updated_unix_timestamp = 1766275200, $max_last_updated_unix_timestamp = null, string $contentType = self::contentTypes['buildItemStats'][0])
    {
        $request = $this->buildItemStatsRequest($hero_id, $min_last_updated_unix_timestamp, $max_last_updated_unix_timestamp, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BuildItemStats[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BuildItemStats[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BuildItemStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation buildItemStatsAsync
     *
     * Build Item Stats
     *
     * @param  int|null $hero_id Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buildItemStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildItemStatsAsync($hero_id = null, $min_last_updated_unix_timestamp = 1766275200, $max_last_updated_unix_timestamp = null, string $contentType = self::contentTypes['buildItemStats'][0])
    {
        return $this->buildItemStatsAsyncWithHttpInfo($hero_id, $min_last_updated_unix_timestamp, $max_last_updated_unix_timestamp, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation buildItemStatsAsyncWithHttpInfo
     *
     * Build Item Stats
     *
     * @param  int|null $hero_id Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buildItemStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function buildItemStatsAsyncWithHttpInfo($hero_id = null, $min_last_updated_unix_timestamp = 1766275200, $max_last_updated_unix_timestamp = null, string $contentType = self::contentTypes['buildItemStats'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BuildItemStats[]';
        $request = $this->buildItemStatsRequest($hero_id, $min_last_updated_unix_timestamp, $max_last_updated_unix_timestamp, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'buildItemStats'
     *
     * @param  int|null $hero_id Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_last_updated_unix_timestamp Filter builds based on their last updated time (Unix timestamp). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['buildItemStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function buildItemStatsRequest($hero_id = null, $min_last_updated_unix_timestamp = 1766275200, $max_last_updated_unix_timestamp = null, string $contentType = self::contentTypes['buildItemStats'][0])
    {

        if ($hero_id !== null && $hero_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$hero_id" when calling AnalyticsApi.buildItemStats, must be bigger than or equal to 0.');
        }
        



        $resourcePath = '/v1/analytics/build-item-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_id,
            'hero_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_last_updated_unix_timestamp,
            'min_last_updated_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_last_updated_unix_timestamp,
            'max_last_updated_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation heroCombStats
     *
     * Hero Comb Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_hero_ids Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $exclude_hero_ids Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 6)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCombStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HeroCombStats[]
     */
    public function heroCombStats($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_hero_ids = null, $exclude_hero_ids = null, $min_matches = 20, $max_matches = null, $comb_size = 6, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCombStats'][0])
    {
        list($response) = $this->heroCombStatsWithHttpInfo($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $include_hero_ids, $exclude_hero_ids, $min_matches, $max_matches, $comb_size, $account_id, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation heroCombStatsWithHttpInfo
     *
     * Hero Comb Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_hero_ids Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $exclude_hero_ids Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 6)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCombStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HeroCombStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function heroCombStatsWithHttpInfo($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_hero_ids = null, $exclude_hero_ids = null, $min_matches = 20, $max_matches = null, $comb_size = 6, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCombStats'][0])
    {
        $request = $this->heroCombStatsRequest($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $include_hero_ids, $exclude_hero_ids, $min_matches, $max_matches, $comb_size, $account_id, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HeroCombStats[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HeroCombStats[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HeroCombStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation heroCombStatsAsync
     *
     * Hero Comb Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_hero_ids Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $exclude_hero_ids Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 6)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCombStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroCombStatsAsync($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_hero_ids = null, $exclude_hero_ids = null, $min_matches = 20, $max_matches = null, $comb_size = 6, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCombStats'][0])
    {
        return $this->heroCombStatsAsyncWithHttpInfo($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $include_hero_ids, $exclude_hero_ids, $min_matches, $max_matches, $comb_size, $account_id, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation heroCombStatsAsyncWithHttpInfo
     *
     * Hero Comb Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_hero_ids Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $exclude_hero_ids Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 6)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCombStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroCombStatsAsyncWithHttpInfo($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_hero_ids = null, $exclude_hero_ids = null, $min_matches = 20, $max_matches = null, $comb_size = 6, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCombStats'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HeroCombStats[]';
        $request = $this->heroCombStatsRequest($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $include_hero_ids, $exclude_hero_ids, $min_matches, $max_matches, $comb_size, $account_id, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'heroCombStats'
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_hero_ids Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $exclude_hero_ids Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 6)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCombStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function heroCombStatsRequest($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_hero_ids = null, $exclude_hero_ids = null, $min_matches = 20, $max_matches = null, $comb_size = 6, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCombStats'][0])
    {



        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroCombStats, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroCombStats, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroCombStats, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroCombStats, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 0.');
        }
        


        if ($min_matches !== null && $min_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$min_matches" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 1.');
        }
        
        if ($max_matches !== null && $max_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_matches" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 1.');
        }
        
        if ($comb_size !== null && $comb_size > 6) {
            throw new \InvalidArgumentException('invalid value for "$comb_size" when calling AnalyticsApi.heroCombStats, must be smaller than or equal to 6.');
        }
        if ($comb_size !== null && $comb_size < 2) {
            throw new \InvalidArgumentException('invalid value for "$comb_size" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 2.');
        }
        
        if ($account_id !== null && $account_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$account_id" when calling AnalyticsApi.heroCombStats, must be bigger than or equal to 0.');
        }
        
        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroCombStats, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroCombStats, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/hero-comb-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_hero_ids,
            'include_hero_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_hero_ids,
            'exclude_hero_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_matches,
            'min_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_matches,
            'max_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comb_size,
            'comb_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'account_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation heroCountersStats
     *
     * Hero Counter Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $max_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCountersStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HeroCounterStats[]
     */
    public function heroCountersStats($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_enemy_networth = null, $max_enemy_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCountersStats'][0])
    {
        list($response) = $this->heroCountersStatsWithHttpInfo($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_enemy_networth, $max_enemy_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $same_lane_filter, $min_matches, $max_matches, $account_id, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation heroCountersStatsWithHttpInfo
     *
     * Hero Counter Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $max_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCountersStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HeroCounterStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function heroCountersStatsWithHttpInfo($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_enemy_networth = null, $max_enemy_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCountersStats'][0])
    {
        $request = $this->heroCountersStatsRequest($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_enemy_networth, $max_enemy_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $same_lane_filter, $min_matches, $max_matches, $account_id, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HeroCounterStats[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HeroCounterStats[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HeroCounterStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation heroCountersStatsAsync
     *
     * Hero Counter Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $max_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCountersStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroCountersStatsAsync($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_enemy_networth = null, $max_enemy_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCountersStats'][0])
    {
        return $this->heroCountersStatsAsyncWithHttpInfo($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_enemy_networth, $max_enemy_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $same_lane_filter, $min_matches, $max_matches, $account_id, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation heroCountersStatsAsyncWithHttpInfo
     *
     * Hero Counter Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $max_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCountersStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroCountersStatsAsyncWithHttpInfo($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_enemy_networth = null, $max_enemy_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCountersStats'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HeroCounterStats[]';
        $request = $this->heroCountersStatsRequest($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_enemy_networth, $max_enemy_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $same_lane_filter, $min_matches, $max_matches, $account_id, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'heroCountersStats'
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $max_enemy_networth Filter enemy players based on their net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroCountersStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function heroCountersStatsRequest($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_enemy_networth = null, $max_enemy_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroCountersStats'][0])
    {



        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroCountersStats, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroCountersStats, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($min_enemy_networth !== null && $min_enemy_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_enemy_networth" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($max_enemy_networth !== null && $max_enemy_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_enemy_networth" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroCountersStats, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroCountersStats, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        

        if ($min_matches !== null && $min_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$min_matches" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 1.');
        }
        
        if ($max_matches !== null && $max_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_matches" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 1.');
        }
        
        if ($account_id !== null && $account_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$account_id" when calling AnalyticsApi.heroCountersStats, must be bigger than or equal to 0.');
        }
        
        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroCountersStats, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroCountersStats, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/hero-counter-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_enemy_networth,
            'min_enemy_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_enemy_networth,
            'max_enemy_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $same_lane_filter,
            'same_lane_filter', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_matches,
            'min_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_matches,
            'max_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'account_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation heroScoreboard
     *
     * Hero Scoreboard
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort heroes in. (optional)
     * @param  int|null $min_matches Filter by min number of matches played. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroScoreboard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Entry[]
     */
    public function heroScoreboard($sort_by, $sort_direction = null, $min_matches = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroScoreboard'][0])
    {
        list($response) = $this->heroScoreboardWithHttpInfo($sort_by, $sort_direction, $min_matches, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $account_id, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation heroScoreboardWithHttpInfo
     *
     * Hero Scoreboard
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort heroes in. (optional)
     * @param  int|null $min_matches Filter by min number of matches played. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroScoreboard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Entry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function heroScoreboardWithHttpInfo($sort_by, $sort_direction = null, $min_matches = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroScoreboard'][0])
    {
        $request = $this->heroScoreboardRequest($sort_by, $sort_direction, $min_matches, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $account_id, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Entry[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\Entry[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Entry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation heroScoreboardAsync
     *
     * Hero Scoreboard
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort heroes in. (optional)
     * @param  int|null $min_matches Filter by min number of matches played. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroScoreboard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroScoreboardAsync($sort_by, $sort_direction = null, $min_matches = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroScoreboard'][0])
    {
        return $this->heroScoreboardAsyncWithHttpInfo($sort_by, $sort_direction, $min_matches, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $account_id, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation heroScoreboardAsyncWithHttpInfo
     *
     * Hero Scoreboard
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort heroes in. (optional)
     * @param  int|null $min_matches Filter by min number of matches played. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroScoreboard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroScoreboardAsyncWithHttpInfo($sort_by, $sort_direction = null, $min_matches = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroScoreboard'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Entry[]';
        $request = $this->heroScoreboardRequest($sort_by, $sort_direction, $min_matches, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $account_id, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'heroScoreboard'
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort heroes in. (optional)
     * @param  int|null $min_matches Filter by min number of matches played. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroScoreboard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function heroScoreboardRequest($sort_by, $sort_direction = null, $min_matches = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroScoreboard'][0])
    {

        // verify the required parameter 'sort_by' is set
        if ($sort_by === null || (is_array($sort_by) && count($sort_by) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sort_by when calling heroScoreboard'
            );
        }


        if ($min_matches !== null && $min_matches < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_matches" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        


        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroScoreboard, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroScoreboard, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroScoreboard, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroScoreboard, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($account_id !== null && $account_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$account_id" when calling AnalyticsApi.heroScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroScoreboard, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroScoreboard, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/scoreboards/heroes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sort_by', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_direction,
            'sort_direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_matches,
            'min_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'account_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation heroStats
     *
     * Hero Stats
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $max_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $min_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int|null $max_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AnalyticsHeroStats[]
     */
    public function heroStats($bucket = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_hero_matches = null, $max_hero_matches = null, $min_hero_matches_total = null, $max_hero_matches_total = null, $include_item_ids = null, $exclude_item_ids = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroStats'][0])
    {
        list($response) = $this->heroStatsWithHttpInfo($bucket, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $min_hero_matches, $max_hero_matches, $min_hero_matches_total, $max_hero_matches_total, $include_item_ids, $exclude_item_ids, $account_id, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation heroStatsWithHttpInfo
     *
     * Hero Stats
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $max_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $min_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int|null $max_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AnalyticsHeroStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function heroStatsWithHttpInfo($bucket = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_hero_matches = null, $max_hero_matches = null, $min_hero_matches_total = null, $max_hero_matches_total = null, $include_item_ids = null, $exclude_item_ids = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroStats'][0])
    {
        $request = $this->heroStatsRequest($bucket, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $min_hero_matches, $max_hero_matches, $min_hero_matches_total, $max_hero_matches_total, $include_item_ids, $exclude_item_ids, $account_id, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\AnalyticsHeroStats[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\AnalyticsHeroStats[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AnalyticsHeroStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation heroStatsAsync
     *
     * Hero Stats
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $max_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $min_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int|null $max_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroStatsAsync($bucket = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_hero_matches = null, $max_hero_matches = null, $min_hero_matches_total = null, $max_hero_matches_total = null, $include_item_ids = null, $exclude_item_ids = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroStats'][0])
    {
        return $this->heroStatsAsyncWithHttpInfo($bucket, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $min_hero_matches, $max_hero_matches, $min_hero_matches_total, $max_hero_matches_total, $include_item_ids, $exclude_item_ids, $account_id, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation heroStatsAsyncWithHttpInfo
     *
     * Hero Stats
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $max_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $min_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int|null $max_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroStatsAsyncWithHttpInfo($bucket = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_hero_matches = null, $max_hero_matches = null, $min_hero_matches_total = null, $max_hero_matches_total = null, $include_item_ids = null, $exclude_item_ids = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroStats'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AnalyticsHeroStats[]';
        $request = $this->heroStatsRequest($bucket, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $min_hero_matches, $max_hero_matches, $min_hero_matches_total, $max_hero_matches_total, $include_item_ids, $exclude_item_ids, $account_id, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'heroStats'
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $max_hero_matches Filter players based on the number of matches they have played with a specific hero within the filtered time range. (optional)
     * @param  int|null $min_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int|null $max_hero_matches_total Filter players based on the number of matches they have played with a specific hero in their entire history. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function heroStatsRequest($bucket = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $min_hero_matches = null, $max_hero_matches = null, $min_hero_matches_total = null, $max_hero_matches_total = null, $include_item_ids = null, $exclude_item_ids = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroStats'][0])
    {




        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroStats, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroStats, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroStats, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroStats, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($min_hero_matches !== null && $min_hero_matches < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_hero_matches" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($max_hero_matches !== null && $max_hero_matches < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_hero_matches" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($min_hero_matches_total !== null && $min_hero_matches_total < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_hero_matches_total" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($max_hero_matches_total !== null && $max_hero_matches_total < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_hero_matches_total" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        


        if ($account_id !== null && $account_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$account_id" when calling AnalyticsApi.heroStats, must be bigger than or equal to 0.');
        }
        
        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroStats, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroStats, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/hero-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bucket,
            'bucket', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_hero_matches,
            'min_hero_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_hero_matches,
            'max_hero_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_hero_matches_total,
            'min_hero_matches_total', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_hero_matches_total,
            'max_hero_matches_total', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_item_ids,
            'include_item_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_item_ids,
            'exclude_item_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'account_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation heroSynergiesStats
     *
     * Hero Synergy Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  bool|null $same_party_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroSynergiesStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\HeroSynergyStats[]
     */
    public function heroSynergiesStats($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $same_party_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroSynergiesStats'][0])
    {
        list($response) = $this->heroSynergiesStatsWithHttpInfo($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $same_lane_filter, $same_party_filter, $min_matches, $max_matches, $account_id, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation heroSynergiesStatsWithHttpInfo
     *
     * Hero Synergy Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  bool|null $same_party_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroSynergiesStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\HeroSynergyStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function heroSynergiesStatsWithHttpInfo($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $same_party_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroSynergiesStats'][0])
    {
        $request = $this->heroSynergiesStatsRequest($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $same_lane_filter, $same_party_filter, $min_matches, $max_matches, $account_id, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\HeroSynergyStats[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\HeroSynergyStats[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\HeroSynergyStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation heroSynergiesStatsAsync
     *
     * Hero Synergy Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  bool|null $same_party_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroSynergiesStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroSynergiesStatsAsync($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $same_party_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroSynergiesStats'][0])
    {
        return $this->heroSynergiesStatsAsyncWithHttpInfo($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $same_lane_filter, $same_party_filter, $min_matches, $max_matches, $account_id, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation heroSynergiesStatsAsyncWithHttpInfo
     *
     * Hero Synergy Stats
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  bool|null $same_party_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroSynergiesStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function heroSynergiesStatsAsyncWithHttpInfo($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $same_party_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroSynergiesStats'][0])
    {
        $returnType = '\OpenAPI\Client\Model\HeroSynergyStats[]';
        $request = $this->heroSynergiesStatsRequest($min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $same_lane_filter, $same_party_filter, $min_matches, $max_matches, $account_id, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'heroSynergiesStats'
     *
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  bool|null $same_lane_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane. (optional, default to true)
     * @param  bool|null $same_party_filter When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation. (optional, default to true)
     * @param  int|null $min_matches The minimum number of matches played for a hero combination to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['heroSynergiesStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function heroSynergiesStatsRequest($min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $same_lane_filter = true, $same_party_filter = true, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['heroSynergiesStats'][0])
    {



        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroSynergiesStats, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroSynergiesStats, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroSynergiesStats, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroSynergiesStats, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 0.');
        }
        


        if ($min_matches !== null && $min_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$min_matches" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 1.');
        }
        
        if ($max_matches !== null && $max_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_matches" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 1.');
        }
        
        if ($account_id !== null && $account_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$account_id" when calling AnalyticsApi.heroSynergiesStats, must be bigger than or equal to 0.');
        }
        
        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroSynergiesStats, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.heroSynergiesStats, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/hero-synergy-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $same_lane_filter,
            'same_lane_filter', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $same_party_filter,
            'same_party_filter', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_matches,
            'min_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_matches,
            'max_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'account_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation itemPermutationStats
     *
     * Item Permutation Stats
     *
     * @param  int[]|null $item_ids Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 2)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemPermutationStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ItemPermutationStats[]
     */
    public function itemPermutationStats($item_ids = null, $comb_size = 2, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['itemPermutationStats'][0])
    {
        list($response) = $this->itemPermutationStatsWithHttpInfo($item_ids, $comb_size, $hero_ids, $hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $account_id, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation itemPermutationStatsWithHttpInfo
     *
     * Item Permutation Stats
     *
     * @param  int[]|null $item_ids Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 2)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemPermutationStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ItemPermutationStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function itemPermutationStatsWithHttpInfo($item_ids = null, $comb_size = 2, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['itemPermutationStats'][0])
    {
        $request = $this->itemPermutationStatsRequest($item_ids, $comb_size, $hero_ids, $hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $account_id, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ItemPermutationStats[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ItemPermutationStats[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ItemPermutationStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation itemPermutationStatsAsync
     *
     * Item Permutation Stats
     *
     * @param  int[]|null $item_ids Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 2)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemPermutationStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function itemPermutationStatsAsync($item_ids = null, $comb_size = 2, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['itemPermutationStats'][0])
    {
        return $this->itemPermutationStatsAsyncWithHttpInfo($item_ids, $comb_size, $hero_ids, $hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $account_id, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation itemPermutationStatsAsyncWithHttpInfo
     *
     * Item Permutation Stats
     *
     * @param  int[]|null $item_ids Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 2)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemPermutationStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function itemPermutationStatsAsyncWithHttpInfo($item_ids = null, $comb_size = 2, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['itemPermutationStats'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ItemPermutationStats[]';
        $request = $this->itemPermutationStatsRequest($item_ids, $comb_size, $hero_ids, $hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $account_id, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'itemPermutationStats'
     *
     * @param  int[]|null $item_ids Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $comb_size The combination size to return. (optional, default to 2)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemPermutationStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function itemPermutationStatsRequest($item_ids = null, $comb_size = 2, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $account_id = null, $account_ids = null, string $contentType = self::contentTypes['itemPermutationStats'][0])
    {


        if ($comb_size !== null && $comb_size > 12) {
            throw new \InvalidArgumentException('invalid value for "$comb_size" when calling AnalyticsApi.itemPermutationStats, must be smaller than or equal to 12.');
        }
        if ($comb_size !== null && $comb_size < 2) {
            throw new \InvalidArgumentException('invalid value for "$comb_size" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 2.');
        }
        

        if ($hero_id !== null && $hero_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$hero_id" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        


        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.itemPermutationStats, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.itemPermutationStats, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.itemPermutationStats, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.itemPermutationStats, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        
        if ($account_id !== null && $account_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$account_id" when calling AnalyticsApi.itemPermutationStats, must be bigger than or equal to 0.');
        }
        
        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.itemPermutationStats, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.itemPermutationStats, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/item-permutation-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item_ids,
            'item_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comb_size,
            'comb_size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_ids,
            'hero_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_id,
            'hero_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'account_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation itemStats
     *
     * Item Stats
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for an item to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  int|null $min_bought_at_s Filter items bought after this game time (seconds). (optional)
     * @param  int|null $max_bought_at_s Filter items bought before this game time (seconds). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ItemStats[]
     */
    public function itemStats($bucket = null, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_item_ids = null, $exclude_item_ids = null, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, $min_bought_at_s = null, $max_bought_at_s = null, string $contentType = self::contentTypes['itemStats'][0])
    {
        list($response) = $this->itemStatsWithHttpInfo($bucket, $hero_ids, $hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $include_item_ids, $exclude_item_ids, $min_matches, $max_matches, $account_id, $account_ids, $min_bought_at_s, $max_bought_at_s, $contentType);
        return $response;
    }

    /**
     * Operation itemStatsWithHttpInfo
     *
     * Item Stats
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for an item to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  int|null $min_bought_at_s Filter items bought after this game time (seconds). (optional)
     * @param  int|null $max_bought_at_s Filter items bought before this game time (seconds). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ItemStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function itemStatsWithHttpInfo($bucket = null, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_item_ids = null, $exclude_item_ids = null, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, $min_bought_at_s = null, $max_bought_at_s = null, string $contentType = self::contentTypes['itemStats'][0])
    {
        $request = $this->itemStatsRequest($bucket, $hero_ids, $hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $include_item_ids, $exclude_item_ids, $min_matches, $max_matches, $account_id, $account_ids, $min_bought_at_s, $max_bought_at_s, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\ItemStats[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\ItemStats[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ItemStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation itemStatsAsync
     *
     * Item Stats
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for an item to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  int|null $min_bought_at_s Filter items bought after this game time (seconds). (optional)
     * @param  int|null $max_bought_at_s Filter items bought before this game time (seconds). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function itemStatsAsync($bucket = null, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_item_ids = null, $exclude_item_ids = null, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, $min_bought_at_s = null, $max_bought_at_s = null, string $contentType = self::contentTypes['itemStats'][0])
    {
        return $this->itemStatsAsyncWithHttpInfo($bucket, $hero_ids, $hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $include_item_ids, $exclude_item_ids, $min_matches, $max_matches, $account_id, $account_ids, $min_bought_at_s, $max_bought_at_s, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation itemStatsAsyncWithHttpInfo
     *
     * Item Stats
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for an item to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  int|null $min_bought_at_s Filter items bought after this game time (seconds). (optional)
     * @param  int|null $max_bought_at_s Filter items bought before this game time (seconds). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function itemStatsAsyncWithHttpInfo($bucket = null, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_item_ids = null, $exclude_item_ids = null, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, $min_bought_at_s = null, $max_bought_at_s = null, string $contentType = self::contentTypes['itemStats'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ItemStats[]';
        $request = $this->itemStatsRequest($bucket, $hero_ids, $hero_id, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $include_item_ids, $exclude_item_ids, $min_matches, $max_matches, $account_id, $account_ids, $min_bought_at_s, $max_bought_at_s, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'itemStats'
     *
     * @param  string|null $bucket Bucket allows you to group the stats by a specific field. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional) (deprecated)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for an item to be included in the response. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $account_id Filter for matches with a specific player account ID. (optional) (deprecated)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  int|null $min_bought_at_s Filter items bought after this game time (seconds). (optional)
     * @param  int|null $max_bought_at_s Filter items bought before this game time (seconds). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['itemStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function itemStatsRequest($bucket = null, $hero_ids = null, $hero_id = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $include_item_ids = null, $exclude_item_ids = null, $min_matches = 20, $max_matches = null, $account_id = null, $account_ids = null, $min_bought_at_s = null, $max_bought_at_s = null, string $contentType = self::contentTypes['itemStats'][0])
    {



        if ($hero_id !== null && $hero_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$hero_id" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        


        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.itemStats, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.itemStats, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.itemStats, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.itemStats, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        


        if ($min_matches !== null && $min_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$min_matches" when calling AnalyticsApi.itemStats, must be bigger than or equal to 1.');
        }
        
        if ($max_matches !== null && $max_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_matches" when calling AnalyticsApi.itemStats, must be bigger than or equal to 1.');
        }
        
        if ($account_id !== null && $account_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$account_id" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        
        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.itemStats, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.itemStats, number of items must be greater than or equal to 1.');
        }
        
        if ($min_bought_at_s !== null && $min_bought_at_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_bought_at_s" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        
        if ($max_bought_at_s !== null && $max_bought_at_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_bought_at_s" when calling AnalyticsApi.itemStats, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/v1/analytics/item-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bucket,
            'bucket', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_ids,
            'hero_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_id,
            'hero_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_item_ids,
            'include_item_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_item_ids,
            'exclude_item_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_matches,
            'min_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_matches,
            'max_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_id,
            'account_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_bought_at_s,
            'min_bought_at_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_bought_at_s,
            'max_bought_at_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation killDeathStats
     *
     * Kill Death Stats
     *
     * @param  int|null $team Filter by team number. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int[]|null $account_ids Filter matches by account IDs of players that participated in the match. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_kills_per_raster Filter Raster cells based on minimum kills. (optional)
     * @param  int|null $max_kills_per_raster Filter Raster cells based on maximum kills. (optional)
     * @param  int|null $min_deaths_per_raster Filter Raster cells based on minimum deaths. (optional)
     * @param  int|null $max_deaths_per_raster Filter Raster cells based on maximum deaths. (optional)
     * @param  int|null $min_game_time_s Filter kills based on their game time. (optional)
     * @param  int|null $max_game_time_s Filter kills based on their game time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['killDeathStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\KillDeathStats[]
     */
    public function killDeathStats($team = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $account_ids = null, $hero_ids = null, $min_networth = null, $max_networth = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, $min_average_badge = null, $max_average_badge = null, $min_kills_per_raster = null, $max_kills_per_raster = null, $min_deaths_per_raster = null, $max_deaths_per_raster = null, $min_game_time_s = null, $max_game_time_s = null, string $contentType = self::contentTypes['killDeathStats'][0])
    {
        list($response) = $this->killDeathStatsWithHttpInfo($team, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $account_ids, $hero_ids, $min_networth, $max_networth, $is_high_skill_range_parties, $is_low_pri_pool, $is_new_player_pool, $min_match_id, $max_match_id, $min_average_badge, $max_average_badge, $min_kills_per_raster, $max_kills_per_raster, $min_deaths_per_raster, $max_deaths_per_raster, $min_game_time_s, $max_game_time_s, $contentType);
        return $response;
    }

    /**
     * Operation killDeathStatsWithHttpInfo
     *
     * Kill Death Stats
     *
     * @param  int|null $team Filter by team number. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int[]|null $account_ids Filter matches by account IDs of players that participated in the match. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_kills_per_raster Filter Raster cells based on minimum kills. (optional)
     * @param  int|null $max_kills_per_raster Filter Raster cells based on maximum kills. (optional)
     * @param  int|null $min_deaths_per_raster Filter Raster cells based on minimum deaths. (optional)
     * @param  int|null $max_deaths_per_raster Filter Raster cells based on maximum deaths. (optional)
     * @param  int|null $min_game_time_s Filter kills based on their game time. (optional)
     * @param  int|null $max_game_time_s Filter kills based on their game time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['killDeathStats'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\KillDeathStats[], HTTP status code, HTTP response headers (array of strings)
     */
    public function killDeathStatsWithHttpInfo($team = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $account_ids = null, $hero_ids = null, $min_networth = null, $max_networth = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, $min_average_badge = null, $max_average_badge = null, $min_kills_per_raster = null, $max_kills_per_raster = null, $min_deaths_per_raster = null, $max_deaths_per_raster = null, $min_game_time_s = null, $max_game_time_s = null, string $contentType = self::contentTypes['killDeathStats'][0])
    {
        $request = $this->killDeathStatsRequest($team, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $account_ids, $hero_ids, $min_networth, $max_networth, $is_high_skill_range_parties, $is_low_pri_pool, $is_new_player_pool, $min_match_id, $max_match_id, $min_average_badge, $max_average_badge, $min_kills_per_raster, $max_kills_per_raster, $min_deaths_per_raster, $max_deaths_per_raster, $min_game_time_s, $max_game_time_s, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\KillDeathStats[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\KillDeathStats[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\KillDeathStats[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation killDeathStatsAsync
     *
     * Kill Death Stats
     *
     * @param  int|null $team Filter by team number. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int[]|null $account_ids Filter matches by account IDs of players that participated in the match. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_kills_per_raster Filter Raster cells based on minimum kills. (optional)
     * @param  int|null $max_kills_per_raster Filter Raster cells based on maximum kills. (optional)
     * @param  int|null $min_deaths_per_raster Filter Raster cells based on minimum deaths. (optional)
     * @param  int|null $max_deaths_per_raster Filter Raster cells based on maximum deaths. (optional)
     * @param  int|null $min_game_time_s Filter kills based on their game time. (optional)
     * @param  int|null $max_game_time_s Filter kills based on their game time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['killDeathStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function killDeathStatsAsync($team = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $account_ids = null, $hero_ids = null, $min_networth = null, $max_networth = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, $min_average_badge = null, $max_average_badge = null, $min_kills_per_raster = null, $max_kills_per_raster = null, $min_deaths_per_raster = null, $max_deaths_per_raster = null, $min_game_time_s = null, $max_game_time_s = null, string $contentType = self::contentTypes['killDeathStats'][0])
    {
        return $this->killDeathStatsAsyncWithHttpInfo($team, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $account_ids, $hero_ids, $min_networth, $max_networth, $is_high_skill_range_parties, $is_low_pri_pool, $is_new_player_pool, $min_match_id, $max_match_id, $min_average_badge, $max_average_badge, $min_kills_per_raster, $max_kills_per_raster, $min_deaths_per_raster, $max_deaths_per_raster, $min_game_time_s, $max_game_time_s, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation killDeathStatsAsyncWithHttpInfo
     *
     * Kill Death Stats
     *
     * @param  int|null $team Filter by team number. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int[]|null $account_ids Filter matches by account IDs of players that participated in the match. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_kills_per_raster Filter Raster cells based on minimum kills. (optional)
     * @param  int|null $max_kills_per_raster Filter Raster cells based on maximum kills. (optional)
     * @param  int|null $min_deaths_per_raster Filter Raster cells based on minimum deaths. (optional)
     * @param  int|null $max_deaths_per_raster Filter Raster cells based on maximum deaths. (optional)
     * @param  int|null $min_game_time_s Filter kills based on their game time. (optional)
     * @param  int|null $max_game_time_s Filter kills based on their game time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['killDeathStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function killDeathStatsAsyncWithHttpInfo($team = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $account_ids = null, $hero_ids = null, $min_networth = null, $max_networth = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, $min_average_badge = null, $max_average_badge = null, $min_kills_per_raster = null, $max_kills_per_raster = null, $min_deaths_per_raster = null, $max_deaths_per_raster = null, $min_game_time_s = null, $max_game_time_s = null, string $contentType = self::contentTypes['killDeathStats'][0])
    {
        $returnType = '\OpenAPI\Client\Model\KillDeathStats[]';
        $request = $this->killDeathStatsRequest($team, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $account_ids, $hero_ids, $min_networth, $max_networth, $is_high_skill_range_parties, $is_low_pri_pool, $is_new_player_pool, $min_match_id, $max_match_id, $min_average_badge, $max_average_badge, $min_kills_per_raster, $max_kills_per_raster, $min_deaths_per_raster, $max_deaths_per_raster, $min_game_time_s, $max_game_time_s, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'killDeathStats'
     *
     * @param  int|null $team Filter by team number. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int[]|null $account_ids Filter matches by account IDs of players that participated in the match. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  bool|null $is_high_skill_range_parties Filter matches based on whether they are in the high skill range. (optional)
     * @param  bool|null $is_low_pri_pool Filter matches based on whether they are in the low priority pool. (optional)
     * @param  bool|null $is_new_player_pool Filter matches based on whether they are in the new player pool. (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_kills_per_raster Filter Raster cells based on minimum kills. (optional)
     * @param  int|null $max_kills_per_raster Filter Raster cells based on maximum kills. (optional)
     * @param  int|null $min_deaths_per_raster Filter Raster cells based on minimum deaths. (optional)
     * @param  int|null $max_deaths_per_raster Filter Raster cells based on maximum deaths. (optional)
     * @param  int|null $min_game_time_s Filter kills based on their game time. (optional)
     * @param  int|null $max_game_time_s Filter kills based on their game time. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['killDeathStats'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function killDeathStatsRequest($team = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $account_ids = null, $hero_ids = null, $min_networth = null, $max_networth = null, $is_high_skill_range_parties = null, $is_low_pri_pool = null, $is_new_player_pool = null, $min_match_id = null, $max_match_id = null, $min_average_badge = null, $max_average_badge = null, $min_kills_per_raster = null, $max_kills_per_raster = null, $min_deaths_per_raster = null, $max_deaths_per_raster = null, $min_game_time_s = null, $max_game_time_s = null, string $contentType = self::contentTypes['killDeathStats'][0])
    {

        if ($team !== null && $team > 1) {
            throw new \InvalidArgumentException('invalid value for "$team" when calling AnalyticsApi.killDeathStats, must be smaller than or equal to 1.');
        }
        if ($team !== null && $team < 0) {
            throw new \InvalidArgumentException('invalid value for "$team" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        


        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.killDeathStats, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.killDeathStats, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        


        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        



        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.killDeathStats, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.killDeathStats, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($min_kills_per_raster !== null && $min_kills_per_raster < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_kills_per_raster" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($max_kills_per_raster !== null && $max_kills_per_raster < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_kills_per_raster" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($min_deaths_per_raster !== null && $min_deaths_per_raster < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_deaths_per_raster" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($max_deaths_per_raster !== null && $max_deaths_per_raster < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_deaths_per_raster" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($min_game_time_s !== null && $min_game_time_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_game_time_s" when calling AnalyticsApi.killDeathStats, must be smaller than or equal to 7000.');
        }
        if ($min_game_time_s !== null && $min_game_time_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_game_time_s" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        
        if ($max_game_time_s !== null && $max_game_time_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_game_time_s" when calling AnalyticsApi.killDeathStats, must be smaller than or equal to 7000.');
        }
        if ($max_game_time_s !== null && $max_game_time_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_game_time_s" when calling AnalyticsApi.killDeathStats, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/v1/analytics/kill-death-stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $team,
            'team', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_ids,
            'hero_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_high_skill_range_parties,
            'is_high_skill_range_parties', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_low_pri_pool,
            'is_low_pri_pool', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_new_player_pool,
            'is_new_player_pool', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_kills_per_raster,
            'min_kills_per_raster', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_kills_per_raster,
            'max_kills_per_raster', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_deaths_per_raster,
            'min_deaths_per_raster', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_deaths_per_raster,
            'max_deaths_per_raster', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_game_time_s,
            'min_game_time_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_game_time_s,
            'max_game_time_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation playerPerformanceCurve
     *
     * Player Performance Curve
     *
     * @param  int|null $resolution Resolution for relative game times in percent (0-100). **Default:** 10 (buckets of 10%). Set to **0** to use absolute game time (seconds). (optional, default to 10)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerPerformanceCurve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PlayerPerformanceCurvePoint[]
     */
    public function playerPerformanceCurve($resolution = 10, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $hero_ids = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerPerformanceCurve'][0])
    {
        list($response) = $this->playerPerformanceCurveWithHttpInfo($resolution, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $hero_ids, $include_item_ids, $exclude_item_ids, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation playerPerformanceCurveWithHttpInfo
     *
     * Player Performance Curve
     *
     * @param  int|null $resolution Resolution for relative game times in percent (0-100). **Default:** 10 (buckets of 10%). Set to **0** to use absolute game time (seconds). (optional, default to 10)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerPerformanceCurve'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PlayerPerformanceCurvePoint[], HTTP status code, HTTP response headers (array of strings)
     */
    public function playerPerformanceCurveWithHttpInfo($resolution = 10, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $hero_ids = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerPerformanceCurve'][0])
    {
        $request = $this->playerPerformanceCurveRequest($resolution, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $hero_ids, $include_item_ids, $exclude_item_ids, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\PlayerPerformanceCurvePoint[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\PlayerPerformanceCurvePoint[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PlayerPerformanceCurvePoint[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation playerPerformanceCurveAsync
     *
     * Player Performance Curve
     *
     * @param  int|null $resolution Resolution for relative game times in percent (0-100). **Default:** 10 (buckets of 10%). Set to **0** to use absolute game time (seconds). (optional, default to 10)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerPerformanceCurve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playerPerformanceCurveAsync($resolution = 10, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $hero_ids = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerPerformanceCurve'][0])
    {
        return $this->playerPerformanceCurveAsyncWithHttpInfo($resolution, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $hero_ids, $include_item_ids, $exclude_item_ids, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playerPerformanceCurveAsyncWithHttpInfo
     *
     * Player Performance Curve
     *
     * @param  int|null $resolution Resolution for relative game times in percent (0-100). **Default:** 10 (buckets of 10%). Set to **0** to use absolute game time (seconds). (optional, default to 10)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerPerformanceCurve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playerPerformanceCurveAsyncWithHttpInfo($resolution = 10, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $hero_ids = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerPerformanceCurve'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PlayerPerformanceCurvePoint[]';
        $request = $this->playerPerformanceCurveRequest($resolution, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $hero_ids, $include_item_ids, $exclude_item_ids, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playerPerformanceCurve'
     *
     * @param  int|null $resolution Resolution for relative game times in percent (0-100). **Default:** 10 (buckets of 10%). Set to **0** to use absolute game time (seconds). (optional, default to 10)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerPerformanceCurve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playerPerformanceCurveRequest($resolution = 10, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $hero_ids = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerPerformanceCurve'][0])
    {

        if ($resolution !== null && $resolution > 100) {
            throw new \InvalidArgumentException('invalid value for "$resolution" when calling AnalyticsApi.playerPerformanceCurve, must be smaller than or equal to 100.');
        }
        if ($resolution !== null && $resolution < 0) {
            throw new \InvalidArgumentException('invalid value for "$resolution" when calling AnalyticsApi.playerPerformanceCurve, must be bigger than or equal to 0.');
        }
        


        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.playerPerformanceCurve, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.playerPerformanceCurve, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.playerPerformanceCurve, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.playerPerformanceCurve, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.playerPerformanceCurve, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.playerPerformanceCurve, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.playerPerformanceCurve, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.playerPerformanceCurve, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.playerPerformanceCurve, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.playerPerformanceCurve, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.playerPerformanceCurve, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.playerPerformanceCurve, must be bigger than or equal to 0.');
        }
        



        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.playerPerformanceCurve, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.playerPerformanceCurve, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/player-performance-curve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $resolution,
            'resolution', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_ids,
            'hero_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_item_ids,
            'include_item_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_item_ids,
            'exclude_item_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation playerScoreboard
     *
     * Player Scoreboard
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort players in. (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $start The offset to start fetching players from. (optional)
     * @param  int|null $limit The maximum number of players to fetch. (optional, default to 100)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerScoreboard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Entry[]
     */
    public function playerScoreboard($sort_by, $sort_direction = null, $hero_id = null, $min_matches = 20, $max_matches = null, $min_unix_timestamp = null, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $start = null, $limit = 100, $account_ids = null, string $contentType = self::contentTypes['playerScoreboard'][0])
    {
        list($response) = $this->playerScoreboardWithHttpInfo($sort_by, $sort_direction, $hero_id, $min_matches, $max_matches, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $start, $limit, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation playerScoreboardWithHttpInfo
     *
     * Player Scoreboard
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort players in. (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $start The offset to start fetching players from. (optional)
     * @param  int|null $limit The maximum number of players to fetch. (optional, default to 100)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerScoreboard'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Entry[], HTTP status code, HTTP response headers (array of strings)
     */
    public function playerScoreboardWithHttpInfo($sort_by, $sort_direction = null, $hero_id = null, $min_matches = 20, $max_matches = null, $min_unix_timestamp = null, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $start = null, $limit = 100, $account_ids = null, string $contentType = self::contentTypes['playerScoreboard'][0])
    {
        $request = $this->playerScoreboardRequest($sort_by, $sort_direction, $hero_id, $min_matches, $max_matches, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $start, $limit, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\Entry[]',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\Entry[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Entry[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation playerScoreboardAsync
     *
     * Player Scoreboard
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort players in. (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $start The offset to start fetching players from. (optional)
     * @param  int|null $limit The maximum number of players to fetch. (optional, default to 100)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerScoreboard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playerScoreboardAsync($sort_by, $sort_direction = null, $hero_id = null, $min_matches = 20, $max_matches = null, $min_unix_timestamp = null, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $start = null, $limit = 100, $account_ids = null, string $contentType = self::contentTypes['playerScoreboard'][0])
    {
        return $this->playerScoreboardAsyncWithHttpInfo($sort_by, $sort_direction, $hero_id, $min_matches, $max_matches, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $start, $limit, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playerScoreboardAsyncWithHttpInfo
     *
     * Player Scoreboard
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort players in. (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $start The offset to start fetching players from. (optional)
     * @param  int|null $limit The maximum number of players to fetch. (optional, default to 100)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerScoreboard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playerScoreboardAsyncWithHttpInfo($sort_by, $sort_direction = null, $hero_id = null, $min_matches = 20, $max_matches = null, $min_unix_timestamp = null, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $start = null, $limit = 100, $account_ids = null, string $contentType = self::contentTypes['playerScoreboard'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Entry[]';
        $request = $this->playerScoreboardRequest($sort_by, $sort_direction, $hero_id, $min_matches, $max_matches, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $start, $limit, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playerScoreboard'
     *
     * @param  string $sort_by The field to sort by. (required)
     * @param  string|null $sort_direction The direction to sort players in. (optional)
     * @param  int|null $hero_id Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_matches The minimum number of matches played for a player to be included in the scoreboard. (optional, default to 20)
     * @param  int|null $max_matches The maximum number of matches played for a hero combination to be included in the response. (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $start The offset to start fetching players from. (optional)
     * @param  int|null $limit The maximum number of players to fetch. (optional, default to 100)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerScoreboard'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playerScoreboardRequest($sort_by, $sort_direction = null, $hero_id = null, $min_matches = 20, $max_matches = null, $min_unix_timestamp = null, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $start = null, $limit = 100, $account_ids = null, string $contentType = self::contentTypes['playerScoreboard'][0])
    {

        // verify the required parameter 'sort_by' is set
        if ($sort_by === null || (is_array($sort_by) && count($sort_by) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sort_by when calling playerScoreboard'
            );
        }


        if ($hero_id !== null && $hero_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$hero_id" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($min_matches !== null && $min_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$min_matches" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 1.');
        }
        
        if ($max_matches !== null && $max_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_matches" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 1.');
        }
        


        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.playerScoreboard, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.playerScoreboard, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.playerScoreboard, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.playerScoreboard, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($start !== null && $start < 0) {
            throw new \InvalidArgumentException('invalid value for "$start" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 0.');
        }
        
        if ($limit !== null && $limit > 10000) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling AnalyticsApi.playerScoreboard, must be smaller than or equal to 10000.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling AnalyticsApi.playerScoreboard, must be bigger than or equal to 1.');
        }
        
        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.playerScoreboard, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.playerScoreboard, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/scoreboards/players';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by,
            'sort_by', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_direction,
            'sort_direction', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_id,
            'hero_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_matches,
            'min_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_matches,
            'max_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start,
            'start', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation playerStatsMetrics
     *
     * Player Stats Metrics
     *
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_matches The maximum number of matches to analyze. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerStatsMetrics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array<string,\OpenAPI\Client\Model\HashMapValue>
     */
    public function playerStatsMetrics($hero_ids = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $max_matches = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerStatsMetrics'][0])
    {
        list($response) = $this->playerStatsMetricsWithHttpInfo($hero_ids, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $max_matches, $include_item_ids, $exclude_item_ids, $account_ids, $contentType);
        return $response;
    }

    /**
     * Operation playerStatsMetricsWithHttpInfo
     *
     * Player Stats Metrics
     *
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_matches The maximum number of matches to analyze. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerStatsMetrics'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of array<string,\OpenAPI\Client\Model\HashMapValue>, HTTP status code, HTTP response headers (array of strings)
     */
    public function playerStatsMetricsWithHttpInfo($hero_ids = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $max_matches = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerStatsMetrics'][0])
    {
        $request = $this->playerStatsMetricsRequest($hero_ids, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $max_matches, $include_item_ids, $exclude_item_ids, $account_ids, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        'array<string,\OpenAPI\Client\Model\HashMapValue>',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'array<string,\OpenAPI\Client\Model\HashMapValue>',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,\OpenAPI\Client\Model\HashMapValue>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation playerStatsMetricsAsync
     *
     * Player Stats Metrics
     *
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_matches The maximum number of matches to analyze. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerStatsMetrics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playerStatsMetricsAsync($hero_ids = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $max_matches = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerStatsMetrics'][0])
    {
        return $this->playerStatsMetricsAsyncWithHttpInfo($hero_ids, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $max_matches, $include_item_ids, $exclude_item_ids, $account_ids, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation playerStatsMetricsAsyncWithHttpInfo
     *
     * Player Stats Metrics
     *
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_matches The maximum number of matches to analyze. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerStatsMetrics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function playerStatsMetricsAsyncWithHttpInfo($hero_ids = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $max_matches = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerStatsMetrics'][0])
    {
        $returnType = 'array<string,\OpenAPI\Client\Model\HashMapValue>';
        $request = $this->playerStatsMetricsRequest($hero_ids, $min_unix_timestamp, $max_unix_timestamp, $min_duration_s, $max_duration_s, $min_networth, $max_networth, $min_average_badge, $max_average_badge, $min_match_id, $max_match_id, $max_matches, $include_item_ids, $exclude_item_ids, $account_ids, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'playerStatsMetrics'
     *
     * @param  string|null $hero_ids Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt; (optional)
     * @param  int|null $min_unix_timestamp Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago. (optional, default to 1766275200)
     * @param  int|null $max_unix_timestamp Filter matches based on their start time (Unix timestamp). (optional)
     * @param  int|null $min_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $max_duration_s Filter matches based on their duration in seconds (up to 7000s). (optional)
     * @param  int|null $min_networth Filter players based on their final net worth. (optional)
     * @param  int|null $max_networth Filter players based on their final net worth. (optional)
     * @param  int|null $min_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $max_average_badge Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt; (optional)
     * @param  int|null $min_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_match_id Filter matches based on their ID. (optional)
     * @param  int|null $max_matches The maximum number of matches to analyze. (optional)
     * @param  int[]|null $include_item_ids Comma separated list of item ids to include (only players who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $exclude_item_ids Comma separated list of item ids to exclude (only players who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt; (optional)
     * @param  int[]|null $account_ids Comma separated list of account ids to include (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['playerStatsMetrics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function playerStatsMetricsRequest($hero_ids = null, $min_unix_timestamp = 1766275200, $max_unix_timestamp = null, $min_duration_s = null, $max_duration_s = null, $min_networth = null, $max_networth = null, $min_average_badge = null, $max_average_badge = null, $min_match_id = null, $max_match_id = null, $max_matches = null, $include_item_ids = null, $exclude_item_ids = null, $account_ids = null, string $contentType = self::contentTypes['playerStatsMetrics'][0])
    {




        if ($min_duration_s !== null && $min_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.playerStatsMetrics, must be smaller than or equal to 7000.');
        }
        if ($min_duration_s !== null && $min_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_duration_s" when calling AnalyticsApi.playerStatsMetrics, must be bigger than or equal to 0.');
        }
        
        if ($max_duration_s !== null && $max_duration_s > 7000) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.playerStatsMetrics, must be smaller than or equal to 7000.');
        }
        if ($max_duration_s !== null && $max_duration_s < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_duration_s" when calling AnalyticsApi.playerStatsMetrics, must be bigger than or equal to 0.');
        }
        
        if ($min_networth !== null && $min_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_networth" when calling AnalyticsApi.playerStatsMetrics, must be bigger than or equal to 0.');
        }
        
        if ($max_networth !== null && $max_networth < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_networth" when calling AnalyticsApi.playerStatsMetrics, must be bigger than or equal to 0.');
        }
        
        if ($min_average_badge !== null && $min_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.playerStatsMetrics, must be smaller than or equal to 116.');
        }
        if ($min_average_badge !== null && $min_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_average_badge" when calling AnalyticsApi.playerStatsMetrics, must be bigger than or equal to 0.');
        }
        
        if ($max_average_badge !== null && $max_average_badge > 116) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.playerStatsMetrics, must be smaller than or equal to 116.');
        }
        if ($max_average_badge !== null && $max_average_badge < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_average_badge" when calling AnalyticsApi.playerStatsMetrics, must be bigger than or equal to 0.');
        }
        
        if ($min_match_id !== null && $min_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$min_match_id" when calling AnalyticsApi.playerStatsMetrics, must be bigger than or equal to 0.');
        }
        
        if ($max_match_id !== null && $max_match_id < 0) {
            throw new \InvalidArgumentException('invalid value for "$max_match_id" when calling AnalyticsApi.playerStatsMetrics, must be bigger than or equal to 0.');
        }
        
        if ($max_matches !== null && $max_matches < 1) {
            throw new \InvalidArgumentException('invalid value for "$max_matches" when calling AnalyticsApi.playerStatsMetrics, must be bigger than or equal to 1.');
        }
        


        if ($account_ids !== null && count($account_ids) > 1000) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.playerStatsMetrics, number of items must be less than or equal to 1000.');
        }
        if ($account_ids !== null && count($account_ids) < 1) {
            throw new \InvalidArgumentException('invalid value for "$account_ids" when calling AnalyticsApi.playerStatsMetrics, number of items must be greater than or equal to 1.');
        }
        

        $resourcePath = '/v1/analytics/player-stats/metrics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hero_ids,
            'hero_ids', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_unix_timestamp,
            'min_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_unix_timestamp,
            'max_unix_timestamp', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_duration_s,
            'min_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_duration_s,
            'max_duration_s', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_networth,
            'min_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_networth,
            'max_networth', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_average_badge,
            'min_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_average_badge,
            'max_average_badge', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $min_match_id,
            'min_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_match_id,
            'max_match_id', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_matches,
            'max_matches', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_item_ids,
            'include_item_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $exclude_item_ids,
            'exclude_item_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $account_ids,
            'account_ids', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
