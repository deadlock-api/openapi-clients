/* tslint:disable */
/* eslint-disable */
/**
 * Deadlock API
 *  ## Support the Deadlock API  Whether you\'re building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface APIInfo
 */
export interface APIInfo {
    /**
     * The number of matches fetched in the last 24 hours.
     * @type {number}
     * @memberof APIInfo
     */
    'fetched_matches_per_day'?: number | null;
    /**
     * The number of matches that have not been fetched.
     * @type {number}
     * @memberof APIInfo
     */
    'missed_matches'?: number | null;
    /**
     * The sizes of all tables in the database.
     * @type {{ [key: string]: TableSize; }}
     * @memberof APIInfo
     */
    'table_sizes'?: { [key: string]: TableSize; };
}
/**
 * 
 * @export
 * @interface ActiveMatch
 */
export interface ActiveMatch {
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'compat_version'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'duration_s'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'game_mode'?: number | null;
    /**
     * 
     * @type {ActiveMatchGameMode}
     * @memberof ActiveMatch
     */
    'game_mode_parsed'?: ActiveMatchGameMode | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'game_mode_version'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'lobby_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'match_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'match_mode'?: number | null;
    /**
     * 
     * @type {ActiveMatchMode}
     * @memberof ActiveMatch
     */
    'match_mode_parsed'?: ActiveMatchMode | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'match_score'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'net_worth_team_0'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'net_worth_team_1'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'objectives_mask_team0'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'objectives_mask_team1'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'open_spectator_slots'?: number | null;
    /**
     * 
     * @type {Array<ActiveMatchPlayer>}
     * @memberof ActiveMatch
     */
    'players': Array<ActiveMatchPlayer>;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'region_mode'?: number | null;
    /**
     * 
     * @type {ActiveMatchRegionMode}
     * @memberof ActiveMatch
     */
    'region_mode_parsed'?: ActiveMatchRegionMode | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'spectators'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'start_time'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatch
     */
    'winning_team'?: number | null;
    /**
     * 
     * @type {ActiveMatchTeam}
     * @memberof ActiveMatch
     */
    'winning_team_parsed'?: ActiveMatchTeam | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ActiveMatchGameMode = {
    KeCitadelGameModeInvalid: 'KECitadelGameModeInvalid',
    KeCitadelGameModeNormal: 'KECitadelGameModeNormal',
    KeCitadelGameMode1v1Test: 'KECitadelGameMode1v1Test',
    KeCitadelGameModeSandbox: 'KECitadelGameModeSandbox'
} as const;

export type ActiveMatchGameMode = typeof ActiveMatchGameMode[keyof typeof ActiveMatchGameMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const ActiveMatchMode = {
    Invalid: 'Invalid',
    Unranked: 'Unranked',
    PrivateLobby: 'PrivateLobby',
    CoopBot: 'CoopBot',
    Ranked: 'Ranked',
    ServerTest: 'ServerTest',
    Tutorial: 'Tutorial',
    HeroLabs: 'HeroLabs'
} as const;

export type ActiveMatchMode = typeof ActiveMatchMode[keyof typeof ActiveMatchMode];


/**
 * 
 * @export
 * @interface ActiveMatchPlayer
 */
export interface ActiveMatchPlayer {
    /**
     * 
     * @type {boolean}
     * @memberof ActiveMatchPlayer
     */
    'abandoned'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatchPlayer
     */
    'account_id'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {number}
     * @memberof ActiveMatchPlayer
     */
    'hero_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ActiveMatchPlayer
     */
    'team'?: number | null;
    /**
     * 
     * @type {ActiveMatchTeam}
     * @memberof ActiveMatchPlayer
     */
    'team_parsed'?: ActiveMatchTeam | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ActiveMatchRegionMode = {
    Row: 'Row',
    Europe: 'Europe',
    SeAsia: 'SeAsia',
    SAmerica: 'SAmerica',
    Russia: 'Russia',
    Oceania: 'Oceania'
} as const;

export type ActiveMatchRegionMode = typeof ActiveMatchRegionMode[keyof typeof ActiveMatchRegionMode];


/**
 * 
 * @export
 * @enum {string}
 */

export const ActiveMatchTeam = {
    Team0: 'Team0',
    Team1: 'Team1',
    Spectator: 'Spectator'
} as const;

export type ActiveMatchTeam = typeof ActiveMatchTeam[keyof typeof ActiveMatchTeam];


/**
 * 
 * @export
 * @interface AnalyticsAbilityOrderStats
 */
export interface AnalyticsAbilityOrderStats {
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {Array<number>}
     * @memberof AnalyticsAbilityOrderStats
     */
    'abilities': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsAbilityOrderStats
     */
    'losses': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsAbilityOrderStats
     */
    'matches': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsAbilityOrderStats
     */
    'players': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsAbilityOrderStats
     */
    'total_assists': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsAbilityOrderStats
     */
    'total_deaths': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsAbilityOrderStats
     */
    'total_kills': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsAbilityOrderStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface AnalyticsHeroStats
 */
export interface AnalyticsHeroStats {
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'bucket'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'hero_id': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'losses': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'matches': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'matches_per_bucket': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'players': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_assists': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_boss_damage': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_creep_damage': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_deaths': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_denies': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_kills': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_last_hits': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_max_health': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_net_worth': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_neutral_damage': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_player_damage': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_player_damage_taken': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_shots_hit': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'total_shots_missed': number;
    /**
     * 
     * @type {number}
     * @memberof AnalyticsHeroStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface BadgeDistribution
 */
export interface BadgeDistribution {
    /**
     * The badge level. See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof BadgeDistribution
     */
    'badge_level': number;
    /**
     * The total number of matches.
     * @type {number}
     * @memberof BadgeDistribution
     */
    'total_matches': number;
}
/**
 * 
 * @export
 * @interface Build
 */
export interface Build {
    /**
     * 
     * @type {BuildHero}
     * @memberof Build
     */
    'hero_build': BuildHero;
    /**
     * 
     * @type {number}
     * @memberof Build
     */
    'num_favorites'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Build
     */
    'num_ignores'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Build
     */
    'num_reports'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Build
     */
    'num_weekly_favorites'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Build
     */
    'rollup_category'?: number | null;
}
/**
 * 
 * @export
 * @interface BuildHero
 */
export interface BuildHero {
    /**
     * 
     * @type {number}
     * @memberof BuildHero
     */
    'author_account_id': number;
    /**
     * 
     * @type {string}
     * @memberof BuildHero
     */
    'description'?: string | null;
    /**
     * 
     * @type {BuildHeroDetails}
     * @memberof BuildHero
     */
    'details': BuildHeroDetails;
    /**
     * 
     * @type {boolean}
     * @memberof BuildHero
     */
    'development_build'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof BuildHero
     */
    'hero_build_id': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {number}
     * @memberof BuildHero
     */
    'hero_id': number;
    /**
     * 
     * @type {number}
     * @memberof BuildHero
     */
    'language': number;
    /**
     * 
     * @type {number}
     * @memberof BuildHero
     */
    'last_updated_timestamp'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof BuildHero
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof BuildHero
     */
    'origin_build_id': number;
    /**
     * 
     * @type {number}
     * @memberof BuildHero
     */
    'publish_timestamp'?: number | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof BuildHero
     */
    'tags'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof BuildHero
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface BuildHeroDetails
 */
export interface BuildHeroDetails {
    /**
     * 
     * @type {BuildHeroDetailsAbilityOrder}
     * @memberof BuildHeroDetails
     */
    'ability_order'?: BuildHeroDetailsAbilityOrder | null;
    /**
     * 
     * @type {Array<BuildHeroDetailsCategory>}
     * @memberof BuildHeroDetails
     */
    'mod_categories': Array<BuildHeroDetailsCategory>;
}
/**
 * 
 * @export
 * @interface BuildHeroDetailsAbilityOrder
 */
export interface BuildHeroDetailsAbilityOrder {
    /**
     * 
     * @type {Array<BuildHeroDetailsAbilityOrderCurrencyChange>}
     * @memberof BuildHeroDetailsAbilityOrder
     */
    'currency_changes'?: Array<BuildHeroDetailsAbilityOrderCurrencyChange> | null;
}
/**
 * 
 * @export
 * @interface BuildHeroDetailsAbilityOrderCurrencyChange
 */
export interface BuildHeroDetailsAbilityOrderCurrencyChange {
    /**
     * 
     * @type {number}
     * @memberof BuildHeroDetailsAbilityOrderCurrencyChange
     */
    'ability_id': number;
    /**
     * 
     * @type {string}
     * @memberof BuildHeroDetailsAbilityOrderCurrencyChange
     */
    'annotation'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BuildHeroDetailsAbilityOrderCurrencyChange
     */
    'currency_type': number;
    /**
     * 
     * @type {number}
     * @memberof BuildHeroDetailsAbilityOrderCurrencyChange
     */
    'delta': number;
}
/**
 * 
 * @export
 * @interface BuildHeroDetailsCategory
 */
export interface BuildHeroDetailsCategory {
    /**
     * 
     * @type {string}
     * @memberof BuildHeroDetailsCategory
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BuildHeroDetailsCategory
     */
    'height'?: number | null;
    /**
     * 
     * @type {Array<BuildHeroDetailsCategoryAbility>}
     * @memberof BuildHeroDetailsCategory
     */
    'mods'?: Array<BuildHeroDetailsCategoryAbility> | null;
    /**
     * 
     * @type {string}
     * @memberof BuildHeroDetailsCategory
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof BuildHeroDetailsCategory
     */
    'optional'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof BuildHeroDetailsCategory
     */
    'width'?: number | null;
}
/**
 * 
 * @export
 * @interface BuildHeroDetailsCategoryAbility
 */
export interface BuildHeroDetailsCategoryAbility {
    /**
     * 
     * @type {number}
     * @memberof BuildHeroDetailsCategoryAbility
     */
    'ability_id': number;
    /**
     * 
     * @type {string}
     * @memberof BuildHeroDetailsCategoryAbility
     */
    'annotation'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BuildHeroDetailsCategoryAbility
     */
    'imbue_target_ability_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BuildHeroDetailsCategoryAbility
     */
    'required_flex_slots'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BuildHeroDetailsCategoryAbility
     */
    'sell_priority'?: number | null;
}
/**
 * 
 * @export
 * @interface BuildItemStats
 */
export interface BuildItemStats {
    /**
     * 
     * @type {number}
     * @memberof BuildItemStats
     */
    'builds': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/items>
     * @type {number}
     * @memberof BuildItemStats
     */
    'item_id': number;
}
/**
 * 
 * @export
 * @interface ClickhouseMatchInfo
 */
export interface ClickhouseMatchInfo {
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof ClickhouseMatchInfo
     */
    'average_badge_team0'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof ClickhouseMatchInfo
     */
    'average_badge_team1'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ClickhouseMatchInfo
     */
    'duration_s': number;
    /**
     * 
     * @type {number}
     * @memberof ClickhouseMatchInfo
     */
    'match_id': number;
    /**
     * 
     * @type {number}
     * @memberof ClickhouseMatchInfo
     */
    'match_mode': number;
    /**
     * 
     * @type {number}
     * @memberof ClickhouseMatchInfo
     */
    'start_time': number;
}
/**
 * 
 * @export
 * @interface ClickhouseSalts
 */
export interface ClickhouseSalts {
    /**
     * 
     * @type {number}
     * @memberof ClickhouseSalts
     */
    'cluster_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ClickhouseSalts
     */
    'match_id': number;
    /**
     * 
     * @type {number}
     * @memberof ClickhouseSalts
     */
    'metadata_salt'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ClickhouseSalts
     */
    'replay_salt'?: number | null;
}
/**
 * 
 * @export
 * @interface CreateCustomRequest
 */
export interface CreateCustomRequest {
    /**
     * If a callback url is provided, we will send a POST request to this url when the match starts.
     * @type {string}
     * @memberof CreateCustomRequest
     */
    'callback_url'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomRequest
     */
    'cheats_enabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomRequest
     */
    'duplicate_heroes_enabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomRequest
     */
    'experimental_heroes_enabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomRequest
     */
    'is_publicly_visible'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof CreateCustomRequest
     */
    'min_roster_size'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof CreateCustomRequest
     */
    'randomize_lanes'?: boolean | null;
}
/**
 * 
 * @export
 * @interface CreateCustomResponse
 */
export interface CreateCustomResponse {
    /**
     * If a callback url is provided, this is the secret that should be used to verify the callback. The secret is a base64 encoded random string. To verify it you should compare it with the X-Callback-Secret header. If no callback url is provided, this will be None.
     * @type {string}
     * @memberof CreateCustomResponse
     */
    'callback_secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomResponse
     */
    'party_code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCustomResponse
     */
    'party_id': string;
}
/**
 * 
 * @export
 * @interface ESportsMatch
 */
export interface ESportsMatch {
    /**
     * Valve\'s match id of the match.
     * @type {number}
     * @memberof ESportsMatch
     */
    'match_id'?: number | null;
    /**
     * The provider of the match data. Some string that identifies the source of the data.
     * @type {string}
     * @memberof ESportsMatch
     */
    'provider': string;
    /**
     * The scheduled date of the match.
     * @type {string}
     * @memberof ESportsMatch
     */
    'scheduled_date'?: string | null;
    /**
     * The status of the match, e.g. live, completed, scheduled, cancelled.
     * @type {ESportsMatchStatus}
     * @memberof ESportsMatch
     */
    'status'?: ESportsMatchStatus | null;
    /**
     * The name of the first team.
     * @type {string}
     * @memberof ESportsMatch
     */
    'team0_name'?: string | null;
    /**
     * The name of the second team.
     * @type {string}
     * @memberof ESportsMatch
     */
    'team1_name'?: string | null;
    /**
     * The name of the tournament.
     * @type {string}
     * @memberof ESportsMatch
     */
    'tournament_name'?: string | null;
    /**
     * The stage of the tournament.
     * @type {string}
     * @memberof ESportsMatch
     */
    'tournament_stage'?: string | null;
    /**
     * If you want to update an existing match, you can provide an update id.
     * @type {string}
     * @memberof ESportsMatch
     */
    'update_id'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ESportsMatchStatus = {
    Live: 'Live',
    Completed: 'Completed',
    Scheduled: 'Scheduled',
    Cancelled: 'Cancelled'
} as const;

export type ESportsMatchStatus = typeof ESportsMatchStatus[keyof typeof ESportsMatchStatus];


/**
 * 
 * @export
 * @interface EnemyStats
 */
export interface EnemyStats {
    /**
     * 
     * @type {number}
     * @memberof EnemyStats
     */
    'enemy_id': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof EnemyStats
     */
    'matches': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof EnemyStats
     */
    'matches_played': number;
    /**
     * The amount of matches won against the enemy.
     * @type {number}
     * @memberof EnemyStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface Entry
 */
export interface Entry {
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {number}
     * @memberof Entry
     */
    'hero_id': number;
    /**
     * 
     * @type {number}
     * @memberof Entry
     */
    'matches': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof Entry
     */
    'rank': number;
    /**
     * 
     * @type {number}
     * @memberof Entry
     */
    'value': number;
}
/**
 * 
 * @export
 * @interface GetCustomMatchIdResponse
 */
export interface GetCustomMatchIdResponse {
    /**
     * 
     * @type {number}
     * @memberof GetCustomMatchIdResponse
     */
    'match_id': number;
}
/**
 * 
 * @export
 * @interface HashMapValue
 */
export interface HashMapValue {
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'avg': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'percentile1': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'percentile10': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'percentile25': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'percentile5': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'percentile50': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'percentile75': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'percentile90': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'percentile95': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'percentile99': number;
    /**
     * 
     * @type {number}
     * @memberof HashMapValue
     */
    'std': number;
}
/**
 * 
 * @export
 * @interface HeroCombStats
 */
export interface HeroCombStats {
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {Array<number>}
     * @memberof HeroCombStats
     */
    'hero_ids': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof HeroCombStats
     */
    'losses': number;
    /**
     * 
     * @type {number}
     * @memberof HeroCombStats
     */
    'matches': number;
    /**
     * 
     * @type {number}
     * @memberof HeroCombStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface HeroCounterStats
 */
export interface HeroCounterStats {
    /**
     * The number of assists by `hero_id` when facing `enemy_hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'assists': number;
    /**
     * The number of creeps killed by `hero_id` when facing `enemy_hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'creeps': number;
    /**
     * The number of deaths by `hero_id` when facing `enemy_hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'deaths': number;
    /**
     * The number of denies by `hero_id` when facing `enemy_hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'denies': number;
    /**
     * The number of assists by `enemy_hero_id` when facing `hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'enemy_assists': number;
    /**
     * The number of creeps killed by `enemy_hero_id` when facing `hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'enemy_creeps': number;
    /**
     * The number of deaths by `enemy_hero_id` when facing `hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'enemy_deaths': number;
    /**
     * The number of denies by `enemy_hero_id` when facing `hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'enemy_denies': number;
    /**
     * The ID of the opposing hero. See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {number}
     * @memberof HeroCounterStats
     */
    'enemy_hero_id': number;
    /**
     * The number of kills by `enemy_hero_id` when facing `hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'enemy_kills': number;
    /**
     * The number of last hits by `enemy_hero_id` when facing `hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'enemy_last_hits': number;
    /**
     * The net worth of `enemy_hero_id` when facing `hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'enemy_networth': number;
    /**
     * The amount of objective damage dealt by `enemy_hero_id` when facing `hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'enemy_obj_damage': number;
    /**
     * The ID of the hero. See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {number}
     * @memberof HeroCounterStats
     */
    'hero_id': number;
    /**
     * The number of kills by `hero_id` when facing `enemy_hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'kills': number;
    /**
     * The number of last hits by `hero_id` when facing `enemy_hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'last_hits': number;
    /**
     * The total number of matches played between `hero_id` and `enemy_hero_id` that meet the filter criteria.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'matches_played': number;
    /**
     * The net worth of `hero_id` when facing `enemy_hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'networth': number;
    /**
     * The amount of objective damage dealt by `hero_id` when facing `enemy_hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'obj_damage': number;
    /**
     * The number of times `hero_id` won the match when facing `enemy_hero_id`.
     * @type {number}
     * @memberof HeroCounterStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface HeroStats
 */
export interface HeroStats {
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'account_id': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'accuracy': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'assists': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'assists_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'creeps_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'crit_shot_rate': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     * @deprecated
     */
    'damage_mitigated_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'damage_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'damage_per_soul': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'damage_taken_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'damage_taken_per_soul': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'deaths': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'deaths_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'denies_per_match': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'denies_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'ending_level': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {number}
     * @memberof HeroStats
     */
    'hero_id': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'kills': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'kills_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'last_hits_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'last_played': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof HeroStats
     */
    'matches': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'matches_played': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'networth_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'obj_damage_per_min': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'obj_damage_per_soul': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'time_played': number;
    /**
     * 
     * @type {number}
     * @memberof HeroStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface HeroSynergyStats
 */
export interface HeroSynergyStats {
    /**
     * The number of assists by `hero_id1` when playing with `hero_id2`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'assists1': number;
    /**
     * The number of assists by `hero_id2` when playing with `hero_id1`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'assists2': number;
    /**
     * The number of creeps killed by `hero_id1` when playing with `hero_id2`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'creeps1': number;
    /**
     * The number of creeps killed by `hero_id2` when playing with `hero_id1`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'creeps2': number;
    /**
     * The number of deaths by `hero_id1` when playing with `hero_id2`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'deaths1': number;
    /**
     * The number of deaths by `hero_id2` when playing with `hero_id1`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'deaths2': number;
    /**
     * The number of denies by `hero_id1` when playing with `hero_id2`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'denies1': number;
    /**
     * The number of denies by `hero_id2` when playing with `hero_id1`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'denies2': number;
    /**
     * The ID of the first hero in the pair.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'hero_id1': number;
    /**
     * The ID of the second hero in the pair.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'hero_id2': number;
    /**
     * The number of kills by `hero_id1` when playing with `hero_id2`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'kills1': number;
    /**
     * The number of kills by `hero_id2` when playing with `hero_id1`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'kills2': number;
    /**
     * The number of last hits by `hero_id1` when playing with `hero_id2`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'last_hits1': number;
    /**
     * The number of last hits by `hero_id2` when playing with `hero_id1`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'last_hits2': number;
    /**
     * The total number of matches played where `hero_id1` and `hero_id2` were on the same team, meeting the filter criteria.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'matches_played': number;
    /**
     * The net worth of `hero_id1` when playing with `hero_id2`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'networth1': number;
    /**
     * The net worth of `hero_id2` when playing with `hero_id1`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'networth2': number;
    /**
     * The amount of objective damage dealt by `hero_id1` when playing with `hero_id2`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'obj_damage1': number;
    /**
     * The amount of objective damage dealt by `hero_id2` when playing with `hero_id1`.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'obj_damage2': number;
    /**
     * The number of times the team won when both `hero_id1` and `hero_id2` were on the same team.
     * @type {number}
     * @memberof HeroSynergyStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface ItemPermutationStats
 */
export interface ItemPermutationStats {
    /**
     * See more: <https://assets.deadlock-api.com/v2/items>
     * @type {Array<number>}
     * @memberof ItemPermutationStats
     */
    'item_ids': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ItemPermutationStats
     */
    'losses': number;
    /**
     * 
     * @type {number}
     * @memberof ItemPermutationStats
     */
    'matches': number;
    /**
     * 
     * @type {number}
     * @memberof ItemPermutationStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface ItemStats
 */
export interface ItemStats {
    /**
     * 
     * @type {number}
     * @memberof ItemStats
     */
    'bucket'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/items>
     * @type {number}
     * @memberof ItemStats
     */
    'item_id': number;
    /**
     * 
     * @type {number}
     * @memberof ItemStats
     */
    'losses': number;
    /**
     * 
     * @type {number}
     * @memberof ItemStats
     */
    'matches': number;
    /**
     * 
     * @type {number}
     * @memberof ItemStats
     */
    'players': number;
    /**
     * 
     * @type {number}
     * @memberof ItemStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface Leaderboard
 */
export interface Leaderboard {
    /**
     * The leaderboard entries.
     * @type {Array<LeaderboardEntry>}
     * @memberof Leaderboard
     */
    'entries': Array<LeaderboardEntry>;
}
/**
 * 
 * @export
 * @interface LeaderboardEntry
 */
export interface LeaderboardEntry {
    /**
     * The account name of the player.
     * @type {string}
     * @memberof LeaderboardEntry
     */
    'account_name'?: string | null;
    /**
     * The badge level of the player. See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof LeaderboardEntry
     */
    'badge_level'?: number | null;
    /**
     * The possible account IDs of the player. **CAVEAT: This is not always correct, as Steam account names are not unique.**
     * @type {Array<number>}
     * @memberof LeaderboardEntry
     */
    'possible_account_ids'?: Array<number>;
    /**
     * The rank of the player. See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof LeaderboardEntry
     */
    'rank'?: number | null;
    /**
     * The ranked rank of the player. See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof LeaderboardEntry
     */
    'ranked_rank'?: number | null;
    /**
     * The ranked subrank of the player. See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof LeaderboardEntry
     */
    'ranked_subrank'?: number | null;
    /**
     * The top hero IDs of the player. See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {Array<number>}
     * @memberof LeaderboardEntry
     */
    'top_hero_ids'?: Array<number>;
}
/**
 * 
 * @export
 * @interface MMRHistory
 */
export interface MMRHistory {
    /**
     * 
     * @type {number}
     * @memberof MMRHistory
     */
    'account_id': number;
    /**
     * Extracted from the rank the division (rank // 10)
     * @type {number}
     * @memberof MMRHistory
     */
    'division': number;
    /**
     * Extracted from the rank the division tier (rank % 10)
     * @type {number}
     * @memberof MMRHistory
     */
    'division_tier': number;
    /**
     * 
     * @type {number}
     * @memberof MMRHistory
     */
    'match_id': number;
    /**
     * Player Score is the index for the rank array (internally used for the rank regression)
     * @type {number}
     * @memberof MMRHistory
     */
    'player_score': number;
    /**
     * The Player Rank. See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof MMRHistory
     */
    'rank': number;
    /**
     * Start time of the match
     * @type {number}
     * @memberof MMRHistory
     */
    'start_time': number;
}
/**
 * 
 * @export
 * @interface MatchSaltsResponse
 */
export interface MatchSaltsResponse {
    /**
     * 
     * @type {number}
     * @memberof MatchSaltsResponse
     */
    'cluster_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MatchSaltsResponse
     */
    'demo_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MatchSaltsResponse
     */
    'match_id': number;
    /**
     * 
     * @type {number}
     * @memberof MatchSaltsResponse
     */
    'metadata_salt'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MatchSaltsResponse
     */
    'metadata_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MatchSaltsResponse
     */
    'replay_salt'?: number | null;
}
/**
 * 
 * @export
 * @interface MatchSpectateResponse
 */
export interface MatchSpectateResponse {
    /**
     * 
     * @type {string}
     * @memberof MatchSpectateResponse
     */
    'broadcast_url': string;
    /**
     * 
     * @type {number}
     * @memberof MatchSpectateResponse
     */
    'lobby_id'?: number | null;
}
/**
 * 
 * @export
 * @interface MateStats
 */
export interface MateStats {
    /**
     * 
     * @type {Array<number>}
     * @memberof MateStats
     */
    'matches': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof MateStats
     */
    'matches_played': number;
    /**
     * 
     * @type {number}
     * @memberof MateStats
     */
    'mate_id': number;
    /**
     * 
     * @type {number}
     * @memberof MateStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface PartyStats
 */
export interface PartyStats {
    /**
     * 
     * @type {Array<number>}
     * @memberof PartyStats
     */
    'matches': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof PartyStats
     */
    'matches_played': number;
    /**
     * 
     * @type {number}
     * @memberof PartyStats
     */
    'party_size': number;
    /**
     * 
     * @type {number}
     * @memberof PartyStats
     */
    'wins': number;
}
/**
 * 
 * @export
 * @interface Patch
 */
export interface Patch {
    /**
     * 
     * @type {string}
     * @memberof Patch
     */
    'author': string;
    /**
     * 
     * @type {PatchCategory}
     * @memberof Patch
     */
    'category': PatchCategory;
    /**
     * 
     * @type {string}
     * @memberof Patch
     */
    'content_encoded': string;
    /**
     * 
     * @type {string}
     * @memberof Patch
     */
    'dc_creator': string;
    /**
     * 
     * @type {PatchGuid}
     * @memberof Patch
     */
    'guid': PatchGuid;
    /**
     * 
     * @type {string}
     * @memberof Patch
     */
    'link': string;
    /**
     * 
     * @type {string}
     * @memberof Patch
     */
    'pub_date': string;
    /**
     * 
     * @type {string}
     * @memberof Patch
     */
    'slash_comments': string;
    /**
     * 
     * @type {string}
     * @memberof Patch
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface PatchCategory
 */
export interface PatchCategory {
    /**
     * 
     * @type {string}
     * @memberof PatchCategory
     */
    'domain': string;
    /**
     * 
     * @type {string}
     * @memberof PatchCategory
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface PatchGuid
 */
export interface PatchGuid {
    /**
     * 
     * @type {boolean}
     * @memberof PatchGuid
     */
    'is_perma_link': boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchGuid
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface PlayerCard
 */
export interface PlayerCard {
    /**
     * 
     * @type {number}
     * @memberof PlayerCard
     */
    'account_id': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof PlayerCard
     */
    'ranked_badge_level'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof PlayerCard
     */
    'ranked_rank'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     * @type {number}
     * @memberof PlayerCard
     */
    'ranked_subrank'?: number | null;
    /**
     * 
     * @type {Array<PlayerCardSlot>}
     * @memberof PlayerCard
     */
    'slots': Array<PlayerCardSlot>;
}
/**
 * 
 * @export
 * @interface PlayerCardSlot
 */
export interface PlayerCardSlot {
    /**
     * 
     * @type {PlayerCardSlotHero}
     * @memberof PlayerCardSlot
     */
    'hero'?: PlayerCardSlotHero | null;
    /**
     * 
     * @type {number}
     * @memberof PlayerCardSlot
     */
    'slot_id'?: number | null;
    /**
     * 
     * @type {PlayerCardSlotStat}
     * @memberof PlayerCardSlot
     */
    'stat'?: PlayerCardSlotStat | null;
}
/**
 * 
 * @export
 * @interface PlayerCardSlotHero
 */
export interface PlayerCardSlotHero {
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {number}
     * @memberof PlayerCardSlotHero
     */
    'id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlayerCardSlotHero
     */
    'kills'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlayerCardSlotHero
     */
    'wins'?: number | null;
}
/**
 * 
 * @export
 * @interface PlayerCardSlotStat
 */
export interface PlayerCardSlotStat {
    /**
     * 
     * @type {number}
     * @memberof PlayerCardSlotStat
     */
    'stat_id'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlayerCardSlotStat
     */
    'stat_score'?: number | null;
}
/**
 * 
 * @export
 * @interface PlayerMatchHistoryEntry
 */
export interface PlayerMatchHistoryEntry {
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'abandoned_time_s'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'account_id': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'denies': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'game_mode': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'hero_id': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'hero_level': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'last_hits': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'match_duration_s': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'match_id': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'match_mode': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'match_result': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'net_worth': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'objectives_mask_team0': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'objectives_mask_team1': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'player_assists': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'player_deaths': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'player_kills': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'player_team': number;
    /**
     * 
     * @type {number}
     * @memberof PlayerMatchHistoryEntry
     */
    'start_time': number;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerMatchHistoryEntry
     */
    'team_abandoned'?: boolean | null;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * Status of the services.
     * @type {StatusServices}
     * @memberof Status
     */
    'services': StatusServices;
}
/**
 * 
 * @export
 * @interface StatusServices
 */
export interface StatusServices {
    /**
     * Whether Clickhouse is reachable.
     * @type {boolean}
     * @memberof StatusServices
     */
    'clickhouse': boolean;
    /**
     * Whether Postgres is reachable.
     * @type {boolean}
     * @memberof StatusServices
     */
    'postgres': boolean;
    /**
     * Whether Redis is reachable.
     * @type {boolean}
     * @memberof StatusServices
     */
    'redis': boolean;
}
/**
 * 
 * @export
 * @interface SteamProfile
 */
export interface SteamProfile {
    /**
     * 
     * @type {number}
     * @memberof SteamProfile
     */
    'account_id': number;
    /**
     * 
     * @type {string}
     * @memberof SteamProfile
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof SteamProfile
     */
    'avatarfull': string;
    /**
     * 
     * @type {string}
     * @memberof SteamProfile
     */
    'avatarmedium': string;
    /**
     * 
     * @type {string}
     * @memberof SteamProfile
     */
    'countrycode'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SteamProfile
     */
    'last_updated': string;
    /**
     * 
     * @type {string}
     * @memberof SteamProfile
     */
    'personaname': string;
    /**
     * 
     * @type {string}
     * @memberof SteamProfile
     */
    'profileurl': string;
    /**
     * 
     * @type {string}
     * @memberof SteamProfile
     */
    'realname'?: string | null;
}
/**
 * 
 * @export
 * @interface TableSize
 */
export interface TableSize {
    /**
     * Compressed size of the table in bytes.
     * @type {number}
     * @memberof TableSize
     */
    'data_compressed_bytes'?: number | null;
    /**
     * Uncompressed size of the table in bytes.
     * @type {number}
     * @memberof TableSize
     */
    'data_uncompressed_bytes'?: number | null;
    /**
     * Whether the table is a view.
     * @type {boolean}
     * @memberof TableSize
     */
    'is_view': boolean;
    /**
     * Number of rows in the table.
     * @type {number}
     * @memberof TableSize
     */
    'rows'?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VariableCategory = {
    General: 'General',
    Daily: 'Daily',
    Hero: 'Hero',
    Leaderboard: 'Leaderboard',
    Overall: 'Overall'
} as const;

export type VariableCategory = typeof VariableCategory[keyof typeof VariableCategory];


/**
 * 
 * @export
 * @interface VariableDescription
 */
export interface VariableDescription {
    /**
     * The category of the variable.
     * @type {VariableCategory}
     * @memberof VariableDescription
     */
    'category': VariableCategory;
    /**
     * The default label for the variable.
     * @type {string}
     * @memberof VariableDescription
     */
    'default_label'?: string | null;
    /**
     * The description of the variable.
     * @type {string}
     * @memberof VariableDescription
     */
    'description': string;
    /**
     * Extra arguments that can be passed to the variable.
     * @type {Array<string>}
     * @memberof VariableDescription
     */
    'extra_args': Array<string>;
    /**
     * The name of the variable.
     * @type {string}
     * @memberof VariableDescription
     */
    'name': string;
}



/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Ability Order Stats
         * @param {number} heroId See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAbilityUpgrades] Filter players based on their minimum number of ability upgrades over the whole match.
         * @param {number | null} [maxAbilityUpgrades] Filter players based on their maximum number of ability upgrades over the whole match.
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatches] The minimum number of matches played for an ability order to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abilityOrderStats: async (heroId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAbilityUpgrades?: number | null, maxAbilityUpgrades?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('abilityOrderStats', 'heroId', heroId)
            const localVarPath = `/v1/analytics/ability-order-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minAbilityUpgrades !== undefined) {
                localVarQueryParameter['min_ability_upgrades'] = minAbilityUpgrades;
            }

            if (maxAbilityUpgrades !== undefined) {
                localVarQueryParameter['max_ability_upgrades'] = maxAbilityUpgrades;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Build Item Stats
         * @param {number | null} [heroId] Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildItemStats: async (heroId?: number | null, minLastUpdatedUnixTimestamp?: number | null, maxLastUpdatedUnixTimestamp?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/build-item-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minLastUpdatedUnixTimestamp !== undefined) {
                localVarQueryParameter['min_last_updated_unix_timestamp'] = minLastUpdatedUnixTimestamp;
            }

            if (maxLastUpdatedUnixTimestamp !== undefined) {
                localVarQueryParameter['max_last_updated_unix_timestamp'] = maxLastUpdatedUnixTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Comb Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeHeroIds] Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {Array<number> | null} [excludeHeroIds] Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [combSize] The combination size to return.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroCombStats: async (minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeHeroIds?: Array<number> | null, excludeHeroIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, combSize?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/hero-comb-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (includeHeroIds) {
                localVarQueryParameter['include_hero_ids'] = includeHeroIds;
            }

            if (excludeHeroIds) {
                localVarQueryParameter['exclude_hero_ids'] = excludeHeroIds;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (combSize !== undefined) {
                localVarQueryParameter['comb_size'] = combSize;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Counter Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [maxEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroCountersStats: async (minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minEnemyNetworth?: number | null, maxEnemyNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/hero-counter-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minEnemyNetworth !== undefined) {
                localVarQueryParameter['min_enemy_networth'] = minEnemyNetworth;
            }

            if (maxEnemyNetworth !== undefined) {
                localVarQueryParameter['max_enemy_networth'] = maxEnemyNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (sameLaneFilter !== undefined) {
                localVarQueryParameter['same_lane_filter'] = sameLaneFilter;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Scoreboard
         * @param {HeroScoreboardSortByEnum} sortBy The field to sort by.
         * @param {HeroScoreboardSortDirectionEnum} [sortDirection] The direction to sort heroes in.
         * @param {number | null} [minMatches] Filter by min number of matches played.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroScoreboard: async (sortBy: HeroScoreboardSortByEnum, sortDirection?: HeroScoreboardSortDirectionEnum, minMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sortBy' is not null or undefined
            assertParamExists('heroScoreboard', 'sortBy', sortBy)
            const localVarPath = `/v1/analytics/scoreboards/heroes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {HeroStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minHeroMatches] Filter players based on the number of matches they have played with a specific hero.
         * @param {number | null} [maxHeroMatches] Filter players based on the number of matches they have played with a specific hero.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroStats: async (bucket?: HeroStatsBucketEnum, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minHeroMatches?: number | null, maxHeroMatches?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/hero-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bucket !== undefined) {
                localVarQueryParameter['bucket'] = bucket;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (minHeroMatches !== undefined) {
                localVarQueryParameter['min_hero_matches'] = minHeroMatches;
            }

            if (maxHeroMatches !== undefined) {
                localVarQueryParameter['max_hero_matches'] = maxHeroMatches;
            }

            if (includeItemIds) {
                localVarQueryParameter['include_item_ids'] = includeItemIds;
            }

            if (excludeItemIds) {
                localVarQueryParameter['exclude_item_ids'] = excludeItemIds;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Synergy Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {boolean | null} [samePartyFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroSynergiesStats: async (minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, samePartyFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/hero-synergy-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (sameLaneFilter !== undefined) {
                localVarQueryParameter['same_lane_filter'] = sameLaneFilter;
            }

            if (samePartyFilter !== undefined) {
                localVarQueryParameter['same_party_filter'] = samePartyFilter;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Permutation Stats
         * @param {Array<number> | null} [itemIds] Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [combSize] The combination size to return.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemPermutationStats: async (itemIds?: Array<number> | null, combSize?: number | null, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/item-permutation-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemIds) {
                localVarQueryParameter['item_ids'] = itemIds;
            }

            if (combSize !== undefined) {
                localVarQueryParameter['comb_size'] = combSize;
            }

            if (heroIds !== undefined) {
                localVarQueryParameter['hero_ids'] = heroIds;
            }

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Stats
         * @param {ItemStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for an item to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStats: async (bucket?: ItemStatsBucketEnum, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/item-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bucket !== undefined) {
                localVarQueryParameter['bucket'] = bucket;
            }

            if (heroIds !== undefined) {
                localVarQueryParameter['hero_ids'] = heroIds;
            }

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (includeItemIds) {
                localVarQueryParameter['include_item_ids'] = includeItemIds;
            }

            if (excludeItemIds) {
                localVarQueryParameter['exclude_item_ids'] = excludeItemIds;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Scoreboard
         * @param {PlayerScoreboardSortByEnum} sortBy The field to sort by.
         * @param {PlayerScoreboardSortDirectionEnum} [sortDirection] The direction to sort players in.
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a player to be included in the scoreboard.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [start] The offset to start fetching players from.
         * @param {number | null} [limit] The maximum number of players to fetch.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerScoreboard: async (sortBy: PlayerScoreboardSortByEnum, sortDirection?: PlayerScoreboardSortDirectionEnum, heroId?: number | null, minMatches?: number | null, maxMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, start?: number | null, limit?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sortBy' is not null or undefined
            assertParamExists('playerScoreboard', 'sortBy', sortBy)
            const localVarPath = `/v1/analytics/scoreboards/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Stats Metrics
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerStatsMetrics: async (heroIds?: string | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/player-stats/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (heroIds !== undefined) {
                localVarQueryParameter['hero_ids'] = heroIds;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (includeItemIds) {
                localVarQueryParameter['include_item_ids'] = includeItemIds;
            }

            if (excludeItemIds) {
                localVarQueryParameter['exclude_item_ids'] = excludeItemIds;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Ability Order Stats
         * @param {number} heroId See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAbilityUpgrades] Filter players based on their minimum number of ability upgrades over the whole match.
         * @param {number | null} [maxAbilityUpgrades] Filter players based on their maximum number of ability upgrades over the whole match.
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatches] The minimum number of matches played for an ability order to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async abilityOrderStats(heroId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAbilityUpgrades?: number | null, maxAbilityUpgrades?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyticsAbilityOrderStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.abilityOrderStats(heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAbilityUpgrades, maxAbilityUpgrades, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatches, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.abilityOrderStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Build Item Stats
         * @param {number | null} [heroId] Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildItemStats(heroId?: number | null, minLastUpdatedUnixTimestamp?: number | null, maxLastUpdatedUnixTimestamp?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BuildItemStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildItemStats(heroId, minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.buildItemStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Comb Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeHeroIds] Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {Array<number> | null} [excludeHeroIds] Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [combSize] The combination size to return.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroCombStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeHeroIds?: Array<number> | null, excludeHeroIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, combSize?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HeroCombStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroCombStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeHeroIds, excludeHeroIds, minMatches, maxMatches, combSize, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroCombStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Counter Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [maxEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroCountersStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minEnemyNetworth?: number | null, maxEnemyNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HeroCounterStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroCountersStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minEnemyNetworth, maxEnemyNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, minMatches, maxMatches, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroCountersStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Scoreboard
         * @param {HeroScoreboardSortByEnum} sortBy The field to sort by.
         * @param {HeroScoreboardSortDirectionEnum} [sortDirection] The direction to sort heroes in.
         * @param {number | null} [minMatches] Filter by min number of matches played.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroScoreboard(sortBy: HeroScoreboardSortByEnum, sortDirection?: HeroScoreboardSortDirectionEnum, minMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroScoreboard(sortBy, sortDirection, minMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroScoreboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {HeroStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minHeroMatches] Filter players based on the number of matches they have played with a specific hero.
         * @param {number | null} [maxHeroMatches] Filter players based on the number of matches they have played with a specific hero.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroStats(bucket?: HeroStatsBucketEnum, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minHeroMatches?: number | null, maxHeroMatches?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyticsHeroStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroStats(bucket, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minHeroMatches, maxHeroMatches, includeItemIds, excludeItemIds, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Synergy Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {boolean | null} [samePartyFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroSynergiesStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, samePartyFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HeroSynergyStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroSynergiesStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, samePartyFilter, minMatches, maxMatches, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroSynergiesStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Permutation Stats
         * @param {Array<number> | null} [itemIds] Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [combSize] The combination size to return.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemPermutationStats(itemIds?: Array<number> | null, combSize?: number | null, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemPermutationStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemPermutationStats(itemIds, combSize, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.itemPermutationStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Stats
         * @param {ItemStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for an item to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemStats(bucket?: ItemStatsBucketEnum, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemStats(bucket, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, minMatches, maxMatches, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.itemStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Scoreboard
         * @param {PlayerScoreboardSortByEnum} sortBy The field to sort by.
         * @param {PlayerScoreboardSortDirectionEnum} [sortDirection] The direction to sort players in.
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a player to be included in the scoreboard.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [start] The offset to start fetching players from.
         * @param {number | null} [limit] The maximum number of players to fetch.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerScoreboard(sortBy: PlayerScoreboardSortByEnum, sortDirection?: PlayerScoreboardSortDirectionEnum, heroId?: number | null, minMatches?: number | null, maxMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, start?: number | null, limit?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerScoreboard(sortBy, sortDirection, heroId, minMatches, maxMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, start, limit, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.playerScoreboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Stats Metrics
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerStatsMetrics(heroIds?: string | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: HashMapValue; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerStatsMetrics(heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.playerStatsMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Ability Order Stats
         * @param {number} heroId See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAbilityUpgrades] Filter players based on their minimum number of ability upgrades over the whole match.
         * @param {number | null} [maxAbilityUpgrades] Filter players based on their maximum number of ability upgrades over the whole match.
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatches] The minimum number of matches played for an ability order to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abilityOrderStats(heroId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAbilityUpgrades?: number | null, maxAbilityUpgrades?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnalyticsAbilityOrderStats>> {
            return localVarFp.abilityOrderStats(heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAbilityUpgrades, maxAbilityUpgrades, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatches, accountId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Build Item Stats
         * @param {number | null} [heroId] Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildItemStats(heroId?: number | null, minLastUpdatedUnixTimestamp?: number | null, maxLastUpdatedUnixTimestamp?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<BuildItemStats>> {
            return localVarFp.buildItemStats(heroId, minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Comb Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeHeroIds] Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {Array<number> | null} [excludeHeroIds] Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [combSize] The combination size to return.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroCombStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeHeroIds?: Array<number> | null, excludeHeroIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, combSize?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<HeroCombStats>> {
            return localVarFp.heroCombStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeHeroIds, excludeHeroIds, minMatches, maxMatches, combSize, accountId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Counter Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [maxEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroCountersStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minEnemyNetworth?: number | null, maxEnemyNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<HeroCounterStats>> {
            return localVarFp.heroCountersStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minEnemyNetworth, maxEnemyNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, minMatches, maxMatches, accountId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Scoreboard
         * @param {HeroScoreboardSortByEnum} sortBy The field to sort by.
         * @param {HeroScoreboardSortDirectionEnum} [sortDirection] The direction to sort heroes in.
         * @param {number | null} [minMatches] Filter by min number of matches played.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroScoreboard(sortBy: HeroScoreboardSortByEnum, sortDirection?: HeroScoreboardSortDirectionEnum, minMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<Entry>> {
            return localVarFp.heroScoreboard(sortBy, sortDirection, minMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {HeroStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minHeroMatches] Filter players based on the number of matches they have played with a specific hero.
         * @param {number | null} [maxHeroMatches] Filter players based on the number of matches they have played with a specific hero.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroStats(bucket?: HeroStatsBucketEnum, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minHeroMatches?: number | null, maxHeroMatches?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnalyticsHeroStats>> {
            return localVarFp.heroStats(bucket, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minHeroMatches, maxHeroMatches, includeItemIds, excludeItemIds, accountId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Synergy Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {boolean | null} [samePartyFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroSynergiesStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, samePartyFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<HeroSynergyStats>> {
            return localVarFp.heroSynergiesStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, samePartyFilter, minMatches, maxMatches, accountId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Permutation Stats
         * @param {Array<number> | null} [itemIds] Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [combSize] The combination size to return.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemPermutationStats(itemIds?: Array<number> | null, combSize?: number | null, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemPermutationStats>> {
            return localVarFp.itemPermutationStats(itemIds, combSize, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Stats
         * @param {ItemStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for an item to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStats(bucket?: ItemStatsBucketEnum, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemStats>> {
            return localVarFp.itemStats(bucket, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, minMatches, maxMatches, accountId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Scoreboard
         * @param {PlayerScoreboardSortByEnum} sortBy The field to sort by.
         * @param {PlayerScoreboardSortDirectionEnum} [sortDirection] The direction to sort players in.
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a player to be included in the scoreboard.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [start] The offset to start fetching players from.
         * @param {number | null} [limit] The maximum number of players to fetch.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerScoreboard(sortBy: PlayerScoreboardSortByEnum, sortDirection?: PlayerScoreboardSortDirectionEnum, heroId?: number | null, minMatches?: number | null, maxMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, start?: number | null, limit?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<Entry>> {
            return localVarFp.playerScoreboard(sortBy, sortDirection, heroId, minMatches, maxMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, start, limit, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Stats Metrics
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerStatsMetrics(heroIds?: string | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<{ [key: string]: HashMapValue; }>> {
            return localVarFp.playerStatsMetrics(heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, accountIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI {
    /**
     *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Ability Order Stats
     * @param {number} heroId See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minAbilityUpgrades] Filter players based on their minimum number of ability upgrades over the whole match.
     * @param {number | null} [maxAbilityUpgrades] Filter players based on their maximum number of ability upgrades over the whole match.
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {number | null} [minMatches] The minimum number of matches played for an ability order to be included in the response.
     * @param {number | null} [accountId] Filter for matches with a specific player account ID.
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public abilityOrderStats(heroId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAbilityUpgrades?: number | null, maxAbilityUpgrades?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).abilityOrderStats(heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAbilityUpgrades, maxAbilityUpgrades, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatches, accountId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Build Item Stats
     * @param {number | null} [heroId] Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number | null} [minLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public buildItemStats(heroId?: number | null, minLastUpdatedUnixTimestamp?: number | null, maxLastUpdatedUnixTimestamp?: number | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).buildItemStats(heroId, minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Comb Stats
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {Array<number> | null} [includeHeroIds] Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {Array<number> | null} [excludeHeroIds] Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
     * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
     * @param {number | null} [combSize] The combination size to return.
     * @param {number | null} [accountId] Filter for matches with a specific player account ID.
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public heroCombStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeHeroIds?: Array<number> | null, excludeHeroIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, combSize?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroCombStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeHeroIds, excludeHeroIds, minMatches, maxMatches, combSize, accountId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Counter Stats
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minEnemyNetworth] Filter enemy players based on their net worth.
     * @param {number | null} [maxEnemyNetworth] Filter enemy players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
     * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
     * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
     * @param {number | null} [accountId] Filter for matches with a specific player account ID.
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public heroCountersStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minEnemyNetworth?: number | null, maxEnemyNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroCountersStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minEnemyNetworth, maxEnemyNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, minMatches, maxMatches, accountId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Scoreboard
     * @param {HeroScoreboardSortByEnum} sortBy The field to sort by.
     * @param {HeroScoreboardSortDirectionEnum} [sortDirection] The direction to sort heroes in.
     * @param {number | null} [minMatches] Filter by min number of matches played.
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {number | null} [accountId] Filter for matches with a specific player account ID.
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public heroScoreboard(sortBy: HeroScoreboardSortByEnum, sortDirection?: HeroScoreboardSortDirectionEnum, minMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroScoreboard(sortBy, sortDirection, minMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Stats
     * @param {HeroStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {number | null} [minHeroMatches] Filter players based on the number of matches they have played with a specific hero.
     * @param {number | null} [maxHeroMatches] Filter players based on the number of matches they have played with a specific hero.
     * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     * @param {number | null} [accountId] Filter for matches with a specific player account ID.
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public heroStats(bucket?: HeroStatsBucketEnum, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minHeroMatches?: number | null, maxHeroMatches?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroStats(bucket, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minHeroMatches, maxHeroMatches, includeItemIds, excludeItemIds, accountId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Synergy Stats
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
     * @param {boolean | null} [samePartyFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation.
     * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
     * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
     * @param {number | null} [accountId] Filter for matches with a specific player account ID.
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public heroSynergiesStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, samePartyFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroSynergiesStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, samePartyFilter, minMatches, maxMatches, accountId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Item Permutation Stats
     * @param {Array<number> | null} [itemIds] Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     * @param {number | null} [combSize] The combination size to return.
     * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {number | null} [accountId] Filter for matches with a specific player account ID.
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public itemPermutationStats(itemIds?: Array<number> | null, combSize?: number | null, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).itemPermutationStats(itemIds, combSize, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Item Stats
     * @param {ItemStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
     * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     * @param {number | null} [minMatches] The minimum number of matches played for an item to be included in the response.
     * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
     * @param {number | null} [accountId] Filter for matches with a specific player account ID.
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public itemStats(bucket?: ItemStatsBucketEnum, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).itemStats(bucket, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, minMatches, maxMatches, accountId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Player Scoreboard
     * @param {PlayerScoreboardSortByEnum} sortBy The field to sort by.
     * @param {PlayerScoreboardSortDirectionEnum} [sortDirection] The direction to sort players in.
     * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number | null} [minMatches] The minimum number of matches played for a player to be included in the scoreboard.
     * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {number | null} [start] The offset to start fetching players from.
     * @param {number | null} [limit] The maximum number of players to fetch.
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public playerScoreboard(sortBy: PlayerScoreboardSortByEnum, sortDirection?: PlayerScoreboardSortDirectionEnum, heroId?: number | null, minMatches?: number | null, maxMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, start?: number | null, limit?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).playerScoreboard(sortBy, sortDirection, heroId, minMatches, maxMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, start, limit, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Player Stats Metrics
     * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public playerStatsMetrics(heroIds?: string | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).playerStatsMetrics(heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, accountIds, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const HeroScoreboardSortByEnum = {
    Matches: 'matches',
    Wins: 'wins',
    Losses: 'losses',
    Winrate: 'winrate',
    MaxKillsPerMatch: 'max_kills_per_match',
    AvgKillsPerMatch: 'avg_kills_per_match',
    Kills: 'kills',
    MaxDeathsPerMatch: 'max_deaths_per_match',
    AvgDeathsPerMatch: 'avg_deaths_per_match',
    Deaths: 'deaths',
    MaxDamageTakenPerMatch: 'max_damage_taken_per_match',
    AvgDamageTakenPerMatch: 'avg_damage_taken_per_match',
    DamageTaken: 'damage_taken',
    MaxAssistsPerMatch: 'max_assists_per_match',
    AvgAssistsPerMatch: 'avg_assists_per_match',
    Assists: 'assists',
    MaxNetWorthPerMatch: 'max_net_worth_per_match',
    AvgNetWorthPerMatch: 'avg_net_worth_per_match',
    NetWorth: 'net_worth',
    MaxLastHitsPerMatch: 'max_last_hits_per_match',
    AvgLastHitsPerMatch: 'avg_last_hits_per_match',
    LastHits: 'last_hits',
    MaxDeniesPerMatch: 'max_denies_per_match',
    AvgDeniesPerMatch: 'avg_denies_per_match',
    Denies: 'denies',
    MaxPlayerLevelPerMatch: 'max_player_level_per_match',
    AvgPlayerLevelPerMatch: 'avg_player_level_per_match',
    PlayerLevel: 'player_level',
    MaxCreepKillsPerMatch: 'max_creep_kills_per_match',
    AvgCreepKillsPerMatch: 'avg_creep_kills_per_match',
    CreepKills: 'creep_kills',
    MaxNeutralKillsPerMatch: 'max_neutral_kills_per_match',
    AvgNeutralKillsPerMatch: 'avg_neutral_kills_per_match',
    NeutralKills: 'neutral_kills',
    MaxCreepDamagePerMatch: 'max_creep_damage_per_match',
    AvgCreepDamagePerMatch: 'avg_creep_damage_per_match',
    CreepDamage: 'creep_damage',
    MaxPlayerDamagePerMatch: 'max_player_damage_per_match',
    AvgPlayerDamagePerMatch: 'avg_player_damage_per_match',
    PlayerDamage: 'player_damage',
    MaxNeutralDamagePerMatch: 'max_neutral_damage_per_match',
    AvgNeutralDamagePerMatch: 'avg_neutral_damage_per_match',
    NeutralDamage: 'neutral_damage',
    MaxBossDamagePerMatch: 'max_boss_damage_per_match',
    AvgBossDamagePerMatch: 'avg_boss_damage_per_match',
    BossDamage: 'boss_damage',
    MaxMaxHealthPerMatch: 'max_max_health_per_match',
    AvgMaxHealthPerMatch: 'avg_max_health_per_match',
    MaxHealth: 'max_health',
    MaxShotsHitPerMatch: 'max_shots_hit_per_match',
    AvgShotsHitPerMatch: 'avg_shots_hit_per_match',
    ShotsHit: 'shots_hit',
    MaxShotsMissedPerMatch: 'max_shots_missed_per_match',
    AvgShotsMissedPerMatch: 'avg_shots_missed_per_match',
    ShotsMissed: 'shots_missed',
    MaxHeroBulletsHitPerMatch: 'max_hero_bullets_hit_per_match',
    AvgHeroBulletsHitPerMatch: 'avg_hero_bullets_hit_per_match',
    HeroBulletsHit: 'hero_bullets_hit',
    MaxHeroBulletsHitCritPerMatch: 'max_hero_bullets_hit_crit_per_match',
    AvgHeroBulletsHitCritPerMatch: 'avg_hero_bullets_hit_crit_per_match',
    HeroBulletsHitCrit: 'hero_bullets_hit_crit'
} as const;
export type HeroScoreboardSortByEnum = typeof HeroScoreboardSortByEnum[keyof typeof HeroScoreboardSortByEnum];
/**
 * @export
 */
export const HeroScoreboardSortDirectionEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;
export type HeroScoreboardSortDirectionEnum = typeof HeroScoreboardSortDirectionEnum[keyof typeof HeroScoreboardSortDirectionEnum];
/**
 * @export
 */
export const HeroStatsBucketEnum = {
    NoBucket: 'no_bucket',
    StartTimeHour: 'start_time_hour',
    StartTimeDay: 'start_time_day',
    StartTimeWeek: 'start_time_week',
    StartTimeMonth: 'start_time_month'
} as const;
export type HeroStatsBucketEnum = typeof HeroStatsBucketEnum[keyof typeof HeroStatsBucketEnum];
/**
 * @export
 */
export const ItemStatsBucketEnum = {
    NoBucket: 'no_bucket',
    Hero: 'hero',
    Team: 'team',
    StartTimeHour: 'start_time_hour',
    StartTimeDay: 'start_time_day',
    StartTimeWeek: 'start_time_week',
    StartTimeMonth: 'start_time_month',
    GameTimeMin: 'game_time_min',
    GameTimeNormalizedPercentage: 'game_time_normalized_percentage',
    NetWorthBy1000: 'net_worth_by_1000',
    NetWorthBy2000: 'net_worth_by_2000',
    NetWorthBy3000: 'net_worth_by_3000',
    NetWorthBy5000: 'net_worth_by_5000',
    NetWorthBy10000: 'net_worth_by_10000'
} as const;
export type ItemStatsBucketEnum = typeof ItemStatsBucketEnum[keyof typeof ItemStatsBucketEnum];
/**
 * @export
 */
export const PlayerScoreboardSortByEnum = {
    Matches: 'matches',
    Wins: 'wins',
    Losses: 'losses',
    Winrate: 'winrate',
    MaxKillsPerMatch: 'max_kills_per_match',
    AvgKillsPerMatch: 'avg_kills_per_match',
    Kills: 'kills',
    MaxDeathsPerMatch: 'max_deaths_per_match',
    AvgDeathsPerMatch: 'avg_deaths_per_match',
    Deaths: 'deaths',
    MaxDamageTakenPerMatch: 'max_damage_taken_per_match',
    AvgDamageTakenPerMatch: 'avg_damage_taken_per_match',
    DamageTaken: 'damage_taken',
    MaxAssistsPerMatch: 'max_assists_per_match',
    AvgAssistsPerMatch: 'avg_assists_per_match',
    Assists: 'assists',
    MaxNetWorthPerMatch: 'max_net_worth_per_match',
    AvgNetWorthPerMatch: 'avg_net_worth_per_match',
    NetWorth: 'net_worth',
    MaxLastHitsPerMatch: 'max_last_hits_per_match',
    AvgLastHitsPerMatch: 'avg_last_hits_per_match',
    LastHits: 'last_hits',
    MaxDeniesPerMatch: 'max_denies_per_match',
    AvgDeniesPerMatch: 'avg_denies_per_match',
    Denies: 'denies',
    MaxPlayerLevelPerMatch: 'max_player_level_per_match',
    AvgPlayerLevelPerMatch: 'avg_player_level_per_match',
    PlayerLevel: 'player_level',
    MaxCreepKillsPerMatch: 'max_creep_kills_per_match',
    AvgCreepKillsPerMatch: 'avg_creep_kills_per_match',
    CreepKills: 'creep_kills',
    MaxNeutralKillsPerMatch: 'max_neutral_kills_per_match',
    AvgNeutralKillsPerMatch: 'avg_neutral_kills_per_match',
    NeutralKills: 'neutral_kills',
    MaxCreepDamagePerMatch: 'max_creep_damage_per_match',
    AvgCreepDamagePerMatch: 'avg_creep_damage_per_match',
    CreepDamage: 'creep_damage',
    MaxPlayerDamagePerMatch: 'max_player_damage_per_match',
    AvgPlayerDamagePerMatch: 'avg_player_damage_per_match',
    PlayerDamage: 'player_damage',
    MaxNeutralDamagePerMatch: 'max_neutral_damage_per_match',
    AvgNeutralDamagePerMatch: 'avg_neutral_damage_per_match',
    NeutralDamage: 'neutral_damage',
    MaxBossDamagePerMatch: 'max_boss_damage_per_match',
    AvgBossDamagePerMatch: 'avg_boss_damage_per_match',
    BossDamage: 'boss_damage',
    MaxMaxHealthPerMatch: 'max_max_health_per_match',
    AvgMaxHealthPerMatch: 'avg_max_health_per_match',
    MaxHealth: 'max_health',
    MaxShotsHitPerMatch: 'max_shots_hit_per_match',
    AvgShotsHitPerMatch: 'avg_shots_hit_per_match',
    ShotsHit: 'shots_hit',
    MaxShotsMissedPerMatch: 'max_shots_missed_per_match',
    AvgShotsMissedPerMatch: 'avg_shots_missed_per_match',
    ShotsMissed: 'shots_missed',
    MaxHeroBulletsHitPerMatch: 'max_hero_bullets_hit_per_match',
    AvgHeroBulletsHitPerMatch: 'avg_hero_bullets_hit_per_match',
    HeroBulletsHit: 'hero_bullets_hit',
    MaxHeroBulletsHitCritPerMatch: 'max_hero_bullets_hit_crit_per_match',
    AvgHeroBulletsHitCritPerMatch: 'avg_hero_bullets_hit_crit_per_match',
    HeroBulletsHitCrit: 'hero_bullets_hit_crit'
} as const;
export type PlayerScoreboardSortByEnum = typeof PlayerScoreboardSortByEnum[keyof typeof PlayerScoreboardSortByEnum];
/**
 * @export
 */
export const PlayerScoreboardSortDirectionEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;
export type PlayerScoreboardSortDirectionEnum = typeof PlayerScoreboardSortDirectionEnum[keyof typeof PlayerScoreboardSortDirectionEnum];


/**
 * BuildsApi - axios parameter creator
 * @export
 */
export const BuildsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Search for builds based on various criteria.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Search
         * @param {number} [minUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [maxUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [minPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {number} [maxPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {SearchBuildsSortByEnum} [sortBy] The field to sort the builds by.
         * @param {number} [start] The index of the first build to return.
         * @param {number} [limit] The maximum number of builds to return.
         * @param {SearchBuildsSortDirectionEnum} [sortDirection] The direction to sort the builds in.
         * @param {string} [searchName] Search for builds with a name containing this string.
         * @param {string} [searchDescription] Search for builds with a description containing this string.
         * @param {boolean} [onlyLatest] Only return the latest version of each build.
         * @param {number} [language] Filter builds by language.
         * @param {number} [buildId] Filter builds by ID.
         * @param {number} [version] Filter builds by version.
         * @param {number} [heroId] Filter builds by hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number} [tag] Filter builds by tag.
         * @param {number} [rollupCategory] Filter builds by rollup category.
         * @param {number} [authorId] The author\&#39;s &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBuilds: async (minUnixTimestamp?: number, maxUnixTimestamp?: number, minPublishedUnixTimestamp?: number, maxPublishedUnixTimestamp?: number, sortBy?: SearchBuildsSortByEnum, start?: number, limit?: number, sortDirection?: SearchBuildsSortDirectionEnum, searchName?: string, searchDescription?: string, onlyLatest?: boolean, language?: number, buildId?: number, version?: number, heroId?: number, tag?: number, rollupCategory?: number, authorId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/builds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minPublishedUnixTimestamp !== undefined) {
                localVarQueryParameter['min_published_unix_timestamp'] = minPublishedUnixTimestamp;
            }

            if (maxPublishedUnixTimestamp !== undefined) {
                localVarQueryParameter['max_published_unix_timestamp'] = maxPublishedUnixTimestamp;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (searchName !== undefined) {
                localVarQueryParameter['search_name'] = searchName;
            }

            if (searchDescription !== undefined) {
                localVarQueryParameter['search_description'] = searchDescription;
            }

            if (onlyLatest !== undefined) {
                localVarQueryParameter['only_latest'] = onlyLatest;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (buildId !== undefined) {
                localVarQueryParameter['build_id'] = buildId;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (rollupCategory !== undefined) {
                localVarQueryParameter['rollup_category'] = rollupCategory;
            }

            if (authorId !== undefined) {
                localVarQueryParameter['author_id'] = authorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuildsApi - functional programming interface
 * @export
 */
export const BuildsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuildsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Search for builds based on various criteria.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Search
         * @param {number} [minUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [maxUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [minPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {number} [maxPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {SearchBuildsSortByEnum} [sortBy] The field to sort the builds by.
         * @param {number} [start] The index of the first build to return.
         * @param {number} [limit] The maximum number of builds to return.
         * @param {SearchBuildsSortDirectionEnum} [sortDirection] The direction to sort the builds in.
         * @param {string} [searchName] Search for builds with a name containing this string.
         * @param {string} [searchDescription] Search for builds with a description containing this string.
         * @param {boolean} [onlyLatest] Only return the latest version of each build.
         * @param {number} [language] Filter builds by language.
         * @param {number} [buildId] Filter builds by ID.
         * @param {number} [version] Filter builds by version.
         * @param {number} [heroId] Filter builds by hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number} [tag] Filter builds by tag.
         * @param {number} [rollupCategory] Filter builds by rollup category.
         * @param {number} [authorId] The author\&#39;s &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBuilds(minUnixTimestamp?: number, maxUnixTimestamp?: number, minPublishedUnixTimestamp?: number, maxPublishedUnixTimestamp?: number, sortBy?: SearchBuildsSortByEnum, start?: number, limit?: number, sortDirection?: SearchBuildsSortDirectionEnum, searchName?: string, searchDescription?: string, onlyLatest?: boolean, language?: number, buildId?: number, version?: number, heroId?: number, tag?: number, rollupCategory?: number, authorId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Build>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBuilds(minUnixTimestamp, maxUnixTimestamp, minPublishedUnixTimestamp, maxPublishedUnixTimestamp, sortBy, start, limit, sortDirection, searchName, searchDescription, onlyLatest, language, buildId, version, heroId, tag, rollupCategory, authorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuildsApi.searchBuilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BuildsApi - factory interface
 * @export
 */
export const BuildsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuildsApiFp(configuration)
    return {
        /**
         *  Search for builds based on various criteria.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Search
         * @param {number} [minUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [maxUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [minPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {number} [maxPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {SearchBuildsSortByEnum} [sortBy] The field to sort the builds by.
         * @param {number} [start] The index of the first build to return.
         * @param {number} [limit] The maximum number of builds to return.
         * @param {SearchBuildsSortDirectionEnum} [sortDirection] The direction to sort the builds in.
         * @param {string} [searchName] Search for builds with a name containing this string.
         * @param {string} [searchDescription] Search for builds with a description containing this string.
         * @param {boolean} [onlyLatest] Only return the latest version of each build.
         * @param {number} [language] Filter builds by language.
         * @param {number} [buildId] Filter builds by ID.
         * @param {number} [version] Filter builds by version.
         * @param {number} [heroId] Filter builds by hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number} [tag] Filter builds by tag.
         * @param {number} [rollupCategory] Filter builds by rollup category.
         * @param {number} [authorId] The author\&#39;s &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBuilds(minUnixTimestamp?: number, maxUnixTimestamp?: number, minPublishedUnixTimestamp?: number, maxPublishedUnixTimestamp?: number, sortBy?: SearchBuildsSortByEnum, start?: number, limit?: number, sortDirection?: SearchBuildsSortDirectionEnum, searchName?: string, searchDescription?: string, onlyLatest?: boolean, language?: number, buildId?: number, version?: number, heroId?: number, tag?: number, rollupCategory?: number, authorId?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Build>> {
            return localVarFp.searchBuilds(minUnixTimestamp, maxUnixTimestamp, minPublishedUnixTimestamp, maxPublishedUnixTimestamp, sortBy, start, limit, sortDirection, searchName, searchDescription, onlyLatest, language, buildId, version, heroId, tag, rollupCategory, authorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BuildsApi - object-oriented interface
 * @export
 * @class BuildsApi
 * @extends {BaseAPI}
 */
export class BuildsApi extends BaseAPI {
    /**
     *  Search for builds based on various criteria.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Search
     * @param {number} [minUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
     * @param {number} [maxUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
     * @param {number} [minPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
     * @param {number} [maxPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
     * @param {SearchBuildsSortByEnum} [sortBy] The field to sort the builds by.
     * @param {number} [start] The index of the first build to return.
     * @param {number} [limit] The maximum number of builds to return.
     * @param {SearchBuildsSortDirectionEnum} [sortDirection] The direction to sort the builds in.
     * @param {string} [searchName] Search for builds with a name containing this string.
     * @param {string} [searchDescription] Search for builds with a description containing this string.
     * @param {boolean} [onlyLatest] Only return the latest version of each build.
     * @param {number} [language] Filter builds by language.
     * @param {number} [buildId] Filter builds by ID.
     * @param {number} [version] Filter builds by version.
     * @param {number} [heroId] Filter builds by hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {number} [tag] Filter builds by tag.
     * @param {number} [rollupCategory] Filter builds by rollup category.
     * @param {number} [authorId] The author\&#39;s &#x60;SteamID3&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BuildsApi
     */
    public searchBuilds(minUnixTimestamp?: number, maxUnixTimestamp?: number, minPublishedUnixTimestamp?: number, maxPublishedUnixTimestamp?: number, sortBy?: SearchBuildsSortByEnum, start?: number, limit?: number, sortDirection?: SearchBuildsSortDirectionEnum, searchName?: string, searchDescription?: string, onlyLatest?: boolean, language?: number, buildId?: number, version?: number, heroId?: number, tag?: number, rollupCategory?: number, authorId?: number, options?: RawAxiosRequestConfig) {
        return BuildsApiFp(this.configuration).searchBuilds(minUnixTimestamp, maxUnixTimestamp, minPublishedUnixTimestamp, maxPublishedUnixTimestamp, sortBy, start, limit, sortDirection, searchName, searchDescription, onlyLatest, language, buildId, version, heroId, tag, rollupCategory, authorId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SearchBuildsSortByEnum = {
    WeeklyFavorites: 'weekly_favorites',
    Favorites: 'favorites',
    Ignores: 'ignores',
    Reports: 'reports',
    UpdatedAt: 'updated_at',
    PublishedAt: 'published_at',
    Version: 'version'
} as const;
export type SearchBuildsSortByEnum = typeof SearchBuildsSortByEnum[keyof typeof SearchBuildsSortByEnum];
/**
 * @export
 */
export const SearchBuildsSortDirectionEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;
export type SearchBuildsSortDirectionEnum = typeof SearchBuildsSortDirectionEnum[keyof typeof SearchBuildsSortDirectionEnum];


/**
 * CommandsApi - axios parameter creator
 * @export
 */
export const CommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a list of available variables that can be used in the command endpoint.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Available Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableVariables: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/commands/variables/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      Resolves a command and returns the resolved command.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/60s | | Key | - | | Global | 300req/60s |     
         * @summary Resolve Command
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {CommandResolveRegionEnum} [region] The players region
         * @param {string} [template] The command template to resolve
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandResolve: async (accountId: number, region?: CommandResolveRegionEnum, template?: string, heroName?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('commandResolve', 'accountId', accountId)
            const localVarPath = `/v1/commands/resolve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }

            if (heroName !== undefined) {
                localVarQueryParameter['hero_name'] = heroName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Resolves variables and returns a map of variable name to resolved value.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/min | | Key | - | | Global | 300req/min |     
         * @summary Resolve Variables
         * @param {number} accountId 
         * @param {VariablesResolveRegionEnum} [region] 
         * @param {string} [variables] Variables to resolve, separated by commas.
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variablesResolve: async (accountId: number, region?: VariablesResolveRegionEnum, variables?: string, heroName?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('variablesResolve', 'accountId', accountId)
            const localVarPath = `/v1/commands/variables/resolve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (heroName !== undefined) {
                localVarQueryParameter['hero_name'] = heroName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a map of str->int of widget versions.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Widget Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetVersions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/commands/widgets/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 * @export
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a list of available variables that can be used in the command endpoint.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Available Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableVariables(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariableDescription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableVariables(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.availableVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      Resolves a command and returns the resolved command.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/60s | | Key | - | | Global | 300req/60s |     
         * @summary Resolve Command
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {CommandResolveRegionEnum} [region] The players region
         * @param {string} [template] The command template to resolve
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandResolve(accountId: number, region?: CommandResolveRegionEnum, template?: string, heroName?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandResolve(accountId, region, template, heroName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.commandResolve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Resolves variables and returns a map of variable name to resolved value.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/min | | Key | - | | Global | 300req/min |     
         * @summary Resolve Variables
         * @param {number} accountId 
         * @param {VariablesResolveRegionEnum} [region] 
         * @param {string} [variables] Variables to resolve, separated by commas.
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variablesResolve(accountId: number, region?: VariablesResolveRegionEnum, variables?: string, heroName?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variablesResolve(accountId, region, variables, heroName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.variablesResolve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns a map of str->int of widget versions.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Widget Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async widgetVersions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.widgetVersions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.widgetVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommandsApi - factory interface
 * @export
 */
export const CommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandsApiFp(configuration)
    return {
        /**
         *  Returns a list of available variables that can be used in the command endpoint.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Available Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableVariables(options?: RawAxiosRequestConfig): AxiosPromise<Array<VariableDescription>> {
            return localVarFp.availableVariables(options).then((request) => request(axios, basePath));
        },
        /**
         *      Resolves a command and returns the resolved command.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/60s | | Key | - | | Global | 300req/60s |     
         * @summary Resolve Command
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {CommandResolveRegionEnum} [region] The players region
         * @param {string} [template] The command template to resolve
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandResolve(accountId: number, region?: CommandResolveRegionEnum, template?: string, heroName?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.commandResolve(accountId, region, template, heroName, options).then((request) => request(axios, basePath));
        },
        /**
         *  Resolves variables and returns a map of variable name to resolved value.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/min | | Key | - | | Global | 300req/min |     
         * @summary Resolve Variables
         * @param {number} accountId 
         * @param {VariablesResolveRegionEnum} [region] 
         * @param {string} [variables] Variables to resolve, separated by commas.
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variablesResolve(accountId: number, region?: VariablesResolveRegionEnum, variables?: string, heroName?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.variablesResolve(accountId, region, variables, heroName, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a map of str->int of widget versions.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Widget Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetVersions(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.widgetVersions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandsApi - object-oriented interface
 * @export
 * @class CommandsApi
 * @extends {BaseAPI}
 */
export class CommandsApi extends BaseAPI {
    /**
     *  Returns a list of available variables that can be used in the command endpoint.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Available Variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public availableVariables(options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).availableVariables(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      Resolves a command and returns the resolved command.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/60s | | Key | - | | Global | 300req/60s |     
     * @summary Resolve Command
     * @param {number} accountId The players &#x60;SteamID3&#x60;
     * @param {CommandResolveRegionEnum} [region] The players region
     * @param {string} [template] The command template to resolve
     * @param {string | null} [heroName] Hero name to check for hero specific stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public commandResolve(accountId: number, region?: CommandResolveRegionEnum, template?: string, heroName?: string | null, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).commandResolve(accountId, region, template, heroName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Resolves variables and returns a map of variable name to resolved value.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/min | | Key | - | | Global | 300req/min |     
     * @summary Resolve Variables
     * @param {number} accountId 
     * @param {VariablesResolveRegionEnum} [region] 
     * @param {string} [variables] Variables to resolve, separated by commas.
     * @param {string | null} [heroName] Hero name to check for hero specific stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public variablesResolve(accountId: number, region?: VariablesResolveRegionEnum, variables?: string, heroName?: string | null, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).variablesResolve(accountId, region, variables, heroName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a map of str->int of widget versions.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
     * @summary Widget Versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandsApi
     */
    public widgetVersions(options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).widgetVersions(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CommandResolveRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type CommandResolveRegionEnum = typeof CommandResolveRegionEnum[keyof typeof CommandResolveRegionEnum];
/**
 * @export
 */
export const VariablesResolveRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type VariablesResolveRegionEnum = typeof VariablesResolveRegionEnum[keyof typeof VariablesResolveRegionEnum];


/**
 * CustomMatchesApi - axios parameter creator
 * @export
 */
export const CustomMatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  This endpoint creates a custom match using a bot account.  **Process:** 1. A party is created with your provided settings. 2. The system waits for the party code to be generated. 3. The party code is returned in the response. 4. The bot switches to spectator mode. 5. The bot marks itself as ready. 6. You and other players join, ready up, and start the match.  **Callbacks:** If a callback URL is provided, POST requests will be sent to it: - **settings:** When lobby settings change, a POST is sent to `{callback_url}/settings` with the `CsoCitadelParty` protobuf message as JSON. - **match start:** When the match starts, a POST is sent to `{callback_url}` with the match ID.  _Protobuf definitions: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)_  **Note:** The bot will leave the match 15 minutes after creation, regardless of match state.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
         * @summary Create Match
         * @param {CreateCustomRequest} createCustomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustom: async (createCustomRequest: CreateCustomRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomRequest' is not null or undefined
            assertParamExists('createCustom', 'createCustomRequest', createCustomRequest)
            const localVarPath = `/v1/matches/custom/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint allows you to get the match id of a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Get Match ID
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustom: async (partyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyId' is not null or undefined
            assertParamExists('getCustom', 'partyId', partyId)
            const localVarPath = `/v1/matches/custom/{party_id}/match-id`
                .replace(`{${"party_id"}}`, encodeURIComponent(String(partyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomMatchesApi - functional programming interface
 * @export
 */
export const CustomMatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomMatchesApiAxiosParamCreator(configuration)
    return {
        /**
         *  This endpoint creates a custom match using a bot account.  **Process:** 1. A party is created with your provided settings. 2. The system waits for the party code to be generated. 3. The party code is returned in the response. 4. The bot switches to spectator mode. 5. The bot marks itself as ready. 6. You and other players join, ready up, and start the match.  **Callbacks:** If a callback URL is provided, POST requests will be sent to it: - **settings:** When lobby settings change, a POST is sent to `{callback_url}/settings` with the `CsoCitadelParty` protobuf message as JSON. - **match start:** When the match starts, a POST is sent to `{callback_url}` with the match ID.  _Protobuf definitions: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)_  **Note:** The bot will leave the match 15 minutes after creation, regardless of match state.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
         * @summary Create Match
         * @param {CreateCustomRequest} createCustomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustom(createCustomRequest: CreateCustomRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustom(createCustomRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomMatchesApi.createCustom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint allows you to get the match id of a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Get Match ID
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustom(partyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomMatchIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustom(partyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomMatchesApi.getCustom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomMatchesApi - factory interface
 * @export
 */
export const CustomMatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomMatchesApiFp(configuration)
    return {
        /**
         *  This endpoint creates a custom match using a bot account.  **Process:** 1. A party is created with your provided settings. 2. The system waits for the party code to be generated. 3. The party code is returned in the response. 4. The bot switches to spectator mode. 5. The bot marks itself as ready. 6. You and other players join, ready up, and start the match.  **Callbacks:** If a callback URL is provided, POST requests will be sent to it: - **settings:** When lobby settings change, a POST is sent to `{callback_url}/settings` with the `CsoCitadelParty` protobuf message as JSON. - **match start:** When the match starts, a POST is sent to `{callback_url}` with the match ID.  _Protobuf definitions: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)_  **Note:** The bot will leave the match 15 minutes after creation, regardless of match state.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
         * @summary Create Match
         * @param {CreateCustomRequest} createCustomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustom(createCustomRequest: CreateCustomRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCustomResponse> {
            return localVarFp.createCustom(createCustomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint allows you to get the match id of a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Get Match ID
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustom(partyId: number, options?: RawAxiosRequestConfig): AxiosPromise<GetCustomMatchIdResponse> {
            return localVarFp.getCustom(partyId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomMatchesApi - object-oriented interface
 * @export
 * @class CustomMatchesApi
 * @extends {BaseAPI}
 */
export class CustomMatchesApi extends BaseAPI {
    /**
     *  This endpoint creates a custom match using a bot account.  **Process:** 1. A party is created with your provided settings. 2. The system waits for the party code to be generated. 3. The party code is returned in the response. 4. The bot switches to spectator mode. 5. The bot marks itself as ready. 6. You and other players join, ready up, and start the match.  **Callbacks:** If a callback URL is provided, POST requests will be sent to it: - **settings:** When lobby settings change, a POST is sent to `{callback_url}/settings` with the `CsoCitadelParty` protobuf message as JSON. - **match start:** When the match starts, a POST is sent to `{callback_url}` with the match ID.  _Protobuf definitions: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)_  **Note:** The bot will leave the match 15 minutes after creation, regardless of match state.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
     * @summary Create Match
     * @param {CreateCustomRequest} createCustomRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomMatchesApi
     */
    public createCustom(createCustomRequest: CreateCustomRequest, options?: RawAxiosRequestConfig) {
        return CustomMatchesApiFp(this.configuration).createCustom(createCustomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint allows you to get the match id of a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
     * @summary Get Match ID
     * @param {number} partyId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomMatchesApi
     */
    public getCustom(partyId: number, options?: RawAxiosRequestConfig) {
        return CustomMatchesApiFp(this.configuration).getCustom(partyId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ESportsApi - axios parameter creator
 * @export
 */
export const ESportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  To use this Endpoint you need to have special permissions. Please contact us if you organize E-Sports Matches and want to ingest them to us.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 1000req/h | | Key | - | | Global | 10000req/h |     
         * @summary Ingest
         * @param {ESportsMatch} eSportsMatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestMatch: async (eSportsMatch: ESportsMatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eSportsMatch' is not null or undefined
            assertParamExists('ingestMatch', 'eSportsMatch', eSportsMatch)
            const localVarPath = `/v1/esports/ingest/match`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eSportsMatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/esports/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ESportsApi - functional programming interface
 * @export
 */
export const ESportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ESportsApiAxiosParamCreator(configuration)
    return {
        /**
         *  To use this Endpoint you need to have special permissions. Please contact us if you organize E-Sports Matches and want to ingest them to us.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 1000req/h | | Key | - | | Global | 10000req/h |     
         * @summary Ingest
         * @param {ESportsMatch} eSportsMatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestMatch(eSportsMatch: ESportsMatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestMatch(eSportsMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ESportsApi.ingestMatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ESportsMatch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ESportsApi.matches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ESportsApi - factory interface
 * @export
 */
export const ESportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ESportsApiFp(configuration)
    return {
        /**
         *  To use this Endpoint you need to have special permissions. Please contact us if you organize E-Sports Matches and want to ingest them to us.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 1000req/h | | Key | - | | Global | 10000req/h |     
         * @summary Ingest
         * @param {ESportsMatch} eSportsMatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestMatch(eSportsMatch: ESportsMatch, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ingestMatch(eSportsMatch, options).then((request) => request(axios, basePath));
        },
        /**
         *  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matches(options?: RawAxiosRequestConfig): AxiosPromise<Array<ESportsMatch>> {
            return localVarFp.matches(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ESportsApi - object-oriented interface
 * @export
 * @class ESportsApi
 * @extends {BaseAPI}
 */
export class ESportsApi extends BaseAPI {
    /**
     *  To use this Endpoint you need to have special permissions. Please contact us if you organize E-Sports Matches and want to ingest them to us.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 1000req/h | | Key | - | | Global | 10000req/h |     
     * @summary Ingest
     * @param {ESportsMatch} eSportsMatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ESportsApi
     */
    public ingestMatch(eSportsMatch: ESportsMatch, options?: RawAxiosRequestConfig) {
        return ESportsApiFp(this.configuration).ingestMatch(eSportsMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary List Matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ESportsApi
     */
    public matches(options?: RawAxiosRequestConfig) {
        return ESportsApiFp(this.configuration).matches(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoApi - axios parameter creator
 * @export
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Checks the health of the services.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/info/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns information about the API.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary API Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 * @export
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         *  Checks the health of the services.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns information about the API.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary API Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async info(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.info(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.info']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 * @export
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         *  Checks the health of the services.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns information about the API.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary API Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info(options?: RawAxiosRequestConfig): AxiosPromise<APIInfo> {
            return localVarFp.info(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 * @export
 * @class InfoApi
 * @extends {BaseAPI}
 */
export class InfoApi extends BaseAPI {
    /**
     *  Checks the health of the services.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public healthCheck(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns information about the API.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary API Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoApi
     */
    public info(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).info(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalApi - axios parameter creator
 * @export
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  You can use this endpoint to help us collecting data.  The endpoint accepts a list of MatchSalts objects, which contain the following fields:  - `match_id`: The match ID - `cluster_id`: The cluster ID - `metadata_salt`: The metadata salt - `replay_salt`: The replay salt - `username`: The username of the person who submitted the match  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Match Salts Ingest
         * @param {Array<ClickhouseSalts>} clickhouseSalts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestSalts: async (clickhouseSalts: Array<ClickhouseSalts>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clickhouseSalts' is not null or undefined
            assertParamExists('ingestSalts', 'clickhouseSalts', clickhouseSalts)
            const localVarPath = `/v1/matches/salts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clickhouseSalts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 * @export
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         *  You can use this endpoint to help us collecting data.  The endpoint accepts a list of MatchSalts objects, which contain the following fields:  - `match_id`: The match ID - `cluster_id`: The cluster ID - `metadata_salt`: The metadata salt - `replay_salt`: The replay salt - `username`: The username of the person who submitted the match  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Match Salts Ingest
         * @param {Array<ClickhouseSalts>} clickhouseSalts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestSalts(clickhouseSalts: Array<ClickhouseSalts>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestSalts(clickhouseSalts, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.ingestSalts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternalApi - factory interface
 * @export
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         *  You can use this endpoint to help us collecting data.  The endpoint accepts a list of MatchSalts objects, which contain the following fields:  - `match_id`: The match ID - `cluster_id`: The cluster ID - `metadata_salt`: The metadata salt - `replay_salt`: The replay salt - `username`: The username of the person who submitted the match  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Match Salts Ingest
         * @param {Array<ClickhouseSalts>} clickhouseSalts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestSalts(clickhouseSalts: Array<ClickhouseSalts>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ingestSalts(clickhouseSalts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InternalApi - object-oriented interface
 * @export
 * @class InternalApi
 * @extends {BaseAPI}
 */
export class InternalApi extends BaseAPI {
    /**
     *  You can use this endpoint to help us collecting data.  The endpoint accepts a list of MatchSalts objects, which contain the following fields:  - `match_id`: The match ID - `cluster_id`: The cluster ID - `metadata_salt`: The metadata salt - `replay_salt`: The replay salt - `username`: The username of the person who submitted the match  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Match Salts Ingest
     * @param {Array<ClickhouseSalts>} clickhouseSalts 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InternalApi
     */
    public ingestSalts(clickhouseSalts: Array<ClickhouseSalts>, options?: RawAxiosRequestConfig) {
        return InternalApiFp(this.configuration).ingestSalts(clickhouseSalts, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LeaderboardApi - axios parameter creator
 * @export
 */
export const LeaderboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns the leaderboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard
         * @param {LeaderboardRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboard: async (region: LeaderboardRegionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('leaderboard', 'region', region)
            const localVarPath = `/v1/leaderboard/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the leaderboard for a specific hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard
         * @param {LeaderboardHeroRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardHero: async (region: LeaderboardHeroRegionEnum, heroId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('leaderboardHero', 'region', region)
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('leaderboardHero', 'heroId', heroId)
            const localVarPath = `/v1/leaderboard/{region}/{hero_id}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"hero_id"}}`, encodeURIComponent(String(heroId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the leaderboard for a specific hero, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard as Protobuf
         * @param {LeaderboardHeroRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardHeroRaw: async (region: LeaderboardHeroRawRegionEnum, heroId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('leaderboardHeroRaw', 'region', region)
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('leaderboardHeroRaw', 'heroId', heroId)
            const localVarPath = `/v1/leaderboard/{region}/{hero_id}/raw`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"hero_id"}}`, encodeURIComponent(String(heroId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the leaderboard, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard as Protobuf
         * @param {LeaderboardRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardRaw: async (region: LeaderboardRawRegionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('leaderboardRaw', 'region', region)
            const localVarPath = `/v1/leaderboard/{region}/raw`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardApi - functional programming interface
 * @export
 */
export const LeaderboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeaderboardApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns the leaderboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard
         * @param {LeaderboardRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboard(region: LeaderboardRegionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Leaderboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboard(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.leaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the leaderboard for a specific hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard
         * @param {LeaderboardHeroRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardHero(region: LeaderboardHeroRegionEnum, heroId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Leaderboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardHero(region, heroId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.leaderboardHero']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the leaderboard for a specific hero, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard as Protobuf
         * @param {LeaderboardHeroRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardHeroRaw(region: LeaderboardHeroRawRegionEnum, heroId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardHeroRaw(region, heroId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.leaderboardHeroRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the leaderboard, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard as Protobuf
         * @param {LeaderboardRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardRaw(region: LeaderboardRawRegionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardRaw(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.leaderboardRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeaderboardApi - factory interface
 * @export
 */
export const LeaderboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeaderboardApiFp(configuration)
    return {
        /**
         *  Returns the leaderboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard
         * @param {LeaderboardRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboard(region: LeaderboardRegionEnum, options?: RawAxiosRequestConfig): AxiosPromise<Leaderboard> {
            return localVarFp.leaderboard(region, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the leaderboard for a specific hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard
         * @param {LeaderboardHeroRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardHero(region: LeaderboardHeroRegionEnum, heroId: number, options?: RawAxiosRequestConfig): AxiosPromise<Leaderboard> {
            return localVarFp.leaderboardHero(region, heroId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the leaderboard for a specific hero, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard as Protobuf
         * @param {LeaderboardHeroRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardHeroRaw(region: LeaderboardHeroRawRegionEnum, heroId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.leaderboardHeroRaw(region, heroId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the leaderboard, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard as Protobuf
         * @param {LeaderboardRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardRaw(region: LeaderboardRawRegionEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.leaderboardRaw(region, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeaderboardApi - object-oriented interface
 * @export
 * @class LeaderboardApi
 * @extends {BaseAPI}
 */
export class LeaderboardApi extends BaseAPI {
    /**
     *  Returns the leaderboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Leaderboard
     * @param {LeaderboardRegionEnum} region The region to fetch the leaderboard for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboard(region: LeaderboardRegionEnum, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).leaderboard(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the leaderboard for a specific hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Leaderboard
     * @param {LeaderboardHeroRegionEnum} region The region to fetch the leaderboard for.
     * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardHero(region: LeaderboardHeroRegionEnum, heroId: number, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).leaderboardHero(region, heroId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the leaderboard for a specific hero, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Leaderboard as Protobuf
     * @param {LeaderboardHeroRawRegionEnum} region The region to fetch the leaderboard for.
     * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardHeroRaw(region: LeaderboardHeroRawRegionEnum, heroId: number, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).leaderboardHeroRaw(region, heroId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the leaderboard, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Leaderboard as Protobuf
     * @param {LeaderboardRawRegionEnum} region The region to fetch the leaderboard for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeaderboardApi
     */
    public leaderboardRaw(region: LeaderboardRawRegionEnum, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).leaderboardRaw(region, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const LeaderboardRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type LeaderboardRegionEnum = typeof LeaderboardRegionEnum[keyof typeof LeaderboardRegionEnum];
/**
 * @export
 */
export const LeaderboardHeroRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type LeaderboardHeroRegionEnum = typeof LeaderboardHeroRegionEnum[keyof typeof LeaderboardHeroRegionEnum];
/**
 * @export
 */
export const LeaderboardHeroRawRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type LeaderboardHeroRawRegionEnum = typeof LeaderboardHeroRawRegionEnum[keyof typeof LeaderboardHeroRawRegionEnum];
/**
 * @export
 */
export const LeaderboardRawRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type LeaderboardRawRegionEnum = typeof LeaderboardRawRegionEnum[keyof typeof LeaderboardRawRegionEnum];


/**
 * MMRApi - axios parameter creator
 * @export
 */
export const MMRApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Batch Player Hero MMR
         * @summary Hero MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmr: async (accountIds: Array<number>, heroId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIds' is not null or undefined
            assertParamExists('heroMmr', 'accountIds', accountIds)
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('heroMmr', 'heroId', heroId)
            const localVarPath = `/v1/players/mmr/{hero_id}`
                .replace(`{${"hero_id"}}`, encodeURIComponent(String(heroId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Player Hero MMR History
         * @summary Hero MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmrHistory: async (accountId: number, heroId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('heroMmrHistory', 'accountId', accountId)
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('heroMmrHistory', 'heroId', heroId)
            const localVarPath = `/v1/players/{account_id}/mmr-history/{hero_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"hero_id"}}`, encodeURIComponent(String(heroId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Batch Player MMR
         * @summary MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmr: async (accountIds: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIds' is not null or undefined
            assertParamExists('mmr', 'accountIds', accountIds)
            const localVarPath = `/v1/players/mmr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Player MMR History
         * @summary MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmrHistory: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('mmrHistory', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/mmr-history`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MMRApi - functional programming interface
 * @export
 */
export const MMRApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MMRApiAxiosParamCreator(configuration)
    return {
        /**
         * Batch Player Hero MMR
         * @summary Hero MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroMmr(accountIds: Array<number>, heroId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MMRHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroMmr(accountIds, heroId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.heroMmr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Player Hero MMR History
         * @summary Hero MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroMmrHistory(accountId: number, heroId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MMRHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroMmrHistory(accountId, heroId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.heroMmrHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Batch Player MMR
         * @summary MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mmr(accountIds: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MMRHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mmr(accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.mmr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Player MMR History
         * @summary MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mmrHistory(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MMRHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mmrHistory(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.mmrHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MMRApi - factory interface
 * @export
 */
export const MMRApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MMRApiFp(configuration)
    return {
        /**
         * Batch Player Hero MMR
         * @summary Hero MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmr(accountIds: Array<number>, heroId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MMRHistory>> {
            return localVarFp.heroMmr(accountIds, heroId, options).then((request) => request(axios, basePath));
        },
        /**
         * Player Hero MMR History
         * @summary Hero MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmrHistory(accountId: number, heroId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MMRHistory>> {
            return localVarFp.heroMmrHistory(accountId, heroId, options).then((request) => request(axios, basePath));
        },
        /**
         * Batch Player MMR
         * @summary MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmr(accountIds: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<Array<MMRHistory>> {
            return localVarFp.mmr(accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Player MMR History
         * @summary MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmrHistory(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<MMRHistory>> {
            return localVarFp.mmrHistory(accountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MMRApi - object-oriented interface
 * @export
 * @class MMRApi
 * @extends {BaseAPI}
 */
export class MMRApi extends BaseAPI {
    /**
     * Batch Player Hero MMR
     * @summary Hero MMR
     * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMRApi
     */
    public heroMmr(accountIds: Array<number>, heroId: number, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).heroMmr(accountIds, heroId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Player Hero MMR History
     * @summary Hero MMR History
     * @param {number} accountId The players &#x60;SteamID3&#x60;
     * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMRApi
     */
    public heroMmrHistory(accountId: number, heroId: number, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).heroMmrHistory(accountId, heroId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Batch Player MMR
     * @summary MMR
     * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMRApi
     */
    public mmr(accountIds: Array<number>, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).mmr(accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Player MMR History
     * @summary MMR History
     * @param {number} accountId The players &#x60;SteamID3&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MMRApi
     */
    public mmrHistory(accountId: number, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).mmrHistory(accountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MatchesApi - axios parameter creator
 * @export
 */
export const MatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active
         * @param {number | null} [accountId] The account ID to filter active matches by (&#x60;SteamID3&#x60;)
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeMatches: async (accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active as Protobuf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeMatchesRaw: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/active/raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Badge Distribution
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgeDistribution: async (minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/badge-distribution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
         * @summary Bulk Metadata
         * @param {boolean} [includeInfo] Include match info in the response.
         * @param {boolean} [includeObjectives] Include objectives in the response.
         * @param {boolean} [includeMidBoss] Include midboss in the response.
         * @param {boolean} [includePlayerInfo] Include player info in the response.
         * @param {boolean} [includePlayerItems] Include player items in the response.
         * @param {boolean} [includePlayerStats] Include player stats in the response.
         * @param {boolean} [includePlayerDeathDetails] Include player death details in the response.
         * @param {Array<number> | null} [matchIds] Comma separated list of match ids, limited by &#x60;limit&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {Array<number> | null} [accountIds] Filter matches by account IDs of players that participated in the match.
         * @param {BulkMetadataOrderByEnum} [orderBy] The field to order the results by.
         * @param {BulkMetadataOrderDirectionEnum} [orderDirection] The direction to order the results by.
         * @param {number} [limit] The maximum number of matches to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkMetadata: async (includeInfo?: boolean, includeObjectives?: boolean, includeMidBoss?: boolean, includePlayerInfo?: boolean, includePlayerItems?: boolean, includePlayerStats?: boolean, includePlayerDeathDetails?: boolean, matchIds?: Array<number> | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, accountIds?: Array<number> | null, orderBy?: BulkMetadataOrderByEnum, orderDirection?: BulkMetadataOrderDirectionEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeInfo !== undefined) {
                localVarQueryParameter['include_info'] = includeInfo;
            }

            if (includeObjectives !== undefined) {
                localVarQueryParameter['include_objectives'] = includeObjectives;
            }

            if (includeMidBoss !== undefined) {
                localVarQueryParameter['include_mid_boss'] = includeMidBoss;
            }

            if (includePlayerInfo !== undefined) {
                localVarQueryParameter['include_player_info'] = includePlayerInfo;
            }

            if (includePlayerItems !== undefined) {
                localVarQueryParameter['include_player_items'] = includePlayerItems;
            }

            if (includePlayerStats !== undefined) {
                localVarQueryParameter['include_player_stats'] = includePlayerStats;
            }

            if (includePlayerDeathDetails !== undefined) {
                localVarQueryParameter['include_player_death_details'] = includePlayerDeathDetails;
            }

            if (matchIds) {
                localVarQueryParameter['match_ids'] = matchIds;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (isHighSkillRangeParties !== undefined) {
                localVarQueryParameter['is_high_skill_range_parties'] = isHighSkillRangeParties;
            }

            if (isLowPriPool !== undefined) {
                localVarQueryParameter['is_low_pri_pool'] = isLowPriPool;
            }

            if (isNewPlayerPool !== undefined) {
                localVarQueryParameter['is_new_player_pool'] = isNewPlayerPool;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadata: async (matchId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('metadata', 'matchId', matchId)
            const localVarPath = `/v1/matches/{match_id}/metadata`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata as Protobuf
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataRaw: async (matchId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('metadataRaw', 'matchId', matchId)
            const localVarPath = `/v1/matches/{match_id}/metadata/raw`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Recently Fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentlyFetched: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/recently-fetched`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
         * @summary Salts
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salts: async (matchId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('salts', 'matchId', matchId)
            const localVarPath = `/v1/matches/{match_id}/salts`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
         * @summary Live Broadcast URL
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        url: async (matchId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('url', 'matchId', matchId)
            const localVarPath = `/v1/matches/{match_id}/live/url`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchesApi - functional programming interface
 * @export
 */
export const MatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active
         * @param {number | null} [accountId] The account ID to filter active matches by (&#x60;SteamID3&#x60;)
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeMatches(accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveMatch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeMatches(accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.activeMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active as Protobuf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeMatchesRaw(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeMatchesRaw(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.activeMatchesRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Badge Distribution
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async badgeDistribution(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BadgeDistribution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.badgeDistribution(minUnixTimestamp, maxUnixTimestamp, minMatchId, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.badgeDistribution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
         * @summary Bulk Metadata
         * @param {boolean} [includeInfo] Include match info in the response.
         * @param {boolean} [includeObjectives] Include objectives in the response.
         * @param {boolean} [includeMidBoss] Include midboss in the response.
         * @param {boolean} [includePlayerInfo] Include player info in the response.
         * @param {boolean} [includePlayerItems] Include player items in the response.
         * @param {boolean} [includePlayerStats] Include player stats in the response.
         * @param {boolean} [includePlayerDeathDetails] Include player death details in the response.
         * @param {Array<number> | null} [matchIds] Comma separated list of match ids, limited by &#x60;limit&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {Array<number> | null} [accountIds] Filter matches by account IDs of players that participated in the match.
         * @param {BulkMetadataOrderByEnum} [orderBy] The field to order the results by.
         * @param {BulkMetadataOrderDirectionEnum} [orderDirection] The direction to order the results by.
         * @param {number} [limit] The maximum number of matches to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkMetadata(includeInfo?: boolean, includeObjectives?: boolean, includeMidBoss?: boolean, includePlayerInfo?: boolean, includePlayerItems?: boolean, includePlayerStats?: boolean, includePlayerDeathDetails?: boolean, matchIds?: Array<number> | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, accountIds?: Array<number> | null, orderBy?: BulkMetadataOrderByEnum, orderDirection?: BulkMetadataOrderDirectionEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkMetadata(includeInfo, includeObjectives, includeMidBoss, includePlayerInfo, includePlayerItems, includePlayerStats, includePlayerDeathDetails, matchIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, accountIds, orderBy, orderDirection, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.bulkMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metadata(matchId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metadata(matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.metadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata as Protobuf
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metadataRaw(matchId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metadataRaw(matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.metadataRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Recently Fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentlyFetched(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClickhouseMatchInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentlyFetched(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.recentlyFetched']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
         * @summary Salts
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async salts(matchId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchSaltsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.salts(matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.salts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
         * @summary Live Broadcast URL
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async url(matchId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchSpectateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.url(matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.url']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MatchesApi - factory interface
 * @export
 */
export const MatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchesApiFp(configuration)
    return {
        /**
         *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active
         * @param {number | null} [accountId] The account ID to filter active matches by (&#x60;SteamID3&#x60;)
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeMatches(accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActiveMatch>> {
            return localVarFp.activeMatches(accountId, accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active as Protobuf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeMatchesRaw(options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.activeMatchesRaw(options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Badge Distribution
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgeDistribution(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<BadgeDistribution>> {
            return localVarFp.badgeDistribution(minUnixTimestamp, maxUnixTimestamp, minMatchId, maxMatchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
         * @summary Bulk Metadata
         * @param {boolean} [includeInfo] Include match info in the response.
         * @param {boolean} [includeObjectives] Include objectives in the response.
         * @param {boolean} [includeMidBoss] Include midboss in the response.
         * @param {boolean} [includePlayerInfo] Include player info in the response.
         * @param {boolean} [includePlayerItems] Include player items in the response.
         * @param {boolean} [includePlayerStats] Include player stats in the response.
         * @param {boolean} [includePlayerDeathDetails] Include player death details in the response.
         * @param {Array<number> | null} [matchIds] Comma separated list of match ids, limited by &#x60;limit&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {Array<number> | null} [accountIds] Filter matches by account IDs of players that participated in the match.
         * @param {BulkMetadataOrderByEnum} [orderBy] The field to order the results by.
         * @param {BulkMetadataOrderDirectionEnum} [orderDirection] The direction to order the results by.
         * @param {number} [limit] The maximum number of matches to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkMetadata(includeInfo?: boolean, includeObjectives?: boolean, includeMidBoss?: boolean, includePlayerInfo?: boolean, includePlayerItems?: boolean, includePlayerStats?: boolean, includePlayerDeathDetails?: boolean, matchIds?: Array<number> | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, accountIds?: Array<number> | null, orderBy?: BulkMetadataOrderByEnum, orderDirection?: BulkMetadataOrderDirectionEnum, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.bulkMetadata(includeInfo, includeObjectives, includeMidBoss, includePlayerInfo, includePlayerItems, includePlayerStats, includePlayerDeathDetails, matchIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, accountIds, orderBy, orderDirection, limit, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadata(matchId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metadata(matchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata as Protobuf
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataRaw(matchId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.metadataRaw(matchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Recently Fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentlyFetched(options?: RawAxiosRequestConfig): AxiosPromise<Array<ClickhouseMatchInfo>> {
            return localVarFp.recentlyFetched(options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
         * @summary Salts
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salts(matchId: number, options?: RawAxiosRequestConfig): AxiosPromise<MatchSaltsResponse> {
            return localVarFp.salts(matchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
         * @summary Live Broadcast URL
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        url(matchId: number, options?: RawAxiosRequestConfig): AxiosPromise<MatchSpectateResponse> {
            return localVarFp.url(matchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MatchesApi - object-oriented interface
 * @export
 * @class MatchesApi
 * @extends {BaseAPI}
 */
export class MatchesApi extends BaseAPI {
    /**
     *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Active
     * @param {number | null} [accountId] The account ID to filter active matches by (&#x60;SteamID3&#x60;)
     * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public activeMatches(accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).activeMatches(accountId, accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Active as Protobuf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public activeMatchesRaw(options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).activeMatchesRaw(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Badge Distribution
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public badgeDistribution(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).badgeDistribution(minUnixTimestamp, maxUnixTimestamp, minMatchId, maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
     * @summary Bulk Metadata
     * @param {boolean} [includeInfo] Include match info in the response.
     * @param {boolean} [includeObjectives] Include objectives in the response.
     * @param {boolean} [includeMidBoss] Include midboss in the response.
     * @param {boolean} [includePlayerInfo] Include player info in the response.
     * @param {boolean} [includePlayerItems] Include player items in the response.
     * @param {boolean} [includePlayerStats] Include player stats in the response.
     * @param {boolean} [includePlayerDeathDetails] Include player death details in the response.
     * @param {Array<number> | null} [matchIds] Comma separated list of match ids, limited by &#x60;limit&#x60;
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
     * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
     * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
     * @param {Array<number> | null} [accountIds] Filter matches by account IDs of players that participated in the match.
     * @param {BulkMetadataOrderByEnum} [orderBy] The field to order the results by.
     * @param {BulkMetadataOrderDirectionEnum} [orderDirection] The direction to order the results by.
     * @param {number} [limit] The maximum number of matches to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public bulkMetadata(includeInfo?: boolean, includeObjectives?: boolean, includeMidBoss?: boolean, includePlayerInfo?: boolean, includePlayerItems?: boolean, includePlayerStats?: boolean, includePlayerDeathDetails?: boolean, matchIds?: Array<number> | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, accountIds?: Array<number> | null, orderBy?: BulkMetadataOrderByEnum, orderDirection?: BulkMetadataOrderDirectionEnum, limit?: number, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).bulkMetadata(includeInfo, includeObjectives, includeMidBoss, includePlayerInfo, includePlayerItems, includePlayerStats, includePlayerDeathDetails, matchIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, accountIds, orderBy, orderDirection, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
     * @summary Metadata
     * @param {number} matchId The match ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public metadata(matchId: number, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).metadata(matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
     * @summary Metadata as Protobuf
     * @param {number} matchId The match ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public metadataRaw(matchId: number, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).metadataRaw(matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Recently Fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public recentlyFetched(options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).recentlyFetched(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
     * @summary Salts
     * @param {number} matchId The match ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public salts(matchId: number, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).salts(matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
     * @summary Live Broadcast URL
     * @param {number} matchId The match ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MatchesApi
     */
    public url(matchId: number, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).url(matchId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BulkMetadataOrderByEnum = {
    MatchId: 'match_id',
    StartTime: 'start_time'
} as const;
export type BulkMetadataOrderByEnum = typeof BulkMetadataOrderByEnum[keyof typeof BulkMetadataOrderByEnum];
/**
 * @export
 */
export const BulkMetadataOrderDirectionEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;
export type BulkMetadataOrderDirectionEnum = typeof BulkMetadataOrderDirectionEnum[keyof typeof BulkMetadataOrderDirectionEnum];


/**
 * PatchesApi - axios parameter creator
 * @export
 */
export const PatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a list of dates where Deadlock\'s \"big\" patch days were, usually bi-weekly. The exact date is the time when the announcement forum post was published.  This list is manually maintained, and so new patch dates may be delayed by a few hours.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Big Days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bigPatchDays: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/patches/big-days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the parsed result of the RSS Feed from the official Forum.  RSS-Feed: https://forums.playdeadlock.com/forums/changelog.10/index.rss  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Notes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feed: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/patches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatchesApi - functional programming interface
 * @export
 */
export const PatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PatchesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a list of dates where Deadlock\'s \"big\" patch days were, usually bi-weekly. The exact date is the time when the announcement forum post was published.  This list is manually maintained, and so new patch dates may be delayed by a few hours.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Big Days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bigPatchDays(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bigPatchDays(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatchesApi.bigPatchDays']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the parsed result of the RSS Feed from the official Forum.  RSS-Feed: https://forums.playdeadlock.com/forums/changelog.10/index.rss  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Notes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feed(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Patch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feed(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatchesApi.feed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PatchesApi - factory interface
 * @export
 */
export const PatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PatchesApiFp(configuration)
    return {
        /**
         *  Returns a list of dates where Deadlock\'s \"big\" patch days were, usually bi-weekly. The exact date is the time when the announcement forum post was published.  This list is manually maintained, and so new patch dates may be delayed by a few hours.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Big Days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bigPatchDays(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.bigPatchDays(options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the parsed result of the RSS Feed from the official Forum.  RSS-Feed: https://forums.playdeadlock.com/forums/changelog.10/index.rss  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Notes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feed(options?: RawAxiosRequestConfig): AxiosPromise<Array<Patch>> {
            return localVarFp.feed(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PatchesApi - object-oriented interface
 * @export
 * @class PatchesApi
 * @extends {BaseAPI}
 */
export class PatchesApi extends BaseAPI {
    /**
     *  Returns a list of dates where Deadlock\'s \"big\" patch days were, usually bi-weekly. The exact date is the time when the announcement forum post was published.  This list is manually maintained, and so new patch dates may be delayed by a few hours.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Big Days
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatchesApi
     */
    public bigPatchDays(options?: RawAxiosRequestConfig) {
        return PatchesApiFp(this.configuration).bigPatchDays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the parsed result of the RSS Feed from the official Forum.  RSS-Feed: https://forums.playdeadlock.com/forums/changelog.10/index.rss  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Notes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PatchesApi
     */
    public feed(options?: RawAxiosRequestConfig) {
        return PatchesApiFp(this.configuration).feed(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlayersApi - axios parameter creator
 * @export
 */
export const PlayersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
         * @summary Card
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        card: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('card', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/card`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Enemy Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enemyStats: async (accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('enemyStats', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/enemy-stats`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (minMatchesPlayed !== undefined) {
                localVarQueryParameter['min_matches_played'] = minMatchesPlayed;
            }

            if (maxMatchesPlayed !== undefined) {
                localVarQueryParameter['max_matches_played'] = maxMatchesPlayed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
         * @summary Match History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {boolean} [forceRefetch] Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit.
         * @param {boolean} [onlyStoredHistory] Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchHistory: async (accountId: number, forceRefetch?: boolean, onlyStoredHistory?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('matchHistory', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/match-history`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (forceRefetch !== undefined) {
                localVarQueryParameter['force_refetch'] = forceRefetch;
            }

            if (onlyStoredHistory !== undefined) {
                localVarQueryParameter['only_stored_history'] = onlyStoredHistory;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Mate Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {boolean} [sameParty] Filter based on whether the mates were on the same party.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mateStats: async (accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, sameParty?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('mateStats', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/mate-stats`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (minMatchesPlayed !== undefined) {
                localVarQueryParameter['min_matches_played'] = minMatchesPlayed;
            }

            if (maxMatchesPlayed !== undefined) {
                localVarQueryParameter['max_matches_played'] = maxMatchesPlayed;
            }

            if (sameParty !== undefined) {
                localVarQueryParameter['same_party'] = sameParty;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Party Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partyStats: async (accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('partyStats', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/party-stats`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerHeroStats: async (accountIds: Array<number>, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIds' is not null or undefined
            assertParamExists('playerHeroStats', 'accountIds', accountIds)
            const localVarPath = `/v1/players/hero-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the Steam profile of a player.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Steam Profile
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steam: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('steam', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/steam`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Batch Steam Profile
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steamBatch: async (accountIds: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIds' is not null or undefined
            assertParamExists('steamBatch', 'accountIds', accountIds)
            const localVarPath = `/v1/players/steam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Steam Profile Search
         * @param {string} searchQuery Search query for Steam profiles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steamSearch: async (searchQuery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchQuery' is not null or undefined
            assertParamExists('steamSearch', 'searchQuery', searchQuery)
            const localVarPath = `/v1/players/steam-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersApi - functional programming interface
 * @export
 */
export const PlayersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayersApiAxiosParamCreator(configuration)
    return {
        /**
         *  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
         * @summary Card
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async card(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerCard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.card(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.card']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Enemy Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enemyStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnemyStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enemyStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.enemyStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
         * @summary Match History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {boolean} [forceRefetch] Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit.
         * @param {boolean} [onlyStoredHistory] Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchHistory(accountId: number, forceRefetch?: boolean, onlyStoredHistory?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerMatchHistoryEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchHistory(accountId, forceRefetch, onlyStoredHistory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.matchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Mate Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {boolean} [sameParty] Filter based on whether the mates were on the same party.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mateStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, sameParty?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MateStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mateStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, sameParty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.mateStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Party Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partyStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PartyStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partyStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.partyStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerHeroStats(accountIds: Array<number>, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HeroStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerHeroStats(accountIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.playerHeroStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the Steam profile of a player.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Steam Profile
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async steam(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SteamProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.steam(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.steam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Batch Steam Profile
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async steamBatch(accountIds: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SteamProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.steamBatch(accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.steamBatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Steam Profile Search
         * @param {string} searchQuery Search query for Steam profiles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async steamSearch(searchQuery: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SteamProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.steamSearch(searchQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.steamSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlayersApi - factory interface
 * @export
 */
export const PlayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayersApiFp(configuration)
    return {
        /**
         *  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
         * @summary Card
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        card(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<PlayerCard>> {
            return localVarFp.card(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Enemy Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enemyStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<EnemyStats>> {
            return localVarFp.enemyStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
         * @summary Match History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {boolean} [forceRefetch] Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit.
         * @param {boolean} [onlyStoredHistory] Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchHistory(accountId: number, forceRefetch?: boolean, onlyStoredHistory?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<PlayerMatchHistoryEntry>> {
            return localVarFp.matchHistory(accountId, forceRefetch, onlyStoredHistory, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Mate Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {boolean} [sameParty] Filter based on whether the mates were on the same party.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mateStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, sameParty?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<MateStats>> {
            return localVarFp.mateStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, sameParty, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Party Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partyStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<PartyStats>> {
            return localVarFp.partyStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerHeroStats(accountIds: Array<number>, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<HeroStats>> {
            return localVarFp.playerHeroStats(accountIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the Steam profile of a player.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Steam Profile
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steam(accountId: number, options?: RawAxiosRequestConfig): AxiosPromise<SteamProfile> {
            return localVarFp.steam(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Batch Steam Profile
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steamBatch(accountIds: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<Array<SteamProfile>> {
            return localVarFp.steamBatch(accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Steam Profile Search
         * @param {string} searchQuery Search query for Steam profiles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steamSearch(searchQuery: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SteamProfile>> {
            return localVarFp.steamSearch(searchQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayersApi - object-oriented interface
 * @export
 * @class PlayersApi
 * @extends {BaseAPI}
 */
export class PlayersApi extends BaseAPI {
    /**
     *  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
     * @summary Card
     * @param {number} accountId The players &#x60;SteamID3&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public card(accountId: number, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).card(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Enemy Stats
     * @param {number} accountId The players &#x60;SteamID3&#x60;
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
     * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public enemyStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).enemyStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
     * @summary Match History
     * @param {number} accountId The players &#x60;SteamID3&#x60;
     * @param {boolean} [forceRefetch] Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit.
     * @param {boolean} [onlyStoredHistory] Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public matchHistory(accountId: number, forceRefetch?: boolean, onlyStoredHistory?: boolean, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).matchHistory(accountId, forceRefetch, onlyStoredHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Mate Stats
     * @param {number} accountId The players &#x60;SteamID3&#x60;
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
     * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
     * @param {boolean} [sameParty] Filter based on whether the mates were on the same party.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public mateStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, sameParty?: boolean, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).mateStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, sameParty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Party Stats
     * @param {number} accountId The players &#x60;SteamID3&#x60;
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public partyStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).partyStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Stats
     * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
     * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
     * @param {number | null} [minNetworth] Filter players based on their net worth.
     * @param {number | null} [maxNetworth] Filter players based on their net worth.
     * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     * @param {number | null} [minMatchId] Filter matches based on their ID.
     * @param {number | null} [maxMatchId] Filter matches based on their ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public playerHeroStats(accountIds: Array<number>, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).playerHeroStats(accountIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the Steam profile of a player.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Steam Profile
     * @param {number} accountId The players &#x60;SteamID3&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public steam(accountId: number, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).steam(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Batch Steam Profile
     * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public steamBatch(accountIds: Array<number>, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).steamBatch(accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Steam Profile Search
     * @param {string} searchQuery Search query for Steam profiles.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayersApi
     */
    public steamSearch(searchQuery: string, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).steamSearch(searchQuery, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SQLApi - axios parameter creator
 * @export
 */
export const SQLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Lists all tables in the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Tables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTables: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sql/tables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Executes a SQL query on the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 300req/5min | | Key | 300req/5min | | Global | 600req/60s |     
         * @summary Query
         * @param {string} query The SQL query to execute. It must follow the Clickhouse SQL syntax.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sql: async (query: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('sql', 'query', query)
            const localVarPath = `/v1/sql`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the schema of a table.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Table Schema
         * @param {string} table The name of the table to fetch the schema for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tableSchema: async (table: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'table' is not null or undefined
            assertParamExists('tableSchema', 'table', table)
            const localVarPath = `/v1/sql/tables/{table}/schema`
                .replace(`{${"table"}}`, encodeURIComponent(String(table)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SQLApi - functional programming interface
 * @export
 */
export const SQLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SQLApiAxiosParamCreator(configuration)
    return {
        /**
         *  Lists all tables in the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Tables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTables(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTables(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SQLApi.listTables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Executes a SQL query on the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 300req/5min | | Key | 300req/5min | | Global | 600req/60s |     
         * @summary Query
         * @param {string} query The SQL query to execute. It must follow the Clickhouse SQL syntax.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sql(query: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sql(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SQLApi.sql']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the schema of a table.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Table Schema
         * @param {string} table The name of the table to fetch the schema for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tableSchema(table: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tableSchema(table, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SQLApi.tableSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SQLApi - factory interface
 * @export
 */
export const SQLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SQLApiFp(configuration)
    return {
        /**
         *  Lists all tables in the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Tables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTables(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listTables(options).then((request) => request(axios, basePath));
        },
        /**
         *  Executes a SQL query on the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 300req/5min | | Key | 300req/5min | | Global | 600req/60s |     
         * @summary Query
         * @param {string} query The SQL query to execute. It must follow the Clickhouse SQL syntax.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sql(query: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.sql(query, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the schema of a table.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Table Schema
         * @param {string} table The name of the table to fetch the schema for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tableSchema(table: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.tableSchema(table, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SQLApi - object-oriented interface
 * @export
 * @class SQLApi
 * @extends {BaseAPI}
 */
export class SQLApi extends BaseAPI {
    /**
     *  Lists all tables in the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary List Tables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SQLApi
     */
    public listTables(options?: RawAxiosRequestConfig) {
        return SQLApiFp(this.configuration).listTables(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Executes a SQL query on the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 300req/5min | | Key | 300req/5min | | Global | 600req/60s |     
     * @summary Query
     * @param {string} query The SQL query to execute. It must follow the Clickhouse SQL syntax.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SQLApi
     */
    public sql(query: string, options?: RawAxiosRequestConfig) {
        return SQLApiFp(this.configuration).sql(query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the schema of a table.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Table Schema
     * @param {string} table The name of the table to fetch the schema for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SQLApi
     */
    public tableSchema(table: string, options?: RawAxiosRequestConfig) {
        return SQLApiFp(this.configuration).tableSchema(table, options).then((request) => request(this.axios, this.basePath));
    }
}



