/* tslint:disable */
/* eslint-disable */
/**
 * Deadlock API
 *  ## Support the Deadlock API  Whether you\'re building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface APIInfo {
    /**
     * The number of matches fetched in the last 24 hours.
     */
    'fetched_matches_per_day'?: number | null;
    /**
     * The number of matches that have not been fetched.
     */
    'missed_matches'?: number | null;
    /**
     * The sizes of all tables in the database.
     */
    'table_sizes'?: { [key: string]: TableSize; };
}
export interface ActiveMatch {
    'compat_version'?: number | null;
    'duration_s'?: number | null;
    'game_mode'?: number | null;
    'game_mode_parsed'?: ActiveMatchGameMode | null;
    'game_mode_version'?: number | null;
    'lobby_id'?: number | null;
    'match_id'?: number | null;
    'match_mode'?: number | null;
    'match_mode_parsed'?: ActiveMatchMode | null;
    'match_score'?: number | null;
    'net_worth_team_0'?: number | null;
    'net_worth_team_1'?: number | null;
    'objectives_mask_team0'?: number | null;
    'objectives_mask_team1'?: number | null;
    'open_spectator_slots'?: number | null;
    'players': Array<ActiveMatchPlayer>;
    'region_mode'?: number | null;
    'region_mode_parsed'?: ActiveMatchRegionMode | null;
    'spectators'?: number | null;
    'start_time'?: number | null;
    'winning_team'?: number | null;
    'winning_team_parsed'?: ActiveMatchTeam | null;
}



export const ActiveMatchGameMode = {
    KeCitadelGameModeInvalid: 'KECitadelGameModeInvalid',
    KeCitadelGameModeNormal: 'KECitadelGameModeNormal',
    KeCitadelGameMode1v1Test: 'KECitadelGameMode1v1Test',
    KeCitadelGameModeSandbox: 'KECitadelGameModeSandbox'
} as const;

export type ActiveMatchGameMode = typeof ActiveMatchGameMode[keyof typeof ActiveMatchGameMode];



export const ActiveMatchMode = {
    Invalid: 'Invalid',
    Unranked: 'Unranked',
    PrivateLobby: 'PrivateLobby',
    CoopBot: 'CoopBot',
    Ranked: 'Ranked',
    ServerTest: 'ServerTest',
    Tutorial: 'Tutorial',
    HeroLabs: 'HeroLabs'
} as const;

export type ActiveMatchMode = typeof ActiveMatchMode[keyof typeof ActiveMatchMode];


export interface ActiveMatchPlayer {
    'abandoned'?: boolean | null;
    'account_id'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'hero_id'?: number | null;
    'team'?: number | null;
    'team_parsed'?: ActiveMatchTeam | null;
}



export const ActiveMatchRegionMode = {
    Row: 'Row',
    Europe: 'Europe',
    SeAsia: 'SeAsia',
    SAmerica: 'SAmerica',
    Russia: 'Russia',
    Oceania: 'Oceania'
} as const;

export type ActiveMatchRegionMode = typeof ActiveMatchRegionMode[keyof typeof ActiveMatchRegionMode];



export const ActiveMatchTeam = {
    Team0: 'Team0',
    Team1: 'Team1',
    Spectator: 'Spectator'
} as const;

export type ActiveMatchTeam = typeof ActiveMatchTeam[keyof typeof ActiveMatchTeam];


export interface AnalyticsAbilityOrderStats {
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'abilities': Array<number>;
    'losses': number;
    'matches': number;
    'players': number;
    'total_assists': number;
    'total_deaths': number;
    'total_kills': number;
    'wins': number;
}
export interface AnalyticsHeroStats {
    'bucket': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'hero_id': number;
    'losses': number;
    'matches': number;
    'matches_per_bucket': number;
    'players': number;
    'total_assists': number;
    'total_boss_damage': number;
    'total_creep_damage': number;
    'total_deaths': number;
    'total_denies': number;
    'total_kills': number;
    'total_last_hits': number;
    'total_max_health': number;
    'total_net_worth': number;
    'total_neutral_damage': number;
    'total_player_damage': number;
    'total_player_damage_taken': number;
    'total_shots_hit': number;
    'total_shots_missed': number;
    'wins': number;
}
export interface BadgeDistribution {
    /**
     * The badge level. See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'badge_level': number;
    /**
     * The total number of matches.
     */
    'total_matches': number;
}
export interface Build {
    'hero_build': BuildHero;
    'num_favorites'?: number | null;
    'num_ignores'?: number | null;
    'num_reports'?: number | null;
    'num_weekly_favorites'?: number | null;
    'rollup_category'?: number | null;
}
export interface BuildHero {
    'author_account_id': number;
    'description'?: string | null;
    'details': BuildHeroDetails;
    'development_build'?: boolean | null;
    'hero_build_id': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'hero_id': number;
    'language': number;
    'last_updated_timestamp'?: number | null;
    'name': string;
    'origin_build_id': number;
    'publish_timestamp'?: number | null;
    'tags'?: Array<number>;
    'version': number;
}
export interface BuildHeroDetails {
    'ability_order'?: BuildHeroDetailsAbilityOrder | null;
    'mod_categories': Array<BuildHeroDetailsCategory>;
}
export interface BuildHeroDetailsAbilityOrder {
    'currency_changes'?: Array<BuildHeroDetailsAbilityOrderCurrencyChange> | null;
}
export interface BuildHeroDetailsAbilityOrderCurrencyChange {
    'ability_id': number;
    'annotation'?: string | null;
    'currency_type': number;
    'delta': number;
}
export interface BuildHeroDetailsCategory {
    'description'?: string | null;
    'height'?: number | null;
    'mods'?: Array<BuildHeroDetailsCategoryAbility> | null;
    'name': string;
    'optional'?: boolean | null;
    'width'?: number | null;
}
export interface BuildHeroDetailsCategoryAbility {
    'ability_id': number;
    'annotation'?: string | null;
    'imbue_target_ability_id'?: number | null;
    'required_flex_slots'?: number | null;
    'sell_priority'?: number | null;
}
export interface BuildItemStats {
    'builds': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/items>
     */
    'item_id': number;
}
export interface ClickhouseMatchInfo {
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'average_badge_team0'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'average_badge_team1'?: number | null;
    'duration_s': number;
    'match_id': number;
    'match_mode': number;
    'start_time': number;
}
export interface ClickhouseSalts {
    'cluster_id'?: number | null;
    'match_id': number;
    'metadata_salt'?: number | null;
    'replay_salt'?: number | null;
    'username'?: string | null;
}
export interface CreateCustomRequest {
    /**
     * If a callback url is provided, we will send a POST request to this url when the match starts.
     */
    'callback_url'?: string | null;
    'cheats_enabled'?: boolean | null;
    /**
     * If auto-ready is disabled, the bot will not automatically ready up. You need to call the `ready` endpoint to ready up.
     */
    'disable_auto_ready'?: boolean | null;
    'duplicate_heroes_enabled'?: boolean | null;
    'experimental_heroes_enabled'?: boolean | null;
    'is_publicly_visible'?: boolean | null;
    'min_roster_size'?: number | null;
    'randomize_lanes'?: boolean | null;
    'region_mode'?: RegionMode | null;
}


export interface CreateCustomResponse {
    /**
     * If a callback url is provided, this is the secret that should be used to verify the callback. The secret is a base64 encoded random string. To verify it you should compare it with the X-Callback-Secret header. If no callback url is provided, this will be None.
     */
    'callback_secret'?: string | null;
    'party_code': string;
    'party_id': string;
}
export interface DataPrivacyRequest {
    'open_id_params': { [key: string]: string; };
    'steam_id': number;
}
export interface DistributionEntry {
    'players': number;
    'rank': number;
}
export interface ESportsMatch {
    /**
     * Valve\'s match id of the match.
     */
    'match_id'?: number | null;
    /**
     * The provider of the match data. Some string that identifies the source of the data.
     */
    'provider': string;
    /**
     * The scheduled date of the match.
     */
    'scheduled_date'?: string | null;
    /**
     * The status of the match, e.g. live, completed, scheduled, cancelled.
     */
    'status'?: ESportsMatchStatus | null;
    /**
     * The name of the first team.
     */
    'team0_name'?: string | null;
    /**
     * The name of the second team.
     */
    'team1_name'?: string | null;
    /**
     * The name of the tournament.
     */
    'tournament_name'?: string | null;
    /**
     * The stage of the tournament.
     */
    'tournament_stage'?: string | null;
    /**
     * If you want to update an existing match, you can provide an update id.
     */
    'update_id'?: string | null;
}



export const ESportsMatchStatus = {
    Live: 'Live',
    Completed: 'Completed',
    Scheduled: 'Scheduled',
    Cancelled: 'Cancelled'
} as const;

export type ESportsMatchStatus = typeof ESportsMatchStatus[keyof typeof ESportsMatchStatus];


export interface EnemyStats {
    'enemy_id': number;
    'matches': Array<number>;
    'matches_played': number;
    /**
     * The amount of matches won against the enemy.
     */
    'wins': number;
}
export interface Entry {
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'hero_id': number;
    'matches': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'rank': number;
    'value': number;
}
export interface GetCustomMatchIdResponse {
    'match_id': number;
}
export interface HashMapValue {
    'avg': number;
    'percentile1': number;
    'percentile10': number;
    'percentile25': number;
    'percentile5': number;
    'percentile50': number;
    'percentile75': number;
    'percentile90': number;
    'percentile95': number;
    'percentile99': number;
    'std': number;
}
export interface HeroCombStats {
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'hero_ids': Array<number>;
    'losses': number;
    'matches': number;
    'wins': number;
}
export interface HeroCounterStats {
    /**
     * The number of assists by `hero_id` when facing `enemy_hero_id`.
     */
    'assists': number;
    /**
     * The number of creeps killed by `hero_id` when facing `enemy_hero_id`.
     */
    'creeps': number;
    /**
     * The number of deaths by `hero_id` when facing `enemy_hero_id`.
     */
    'deaths': number;
    /**
     * The number of denies by `hero_id` when facing `enemy_hero_id`.
     */
    'denies': number;
    /**
     * The number of assists by `enemy_hero_id` when facing `hero_id`.
     */
    'enemy_assists': number;
    /**
     * The number of creeps killed by `enemy_hero_id` when facing `hero_id`.
     */
    'enemy_creeps': number;
    /**
     * The number of deaths by `enemy_hero_id` when facing `hero_id`.
     */
    'enemy_deaths': number;
    /**
     * The number of denies by `enemy_hero_id` when facing `hero_id`.
     */
    'enemy_denies': number;
    /**
     * The ID of the opposing hero. See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'enemy_hero_id': number;
    /**
     * The number of kills by `enemy_hero_id` when facing `hero_id`.
     */
    'enemy_kills': number;
    /**
     * The number of last hits by `enemy_hero_id` when facing `hero_id`.
     */
    'enemy_last_hits': number;
    /**
     * The net worth of `enemy_hero_id` when facing `hero_id`.
     */
    'enemy_networth': number;
    /**
     * The amount of objective damage dealt by `enemy_hero_id` when facing `hero_id`.
     */
    'enemy_obj_damage': number;
    /**
     * The ID of the hero. See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'hero_id': number;
    /**
     * The number of kills by `hero_id` when facing `enemy_hero_id`.
     */
    'kills': number;
    /**
     * The number of last hits by `hero_id` when facing `enemy_hero_id`.
     */
    'last_hits': number;
    /**
     * The total number of matches played between `hero_id` and `enemy_hero_id` that meet the filter criteria.
     */
    'matches_played': number;
    /**
     * The net worth of `hero_id` when facing `enemy_hero_id`.
     */
    'networth': number;
    /**
     * The amount of objective damage dealt by `hero_id` when facing `enemy_hero_id`.
     */
    'obj_damage': number;
    /**
     * The number of times `hero_id` won the match when facing `enemy_hero_id`.
     */
    'wins': number;
}
export interface HeroStats {
    'account_id': number;
    'accuracy': number;
    'assists': number;
    'assists_per_min': number;
    'creeps_per_min': number;
    'crit_shot_rate': number;
    /**
     * @deprecated
     */
    'damage_mitigated_per_min': number;
    'damage_per_min': number;
    'damage_per_soul': number;
    'damage_taken_per_min': number;
    'damage_taken_per_soul': number;
    'deaths': number;
    'deaths_per_min': number;
    'denies_per_match': number;
    'denies_per_min': number;
    'ending_level': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'hero_id': number;
    'kills': number;
    'kills_per_min': number;
    'last_hits_per_min': number;
    'last_played': number;
    'matches': Array<number>;
    'matches_played': number;
    'networth_per_min': number;
    'obj_damage_per_min': number;
    'obj_damage_per_soul': number;
    'time_played': number;
    'wins': number;
}
export interface HeroSynergyStats {
    /**
     * The number of assists by `hero_id1` when playing with `hero_id2`.
     */
    'assists1': number;
    /**
     * The number of assists by `hero_id2` when playing with `hero_id1`.
     */
    'assists2': number;
    /**
     * The number of creeps killed by `hero_id1` when playing with `hero_id2`.
     */
    'creeps1': number;
    /**
     * The number of creeps killed by `hero_id2` when playing with `hero_id1`.
     */
    'creeps2': number;
    /**
     * The number of deaths by `hero_id1` when playing with `hero_id2`.
     */
    'deaths1': number;
    /**
     * The number of deaths by `hero_id2` when playing with `hero_id1`.
     */
    'deaths2': number;
    /**
     * The number of denies by `hero_id1` when playing with `hero_id2`.
     */
    'denies1': number;
    /**
     * The number of denies by `hero_id2` when playing with `hero_id1`.
     */
    'denies2': number;
    /**
     * The ID of the first hero in the pair.
     */
    'hero_id1': number;
    /**
     * The ID of the second hero in the pair.
     */
    'hero_id2': number;
    /**
     * The number of kills by `hero_id1` when playing with `hero_id2`.
     */
    'kills1': number;
    /**
     * The number of kills by `hero_id2` when playing with `hero_id1`.
     */
    'kills2': number;
    /**
     * The number of last hits by `hero_id1` when playing with `hero_id2`.
     */
    'last_hits1': number;
    /**
     * The number of last hits by `hero_id2` when playing with `hero_id1`.
     */
    'last_hits2': number;
    /**
     * The total number of matches played where `hero_id1` and `hero_id2` were on the same team, meeting the filter criteria.
     */
    'matches_played': number;
    /**
     * The net worth of `hero_id1` when playing with `hero_id2`.
     */
    'networth1': number;
    /**
     * The net worth of `hero_id2` when playing with `hero_id1`.
     */
    'networth2': number;
    /**
     * The amount of objective damage dealt by `hero_id1` when playing with `hero_id2`.
     */
    'obj_damage1': number;
    /**
     * The amount of objective damage dealt by `hero_id2` when playing with `hero_id1`.
     */
    'obj_damage2': number;
    /**
     * The number of times the team won when both `hero_id1` and `hero_id2` were on the same team.
     */
    'wins': number;
}
export interface ItemPermutationStats {
    /**
     * See more: <https://assets.deadlock-api.com/v2/items>
     */
    'item_ids': Array<number>;
    'losses': number;
    'matches': number;
    'wins': number;
}
export interface ItemStats {
    'bucket': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/items>
     */
    'item_id': number;
    'losses': number;
    'matches': number;
    'players': number;
    'wins': number;
}
export interface Leaderboard {
    /**
     * The leaderboard entries.
     */
    'entries': Array<LeaderboardEntry>;
}
export interface LeaderboardEntry {
    /**
     * The account name of the player.
     */
    'account_name'?: string | null;
    /**
     * The badge level of the player. See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'badge_level'?: number | null;
    /**
     * The possible account IDs of the player. **CAVEAT: This is not always correct, as Steam account names are not unique.**
     */
    'possible_account_ids'?: Array<number>;
    /**
     * The rank of the player. See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'rank'?: number | null;
    /**
     * The ranked rank of the player. See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'ranked_rank'?: number | null;
    /**
     * The ranked subrank of the player. See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'ranked_subrank'?: number | null;
    /**
     * The top hero IDs of the player. See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'top_hero_ids'?: Array<number>;
}
export interface MMRHistory {
    'account_id': number;
    /**
     * Extracted from the rank the division (rank // 10)
     */
    'division': number;
    /**
     * Extracted from the rank the division tier (rank % 10)
     */
    'division_tier': number;
    'match_id': number;
    /**
     * Player Score is the index for the rank array (internally used for the rank regression)
     */
    'player_score': number;
    /**
     * The Player Rank. See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'rank': number;
    /**
     * Start time of the match
     */
    'start_time': number;
}
export interface MatchSaltsResponse {
    'cluster_id'?: number | null;
    'demo_url'?: string | null;
    'match_id': number;
    'metadata_salt'?: number | null;
    'metadata_url'?: string | null;
    'replay_salt'?: number | null;
}
export interface MatchSpectateResponse {
    'broadcast_url': string;
    'lobby_id'?: number | null;
}
export interface MateStats {
    'matches': Array<number>;
    'matches_played': number;
    'mate_id': number;
    'wins': number;
}
export interface PartyStats {
    'matches': Array<number>;
    'matches_played': number;
    'party_size': number;
    'wins': number;
}
export interface Patch {
    'author': string;
    'category': PatchCategory;
    'content_encoded': string;
    'dc_creator': string;
    'guid': PatchGuid;
    'link': string;
    'pub_date': string;
    'slash_comments': string;
    'title': string;
}
export interface PatchCategory {
    'domain': string;
    'text': string;
}
export interface PatchGuid {
    'is_perma_link': boolean;
    'text': string;
}
export interface PlayerCard {
    'account_id': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'ranked_badge_level'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'ranked_rank'?: number | null;
    /**
     * See more: <https://assets.deadlock-api.com/v2/ranks>
     */
    'ranked_subrank'?: number | null;
    'slots': Array<PlayerCardSlot>;
}
export interface PlayerCardSlot {
    'hero'?: PlayerCardSlotHero | null;
    'slot_id'?: number | null;
    'stat'?: PlayerCardSlotStat | null;
}
export interface PlayerCardSlotHero {
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'id'?: number | null;
    'kills'?: number | null;
    'wins'?: number | null;
}
export interface PlayerCardSlotStat {
    'stat_id'?: number | null;
    'stat_score'?: number | null;
}
export interface PlayerMatchHistoryEntry {
    'abandoned_time_s'?: number | null;
    'account_id': number;
    'denies': number;
    'game_mode': number;
    /**
     * See more: <https://assets.deadlock-api.com/v2/heroes>
     */
    'hero_id': number;
    'hero_level': number;
    'last_hits': number;
    'match_duration_s': number;
    'match_id': number;
    'match_mode': number;
    'match_result': number;
    'net_worth': number;
    'objectives_mask_team0': number;
    'objectives_mask_team1': number;
    'player_assists': number;
    'player_deaths': number;
    'player_kills': number;
    'player_team': number;
    'start_time': number;
    'team_abandoned'?: boolean | null;
    'username'?: string | null;
}

export const RegionMode = {
    Row: 'row',
    Europe: 'europe',
    SeAsia: 'se_asia',
    SAmerica: 's_america',
    Russia: 'russia',
    Oceania: 'oceania'
} as const;

export type RegionMode = typeof RegionMode[keyof typeof RegionMode];


export interface Status {
    /**
     * Status of the services.
     */
    'services': StatusServices;
}
export interface StatusServices {
    /**
     * Whether Clickhouse is reachable.
     */
    'clickhouse': boolean;
    /**
     * Whether Postgres is reachable.
     */
    'postgres': boolean;
    /**
     * Whether Redis is reachable.
     */
    'redis': boolean;
}
export interface SteamProfile {
    'account_id': number;
    'avatar': string;
    'avatarfull': string;
    'avatarmedium': string;
    'countrycode'?: string | null;
    'last_updated': string;
    'personaname': string;
    'profileurl': string;
    'realname'?: string | null;
}
export interface TableSize {
    /**
     * Compressed size of the table in bytes.
     */
    'data_compressed_bytes'?: number | null;
    /**
     * Uncompressed size of the table in bytes.
     */
    'data_uncompressed_bytes'?: number | null;
    /**
     * Whether the table is a view.
     */
    'is_view': boolean;
    /**
     * Number of rows in the table.
     */
    'rows'?: number | null;
}

export const VariableCategory = {
    General: 'General',
    Daily: 'Daily',
    Hero: 'Hero',
    Item: 'Item',
    Leaderboard: 'Leaderboard',
    Overall: 'Overall'
} as const;

export type VariableCategory = typeof VariableCategory[keyof typeof VariableCategory];


export interface VariableDescription {
    /**
     * The category of the variable.
     */
    'category': VariableCategory;
    /**
     * The default label for the variable.
     */
    'default_label'?: string | null;
    /**
     * The description of the variable.
     */
    'description': string;
    /**
     * Extra arguments that can be passed to the variable.
     */
    'extra_args': Array<string>;
    /**
     * The name of the variable.
     */
    'name': string;
}



/**
 * AnalyticsApi - axios parameter creator
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Ability Order Stats
         * @param {number} heroId See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAbilityUpgrades] Filter players based on their minimum number of ability upgrades over the whole match.
         * @param {number | null} [maxAbilityUpgrades] Filter players based on their maximum number of ability upgrades over the whole match.
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatches] The minimum number of matches played for an ability order to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abilityOrderStats: async (heroId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAbilityUpgrades?: number | null, maxAbilityUpgrades?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('abilityOrderStats', 'heroId', heroId)
            const localVarPath = `/v1/analytics/ability-order-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minAbilityUpgrades !== undefined) {
                localVarQueryParameter['min_ability_upgrades'] = minAbilityUpgrades;
            }

            if (maxAbilityUpgrades !== undefined) {
                localVarQueryParameter['max_ability_upgrades'] = maxAbilityUpgrades;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Badge Distribution
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgeDistribution: async (minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, minMatchId?: number | null, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/badge-distribution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (isHighSkillRangeParties !== undefined) {
                localVarQueryParameter['is_high_skill_range_parties'] = isHighSkillRangeParties;
            }

            if (isLowPriPool !== undefined) {
                localVarQueryParameter['is_low_pri_pool'] = isLowPriPool;
            }

            if (isNewPlayerPool !== undefined) {
                localVarQueryParameter['is_new_player_pool'] = isNewPlayerPool;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Build Item Stats
         * @param {number | null} [heroId] Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildItemStats: async (heroId?: number | null, minLastUpdatedUnixTimestamp?: number | null, maxLastUpdatedUnixTimestamp?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/build-item-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minLastUpdatedUnixTimestamp !== undefined) {
                localVarQueryParameter['min_last_updated_unix_timestamp'] = minLastUpdatedUnixTimestamp;
            }

            if (maxLastUpdatedUnixTimestamp !== undefined) {
                localVarQueryParameter['max_last_updated_unix_timestamp'] = maxLastUpdatedUnixTimestamp;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Comb Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeHeroIds] Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {Array<number> | null} [excludeHeroIds] Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [combSize] The combination size to return.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroCombStats: async (minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeHeroIds?: Array<number> | null, excludeHeroIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, combSize?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/hero-comb-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (includeHeroIds) {
                localVarQueryParameter['include_hero_ids'] = includeHeroIds;
            }

            if (excludeHeroIds) {
                localVarQueryParameter['exclude_hero_ids'] = excludeHeroIds;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (combSize !== undefined) {
                localVarQueryParameter['comb_size'] = combSize;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Counter Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [maxEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroCountersStats: async (minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minEnemyNetworth?: number | null, maxEnemyNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/hero-counter-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minEnemyNetworth !== undefined) {
                localVarQueryParameter['min_enemy_networth'] = minEnemyNetworth;
            }

            if (maxEnemyNetworth !== undefined) {
                localVarQueryParameter['max_enemy_networth'] = maxEnemyNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (sameLaneFilter !== undefined) {
                localVarQueryParameter['same_lane_filter'] = sameLaneFilter;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Scoreboard
         * @param {HeroScoreboardSortByEnum} sortBy The field to sort by.
         * @param {HeroScoreboardSortDirectionEnum} [sortDirection] The direction to sort heroes in.
         * @param {number | null} [minMatches] Filter by min number of matches played.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroScoreboard: async (sortBy: HeroScoreboardSortByEnum, sortDirection?: HeroScoreboardSortDirectionEnum, minMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sortBy' is not null or undefined
            assertParamExists('heroScoreboard', 'sortBy', sortBy)
            const localVarPath = `/v1/analytics/scoreboards/heroes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {HeroStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minHeroMatches] Filter players based on the number of matches they have played with a specific hero within the filtered time range.
         * @param {number | null} [maxHeroMatches] Filter players based on the number of matches they have played with a specific hero within the filtered time range.
         * @param {number | null} [minHeroMatchesTotal] Filter players based on the number of matches they have played with a specific hero in their entire history.
         * @param {number | null} [maxHeroMatchesTotal] Filter players based on the number of matches they have played with a specific hero in their entire history.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroStats: async (bucket?: HeroStatsBucketEnum, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minHeroMatches?: number | null, maxHeroMatches?: number | null, minHeroMatchesTotal?: number | null, maxHeroMatchesTotal?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/hero-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bucket !== undefined) {
                localVarQueryParameter['bucket'] = bucket;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (minHeroMatches !== undefined) {
                localVarQueryParameter['min_hero_matches'] = minHeroMatches;
            }

            if (maxHeroMatches !== undefined) {
                localVarQueryParameter['max_hero_matches'] = maxHeroMatches;
            }

            if (minHeroMatchesTotal !== undefined) {
                localVarQueryParameter['min_hero_matches_total'] = minHeroMatchesTotal;
            }

            if (maxHeroMatchesTotal !== undefined) {
                localVarQueryParameter['max_hero_matches_total'] = maxHeroMatchesTotal;
            }

            if (includeItemIds) {
                localVarQueryParameter['include_item_ids'] = includeItemIds;
            }

            if (excludeItemIds) {
                localVarQueryParameter['exclude_item_ids'] = excludeItemIds;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Synergy Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {boolean | null} [samePartyFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroSynergiesStats: async (minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, samePartyFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/hero-synergy-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (sameLaneFilter !== undefined) {
                localVarQueryParameter['same_lane_filter'] = sameLaneFilter;
            }

            if (samePartyFilter !== undefined) {
                localVarQueryParameter['same_party_filter'] = samePartyFilter;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Permutation Stats
         * @param {Array<number> | null} [itemIds] Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [combSize] The combination size to return.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemPermutationStats: async (itemIds?: Array<number> | null, combSize?: number | null, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/item-permutation-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (itemIds) {
                localVarQueryParameter['item_ids'] = itemIds;
            }

            if (combSize !== undefined) {
                localVarQueryParameter['comb_size'] = combSize;
            }

            if (heroIds !== undefined) {
                localVarQueryParameter['hero_ids'] = heroIds;
            }

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Stats
         * @param {ItemStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for an item to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStats: async (bucket?: ItemStatsBucketEnum, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/item-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (bucket !== undefined) {
                localVarQueryParameter['bucket'] = bucket;
            }

            if (heroIds !== undefined) {
                localVarQueryParameter['hero_ids'] = heroIds;
            }

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (includeItemIds) {
                localVarQueryParameter['include_item_ids'] = includeItemIds;
            }

            if (excludeItemIds) {
                localVarQueryParameter['exclude_item_ids'] = excludeItemIds;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Scoreboard
         * @param {PlayerScoreboardSortByEnum} sortBy The field to sort by.
         * @param {PlayerScoreboardSortDirectionEnum} [sortDirection] The direction to sort players in.
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a player to be included in the scoreboard.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [start] The offset to start fetching players from.
         * @param {number | null} [limit] The maximum number of players to fetch.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerScoreboard: async (sortBy: PlayerScoreboardSortByEnum, sortDirection?: PlayerScoreboardSortDirectionEnum, heroId?: number | null, minMatches?: number | null, maxMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, start?: number | null, limit?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sortBy' is not null or undefined
            assertParamExists('playerScoreboard', 'sortBy', sortBy)
            const localVarPath = `/v1/analytics/scoreboards/players`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (minMatches !== undefined) {
                localVarQueryParameter['min_matches'] = minMatches;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Stats Metrics
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatches] The maximum number of matches to analyze.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerStatsMetrics: async (heroIds?: string | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, maxMatches?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/analytics/player-stats/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (heroIds !== undefined) {
                localVarQueryParameter['hero_ids'] = heroIds;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (maxMatches !== undefined) {
                localVarQueryParameter['max_matches'] = maxMatches;
            }

            if (includeItemIds) {
                localVarQueryParameter['include_item_ids'] = includeItemIds;
            }

            if (excludeItemIds) {
                localVarQueryParameter['exclude_item_ids'] = excludeItemIds;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Ability Order Stats
         * @param {number} heroId See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAbilityUpgrades] Filter players based on their minimum number of ability upgrades over the whole match.
         * @param {number | null} [maxAbilityUpgrades] Filter players based on their maximum number of ability upgrades over the whole match.
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatches] The minimum number of matches played for an ability order to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async abilityOrderStats(heroId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAbilityUpgrades?: number | null, maxAbilityUpgrades?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyticsAbilityOrderStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.abilityOrderStats(heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAbilityUpgrades, maxAbilityUpgrades, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minMatches, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.abilityOrderStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Badge Distribution
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async badgeDistribution(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BadgeDistribution>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.badgeDistribution(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.badgeDistribution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Build Item Stats
         * @param {number | null} [heroId] Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxLastUpdatedUnixTimestamp] Filter builds based on their last updated time (Unix timestamp).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async buildItemStats(heroId?: number | null, minLastUpdatedUnixTimestamp?: number | null, maxLastUpdatedUnixTimestamp?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BuildItemStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.buildItemStats(heroId, minLastUpdatedUnixTimestamp, maxLastUpdatedUnixTimestamp, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.buildItemStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Comb Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeHeroIds] Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {Array<number> | null} [excludeHeroIds] Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [combSize] The combination size to return.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroCombStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeHeroIds?: Array<number> | null, excludeHeroIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, combSize?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HeroCombStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroCombStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeHeroIds, excludeHeroIds, minMatches, maxMatches, combSize, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroCombStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Counter Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [maxEnemyNetworth] Filter enemy players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroCountersStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minEnemyNetworth?: number | null, maxEnemyNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HeroCounterStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroCountersStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minEnemyNetworth, maxEnemyNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, minMatches, maxMatches, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroCountersStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Scoreboard
         * @param {HeroScoreboardSortByEnum} sortBy The field to sort by.
         * @param {HeroScoreboardSortDirectionEnum} [sortDirection] The direction to sort heroes in.
         * @param {number | null} [minMatches] Filter by min number of matches played.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroScoreboard(sortBy: HeroScoreboardSortByEnum, sortDirection?: HeroScoreboardSortDirectionEnum, minMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroScoreboard(sortBy, sortDirection, minMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroScoreboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {HeroStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minHeroMatches] Filter players based on the number of matches they have played with a specific hero within the filtered time range.
         * @param {number | null} [maxHeroMatches] Filter players based on the number of matches they have played with a specific hero within the filtered time range.
         * @param {number | null} [minHeroMatchesTotal] Filter players based on the number of matches they have played with a specific hero in their entire history.
         * @param {number | null} [maxHeroMatchesTotal] Filter players based on the number of matches they have played with a specific hero in their entire history.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroStats(bucket?: HeroStatsBucketEnum, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minHeroMatches?: number | null, maxHeroMatches?: number | null, minHeroMatchesTotal?: number | null, maxHeroMatchesTotal?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnalyticsHeroStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroStats(bucket, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, minHeroMatches, maxHeroMatches, minHeroMatchesTotal, maxHeroMatchesTotal, includeItemIds, excludeItemIds, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Synergy Stats
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [sameLaneFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
         * @param {boolean | null} [samePartyFilter] When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation.
         * @param {number | null} [minMatches] The minimum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroSynergiesStats(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, sameLaneFilter?: boolean | null, samePartyFilter?: boolean | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HeroSynergyStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroSynergiesStats(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, sameLaneFilter, samePartyFilter, minMatches, maxMatches, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.heroSynergiesStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Permutation Stats
         * @param {Array<number> | null} [itemIds] Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [combSize] The combination size to return.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemPermutationStats(itemIds?: Array<number> | null, combSize?: number | null, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemPermutationStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemPermutationStats(itemIds, combSize, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.itemPermutationStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Stats
         * @param {ItemStatsBucketEnum} [bucket] Bucket allows you to group the stats by a specific field.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for an item to be included in the response.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [accountId] Filter for matches with a specific player account ID.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemStats(bucket?: ItemStatsBucketEnum, heroIds?: string | null, heroId?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, minMatches?: number | null, maxMatches?: number | null, accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ItemStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemStats(bucket, heroIds, heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, includeItemIds, excludeItemIds, minMatches, maxMatches, accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.itemStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Scoreboard
         * @param {PlayerScoreboardSortByEnum} sortBy The field to sort by.
         * @param {PlayerScoreboardSortDirectionEnum} [sortDirection] The direction to sort players in.
         * @param {number | null} [heroId] Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minMatches] The minimum number of matches played for a player to be included in the scoreboard.
         * @param {number | null} [maxMatches] The maximum number of matches played for a hero combination to be included in the response.
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [start] The offset to start fetching players from.
         * @param {number | null} [limit] The maximum number of players to fetch.
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerScoreboard(sortBy: PlayerScoreboardSortByEnum, sortDirection?: PlayerScoreboardSortDirectionEnum, heroId?: number | null, minMatches?: number | null, maxMatches?: number | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, start?: number | null, limit?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Entry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerScoreboard(sortBy, sortDirection, heroId, minMatches, maxMatches, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, start, limit, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.playerScoreboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Stats Metrics
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatches] The maximum number of matches to analyze.
         * @param {Array<number> | null} [includeItemIds] Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [excludeItemIds] Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerStatsMetrics(heroIds?: string | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, maxMatches?: number | null, includeItemIds?: Array<number> | null, excludeItemIds?: Array<number> | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: HashMapValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerStatsMetrics(heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, maxMatches, includeItemIds, excludeItemIds, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.playerStatsMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Ability Order Stats
         * @param {AnalyticsApiAbilityOrderStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abilityOrderStats(requestParameters: AnalyticsApiAbilityOrderStatsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnalyticsAbilityOrderStats>> {
            return localVarFp.abilityOrderStats(requestParameters.heroId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minAbilityUpgrades, requestParameters.maxAbilityUpgrades, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.minMatches, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Badge Distribution
         * @param {AnalyticsApiBadgeDistributionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        badgeDistribution(requestParameters: AnalyticsApiBadgeDistributionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<BadgeDistribution>> {
            return localVarFp.badgeDistribution(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.isHighSkillRangeParties, requestParameters.isLowPriPool, requestParameters.isNewPlayerPool, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Build Item Stats
         * @param {AnalyticsApiBuildItemStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildItemStats(requestParameters: AnalyticsApiBuildItemStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<BuildItemStats>> {
            return localVarFp.buildItemStats(requestParameters.heroId, requestParameters.minLastUpdatedUnixTimestamp, requestParameters.maxLastUpdatedUnixTimestamp, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Comb Stats
         * @param {AnalyticsApiHeroCombStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroCombStats(requestParameters: AnalyticsApiHeroCombStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<HeroCombStats>> {
            return localVarFp.heroCombStats(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.includeHeroIds, requestParameters.excludeHeroIds, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.combSize, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Counter Stats
         * @param {AnalyticsApiHeroCountersStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroCountersStats(requestParameters: AnalyticsApiHeroCountersStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<HeroCounterStats>> {
            return localVarFp.heroCountersStats(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minEnemyNetworth, requestParameters.maxEnemyNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.sameLaneFilter, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Scoreboard
         * @param {AnalyticsApiHeroScoreboardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroScoreboard(requestParameters: AnalyticsApiHeroScoreboardRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Entry>> {
            return localVarFp.heroScoreboard(requestParameters.sortBy, requestParameters.sortDirection, requestParameters.minMatches, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {AnalyticsApiHeroStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroStats(requestParameters: AnalyticsApiHeroStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<AnalyticsHeroStats>> {
            return localVarFp.heroStats(requestParameters.bucket, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.minHeroMatches, requestParameters.maxHeroMatches, requestParameters.minHeroMatchesTotal, requestParameters.maxHeroMatchesTotal, requestParameters.includeItemIds, requestParameters.excludeItemIds, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Synergy Stats
         * @param {AnalyticsApiHeroSynergiesStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroSynergiesStats(requestParameters: AnalyticsApiHeroSynergiesStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<HeroSynergyStats>> {
            return localVarFp.heroSynergiesStats(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.sameLaneFilter, requestParameters.samePartyFilter, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Permutation Stats
         * @param {AnalyticsApiItemPermutationStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemPermutationStats(requestParameters: AnalyticsApiItemPermutationStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemPermutationStats>> {
            return localVarFp.itemPermutationStats(requestParameters.itemIds, requestParameters.combSize, requestParameters.heroIds, requestParameters.heroId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Item Stats
         * @param {AnalyticsApiItemStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemStats(requestParameters: AnalyticsApiItemStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<ItemStats>> {
            return localVarFp.itemStats(requestParameters.bucket, requestParameters.heroIds, requestParameters.heroId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.includeItemIds, requestParameters.excludeItemIds, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Scoreboard
         * @param {AnalyticsApiPlayerScoreboardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerScoreboard(requestParameters: AnalyticsApiPlayerScoreboardRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Entry>> {
            return localVarFp.playerScoreboard(requestParameters.sortBy, requestParameters.sortDirection, requestParameters.heroId, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.start, requestParameters.limit, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Player Stats Metrics
         * @param {AnalyticsApiPlayerStatsMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerStatsMetrics(requestParameters: AnalyticsApiPlayerStatsMetricsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: HashMapValue; }> {
            return localVarFp.playerStatsMetrics(requestParameters.heroIds, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.maxMatches, requestParameters.includeItemIds, requestParameters.excludeItemIds, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for abilityOrderStats operation in AnalyticsApi.
 */
export interface AnalyticsApiAbilityOrderStatsRequest {
    /**
     * See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId: number

    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their minimum number of ability upgrades over the whole match.
     */
    readonly minAbilityUpgrades?: number | null

    /**
     * Filter players based on their maximum number of ability upgrades over the whole match.
     */
    readonly maxAbilityUpgrades?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * The minimum number of matches played for an ability order to be included in the response.
     */
    readonly minMatches?: number | null

    /**
     * Filter for matches with a specific player account ID.
     */
    readonly accountId?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for badgeDistribution operation in AnalyticsApi.
 */
export interface AnalyticsApiBadgeDistributionRequest {
    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter matches based on whether they are in the high skill range.
     */
    readonly isHighSkillRangeParties?: boolean | null

    /**
     * Filter matches based on whether they are in the low priority pool.
     */
    readonly isLowPriPool?: boolean | null

    /**
     * Filter matches based on whether they are in the new player pool.
     */
    readonly isNewPlayerPool?: boolean | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null
}

/**
 * Request parameters for buildItemStats operation in AnalyticsApi.
 */
export interface AnalyticsApiBuildItemStatsRequest {
    /**
     * Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId?: number | null

    /**
     * Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minLastUpdatedUnixTimestamp?: number | null

    /**
     * Filter builds based on their last updated time (Unix timestamp).
     */
    readonly maxLastUpdatedUnixTimestamp?: number | null
}

/**
 * Request parameters for heroCombStats operation in AnalyticsApi.
 */
export interface AnalyticsApiHeroCombStatsRequest {
    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly includeHeroIds?: Array<number> | null

    /**
     * Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly excludeHeroIds?: Array<number> | null

    /**
     * The minimum number of matches played for a hero combination to be included in the response.
     */
    readonly minMatches?: number | null

    /**
     * The maximum number of matches played for a hero combination to be included in the response.
     */
    readonly maxMatches?: number | null

    /**
     * The combination size to return.
     */
    readonly combSize?: number | null

    /**
     * Filter for matches with a specific player account ID.
     */
    readonly accountId?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for heroCountersStats operation in AnalyticsApi.
 */
export interface AnalyticsApiHeroCountersStatsRequest {
    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter enemy players based on their net worth.
     */
    readonly minEnemyNetworth?: number | null

    /**
     * Filter enemy players based on their net worth.
     */
    readonly maxEnemyNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
     */
    readonly sameLaneFilter?: boolean | null

    /**
     * The minimum number of matches played for a hero combination to be included in the response.
     */
    readonly minMatches?: number | null

    /**
     * The maximum number of matches played for a hero combination to be included in the response.
     */
    readonly maxMatches?: number | null

    /**
     * Filter for matches with a specific player account ID.
     */
    readonly accountId?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for heroScoreboard operation in AnalyticsApi.
 */
export interface AnalyticsApiHeroScoreboardRequest {
    /**
     * The field to sort by.
     */
    readonly sortBy: HeroScoreboardSortByEnum

    /**
     * The direction to sort heroes in.
     */
    readonly sortDirection?: HeroScoreboardSortDirectionEnum

    /**
     * Filter by min number of matches played.
     */
    readonly minMatches?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * Filter for matches with a specific player account ID.
     */
    readonly accountId?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for heroStats operation in AnalyticsApi.
 */
export interface AnalyticsApiHeroStatsRequest {
    /**
     * Bucket allows you to group the stats by a specific field.
     */
    readonly bucket?: HeroStatsBucketEnum

    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * Filter players based on the number of matches they have played with a specific hero within the filtered time range.
     */
    readonly minHeroMatches?: number | null

    /**
     * Filter players based on the number of matches they have played with a specific hero within the filtered time range.
     */
    readonly maxHeroMatches?: number | null

    /**
     * Filter players based on the number of matches they have played with a specific hero in their entire history.
     */
    readonly minHeroMatchesTotal?: number | null

    /**
     * Filter players based on the number of matches they have played with a specific hero in their entire history.
     */
    readonly maxHeroMatchesTotal?: number | null

    /**
     * Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     */
    readonly includeItemIds?: Array<number> | null

    /**
     * Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     */
    readonly excludeItemIds?: Array<number> | null

    /**
     * Filter for matches with a specific player account ID.
     */
    readonly accountId?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for heroSynergiesStats operation in AnalyticsApi.
 */
export interface AnalyticsApiHeroSynergiesStatsRequest {
    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
     */
    readonly sameLaneFilter?: boolean | null

    /**
     * When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation.
     */
    readonly samePartyFilter?: boolean | null

    /**
     * The minimum number of matches played for a hero combination to be included in the response.
     */
    readonly minMatches?: number | null

    /**
     * The maximum number of matches played for a hero combination to be included in the response.
     */
    readonly maxMatches?: number | null

    /**
     * Filter for matches with a specific player account ID.
     */
    readonly accountId?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for itemPermutationStats operation in AnalyticsApi.
 */
export interface AnalyticsApiItemPermutationStatsRequest {
    /**
     * Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     */
    readonly itemIds?: Array<number> | null

    /**
     * The combination size to return.
     */
    readonly combSize?: number | null

    /**
     * Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroIds?: string | null

    /**
     * Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * Filter for matches with a specific player account ID.
     */
    readonly accountId?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for itemStats operation in AnalyticsApi.
 */
export interface AnalyticsApiItemStatsRequest {
    /**
     * Bucket allows you to group the stats by a specific field.
     */
    readonly bucket?: ItemStatsBucketEnum

    /**
     * Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroIds?: string | null

    /**
     * Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     */
    readonly includeItemIds?: Array<number> | null

    /**
     * Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     */
    readonly excludeItemIds?: Array<number> | null

    /**
     * The minimum number of matches played for an item to be included in the response.
     */
    readonly minMatches?: number | null

    /**
     * The maximum number of matches played for a hero combination to be included in the response.
     */
    readonly maxMatches?: number | null

    /**
     * Filter for matches with a specific player account ID.
     */
    readonly accountId?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for playerScoreboard operation in AnalyticsApi.
 */
export interface AnalyticsApiPlayerScoreboardRequest {
    /**
     * The field to sort by.
     */
    readonly sortBy: PlayerScoreboardSortByEnum

    /**
     * The direction to sort players in.
     */
    readonly sortDirection?: PlayerScoreboardSortDirectionEnum

    /**
     * Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId?: number | null

    /**
     * The minimum number of matches played for a player to be included in the scoreboard.
     */
    readonly minMatches?: number | null

    /**
     * The maximum number of matches played for a hero combination to be included in the response.
     */
    readonly maxMatches?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * The offset to start fetching players from.
     */
    readonly start?: number | null

    /**
     * The maximum number of players to fetch.
     */
    readonly limit?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for playerStatsMetrics operation in AnalyticsApi.
 */
export interface AnalyticsApiPlayerStatsMetricsRequest {
    /**
     * Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroIds?: string | null

    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * The maximum number of matches to analyze.
     */
    readonly maxMatches?: number | null

    /**
     * Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     */
    readonly includeItemIds?: Array<number> | null

    /**
     * Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
     */
    readonly excludeItemIds?: Array<number> | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * AnalyticsApi - object-oriented interface
 */
export class AnalyticsApi extends BaseAPI {
    /**
     *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Ability Order Stats
     * @param {AnalyticsApiAbilityOrderStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public abilityOrderStats(requestParameters: AnalyticsApiAbilityOrderStatsRequest, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).abilityOrderStats(requestParameters.heroId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minAbilityUpgrades, requestParameters.maxAbilityUpgrades, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.minMatches, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Badge Distribution
     * @param {AnalyticsApiBadgeDistributionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public badgeDistribution(requestParameters: AnalyticsApiBadgeDistributionRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).badgeDistribution(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.isHighSkillRangeParties, requestParameters.isLowPriPool, requestParameters.isNewPlayerPool, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Build Item Stats
     * @param {AnalyticsApiBuildItemStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public buildItemStats(requestParameters: AnalyticsApiBuildItemStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).buildItemStats(requestParameters.heroId, requestParameters.minLastUpdatedUnixTimestamp, requestParameters.maxLastUpdatedUnixTimestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Comb Stats
     * @param {AnalyticsApiHeroCombStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public heroCombStats(requestParameters: AnalyticsApiHeroCombStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroCombStats(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.includeHeroIds, requestParameters.excludeHeroIds, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.combSize, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Counter Stats
     * @param {AnalyticsApiHeroCountersStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public heroCountersStats(requestParameters: AnalyticsApiHeroCountersStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroCountersStats(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minEnemyNetworth, requestParameters.maxEnemyNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.sameLaneFilter, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Scoreboard
     * @param {AnalyticsApiHeroScoreboardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public heroScoreboard(requestParameters: AnalyticsApiHeroScoreboardRequest, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroScoreboard(requestParameters.sortBy, requestParameters.sortDirection, requestParameters.minMatches, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Stats
     * @param {AnalyticsApiHeroStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public heroStats(requestParameters: AnalyticsApiHeroStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroStats(requestParameters.bucket, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.minHeroMatches, requestParameters.maxHeroMatches, requestParameters.minHeroMatchesTotal, requestParameters.maxHeroMatchesTotal, requestParameters.includeItemIds, requestParameters.excludeItemIds, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Synergy Stats
     * @param {AnalyticsApiHeroSynergiesStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public heroSynergiesStats(requestParameters: AnalyticsApiHeroSynergiesStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).heroSynergiesStats(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.sameLaneFilter, requestParameters.samePartyFilter, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Item Permutation Stats
     * @param {AnalyticsApiItemPermutationStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemPermutationStats(requestParameters: AnalyticsApiItemPermutationStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).itemPermutationStats(requestParameters.itemIds, requestParameters.combSize, requestParameters.heroIds, requestParameters.heroId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Item Stats
     * @param {AnalyticsApiItemStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public itemStats(requestParameters: AnalyticsApiItemStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).itemStats(requestParameters.bucket, requestParameters.heroIds, requestParameters.heroId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.includeItemIds, requestParameters.excludeItemIds, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Player Scoreboard
     * @param {AnalyticsApiPlayerScoreboardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public playerScoreboard(requestParameters: AnalyticsApiPlayerScoreboardRequest, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).playerScoreboard(requestParameters.sortBy, requestParameters.sortDirection, requestParameters.heroId, requestParameters.minMatches, requestParameters.maxMatches, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.start, requestParameters.limit, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Player Stats Metrics
     * @param {AnalyticsApiPlayerStatsMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public playerStatsMetrics(requestParameters: AnalyticsApiPlayerStatsMetricsRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).playerStatsMetrics(requestParameters.heroIds, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.maxMatches, requestParameters.includeItemIds, requestParameters.excludeItemIds, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }
}

export const HeroScoreboardSortByEnum = {
    Matches: 'matches',
    Wins: 'wins',
    Losses: 'losses',
    Winrate: 'winrate',
    MaxKillsPerMatch: 'max_kills_per_match',
    AvgKillsPerMatch: 'avg_kills_per_match',
    Kills: 'kills',
    MaxDeathsPerMatch: 'max_deaths_per_match',
    AvgDeathsPerMatch: 'avg_deaths_per_match',
    Deaths: 'deaths',
    MaxDamageTakenPerMatch: 'max_damage_taken_per_match',
    AvgDamageTakenPerMatch: 'avg_damage_taken_per_match',
    DamageTaken: 'damage_taken',
    MaxAssistsPerMatch: 'max_assists_per_match',
    AvgAssistsPerMatch: 'avg_assists_per_match',
    Assists: 'assists',
    MaxNetWorthPerMatch: 'max_net_worth_per_match',
    AvgNetWorthPerMatch: 'avg_net_worth_per_match',
    NetWorth: 'net_worth',
    MaxLastHitsPerMatch: 'max_last_hits_per_match',
    AvgLastHitsPerMatch: 'avg_last_hits_per_match',
    LastHits: 'last_hits',
    MaxDeniesPerMatch: 'max_denies_per_match',
    AvgDeniesPerMatch: 'avg_denies_per_match',
    Denies: 'denies',
    MaxPlayerLevelPerMatch: 'max_player_level_per_match',
    AvgPlayerLevelPerMatch: 'avg_player_level_per_match',
    PlayerLevel: 'player_level',
    MaxCreepKillsPerMatch: 'max_creep_kills_per_match',
    AvgCreepKillsPerMatch: 'avg_creep_kills_per_match',
    CreepKills: 'creep_kills',
    MaxNeutralKillsPerMatch: 'max_neutral_kills_per_match',
    AvgNeutralKillsPerMatch: 'avg_neutral_kills_per_match',
    NeutralKills: 'neutral_kills',
    MaxCreepDamagePerMatch: 'max_creep_damage_per_match',
    AvgCreepDamagePerMatch: 'avg_creep_damage_per_match',
    CreepDamage: 'creep_damage',
    MaxPlayerDamagePerMatch: 'max_player_damage_per_match',
    AvgPlayerDamagePerMatch: 'avg_player_damage_per_match',
    PlayerDamage: 'player_damage',
    MaxNeutralDamagePerMatch: 'max_neutral_damage_per_match',
    AvgNeutralDamagePerMatch: 'avg_neutral_damage_per_match',
    NeutralDamage: 'neutral_damage',
    MaxBossDamagePerMatch: 'max_boss_damage_per_match',
    AvgBossDamagePerMatch: 'avg_boss_damage_per_match',
    BossDamage: 'boss_damage',
    MaxMaxHealthPerMatch: 'max_max_health_per_match',
    AvgMaxHealthPerMatch: 'avg_max_health_per_match',
    MaxHealth: 'max_health',
    MaxShotsHitPerMatch: 'max_shots_hit_per_match',
    AvgShotsHitPerMatch: 'avg_shots_hit_per_match',
    ShotsHit: 'shots_hit',
    MaxShotsMissedPerMatch: 'max_shots_missed_per_match',
    AvgShotsMissedPerMatch: 'avg_shots_missed_per_match',
    ShotsMissed: 'shots_missed',
    MaxHeroBulletsHitPerMatch: 'max_hero_bullets_hit_per_match',
    AvgHeroBulletsHitPerMatch: 'avg_hero_bullets_hit_per_match',
    HeroBulletsHit: 'hero_bullets_hit',
    MaxHeroBulletsHitCritPerMatch: 'max_hero_bullets_hit_crit_per_match',
    AvgHeroBulletsHitCritPerMatch: 'avg_hero_bullets_hit_crit_per_match',
    HeroBulletsHitCrit: 'hero_bullets_hit_crit'
} as const;
export type HeroScoreboardSortByEnum = typeof HeroScoreboardSortByEnum[keyof typeof HeroScoreboardSortByEnum];
export const HeroScoreboardSortDirectionEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;
export type HeroScoreboardSortDirectionEnum = typeof HeroScoreboardSortDirectionEnum[keyof typeof HeroScoreboardSortDirectionEnum];
export const HeroStatsBucketEnum = {
    NoBucket: 'no_bucket',
    StartTimeHour: 'start_time_hour',
    StartTimeDay: 'start_time_day',
    StartTimeWeek: 'start_time_week',
    StartTimeMonth: 'start_time_month'
} as const;
export type HeroStatsBucketEnum = typeof HeroStatsBucketEnum[keyof typeof HeroStatsBucketEnum];
export const ItemStatsBucketEnum = {
    NoBucket: 'no_bucket',
    Hero: 'hero',
    Team: 'team',
    StartTimeHour: 'start_time_hour',
    StartTimeDay: 'start_time_day',
    StartTimeWeek: 'start_time_week',
    StartTimeMonth: 'start_time_month',
    GameTimeMin: 'game_time_min',
    GameTimeNormalizedPercentage: 'game_time_normalized_percentage',
    NetWorthBy1000: 'net_worth_by_1000',
    NetWorthBy2000: 'net_worth_by_2000',
    NetWorthBy3000: 'net_worth_by_3000',
    NetWorthBy5000: 'net_worth_by_5000',
    NetWorthBy10000: 'net_worth_by_10000'
} as const;
export type ItemStatsBucketEnum = typeof ItemStatsBucketEnum[keyof typeof ItemStatsBucketEnum];
export const PlayerScoreboardSortByEnum = {
    Matches: 'matches',
    Wins: 'wins',
    Losses: 'losses',
    Winrate: 'winrate',
    MaxKillsPerMatch: 'max_kills_per_match',
    AvgKillsPerMatch: 'avg_kills_per_match',
    Kills: 'kills',
    MaxDeathsPerMatch: 'max_deaths_per_match',
    AvgDeathsPerMatch: 'avg_deaths_per_match',
    Deaths: 'deaths',
    MaxDamageTakenPerMatch: 'max_damage_taken_per_match',
    AvgDamageTakenPerMatch: 'avg_damage_taken_per_match',
    DamageTaken: 'damage_taken',
    MaxAssistsPerMatch: 'max_assists_per_match',
    AvgAssistsPerMatch: 'avg_assists_per_match',
    Assists: 'assists',
    MaxNetWorthPerMatch: 'max_net_worth_per_match',
    AvgNetWorthPerMatch: 'avg_net_worth_per_match',
    NetWorth: 'net_worth',
    MaxLastHitsPerMatch: 'max_last_hits_per_match',
    AvgLastHitsPerMatch: 'avg_last_hits_per_match',
    LastHits: 'last_hits',
    MaxDeniesPerMatch: 'max_denies_per_match',
    AvgDeniesPerMatch: 'avg_denies_per_match',
    Denies: 'denies',
    MaxPlayerLevelPerMatch: 'max_player_level_per_match',
    AvgPlayerLevelPerMatch: 'avg_player_level_per_match',
    PlayerLevel: 'player_level',
    MaxCreepKillsPerMatch: 'max_creep_kills_per_match',
    AvgCreepKillsPerMatch: 'avg_creep_kills_per_match',
    CreepKills: 'creep_kills',
    MaxNeutralKillsPerMatch: 'max_neutral_kills_per_match',
    AvgNeutralKillsPerMatch: 'avg_neutral_kills_per_match',
    NeutralKills: 'neutral_kills',
    MaxCreepDamagePerMatch: 'max_creep_damage_per_match',
    AvgCreepDamagePerMatch: 'avg_creep_damage_per_match',
    CreepDamage: 'creep_damage',
    MaxPlayerDamagePerMatch: 'max_player_damage_per_match',
    AvgPlayerDamagePerMatch: 'avg_player_damage_per_match',
    PlayerDamage: 'player_damage',
    MaxNeutralDamagePerMatch: 'max_neutral_damage_per_match',
    AvgNeutralDamagePerMatch: 'avg_neutral_damage_per_match',
    NeutralDamage: 'neutral_damage',
    MaxBossDamagePerMatch: 'max_boss_damage_per_match',
    AvgBossDamagePerMatch: 'avg_boss_damage_per_match',
    BossDamage: 'boss_damage',
    MaxMaxHealthPerMatch: 'max_max_health_per_match',
    AvgMaxHealthPerMatch: 'avg_max_health_per_match',
    MaxHealth: 'max_health',
    MaxShotsHitPerMatch: 'max_shots_hit_per_match',
    AvgShotsHitPerMatch: 'avg_shots_hit_per_match',
    ShotsHit: 'shots_hit',
    MaxShotsMissedPerMatch: 'max_shots_missed_per_match',
    AvgShotsMissedPerMatch: 'avg_shots_missed_per_match',
    ShotsMissed: 'shots_missed',
    MaxHeroBulletsHitPerMatch: 'max_hero_bullets_hit_per_match',
    AvgHeroBulletsHitPerMatch: 'avg_hero_bullets_hit_per_match',
    HeroBulletsHit: 'hero_bullets_hit',
    MaxHeroBulletsHitCritPerMatch: 'max_hero_bullets_hit_crit_per_match',
    AvgHeroBulletsHitCritPerMatch: 'avg_hero_bullets_hit_crit_per_match',
    HeroBulletsHitCrit: 'hero_bullets_hit_crit'
} as const;
export type PlayerScoreboardSortByEnum = typeof PlayerScoreboardSortByEnum[keyof typeof PlayerScoreboardSortByEnum];
export const PlayerScoreboardSortDirectionEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;
export type PlayerScoreboardSortDirectionEnum = typeof PlayerScoreboardSortDirectionEnum[keyof typeof PlayerScoreboardSortDirectionEnum];


/**
 * BuildsApi - axios parameter creator
 */
export const BuildsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Search for builds based on various criteria.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Search
         * @param {number} [minUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [maxUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [minPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {number} [maxPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {SearchBuildsSortByEnum} [sortBy] The field to sort the builds by.
         * @param {number} [start] The index of the first build to return.
         * @param {number} [limit] The maximum number of builds to return.
         * @param {SearchBuildsSortDirectionEnum} [sortDirection] The direction to sort the builds in.
         * @param {string} [searchName] Search for builds with a name containing this string.
         * @param {string} [searchDescription] Search for builds with a description containing this string.
         * @param {boolean} [onlyLatest] Only return the latest version of each build.
         * @param {number} [language] Filter builds by language.
         * @param {number} [buildId] Filter builds by ID.
         * @param {number} [version] Filter builds by version.
         * @param {number} [heroId] Filter builds by hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number} [tag] Filter builds by tag.
         * @param {number} [rollupCategory] Filter builds by rollup category.
         * @param {number} [authorId] The author\&#39;s &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBuilds: async (minUnixTimestamp?: number, maxUnixTimestamp?: number, minPublishedUnixTimestamp?: number, maxPublishedUnixTimestamp?: number, sortBy?: SearchBuildsSortByEnum, start?: number, limit?: number, sortDirection?: SearchBuildsSortDirectionEnum, searchName?: string, searchDescription?: string, onlyLatest?: boolean, language?: number, buildId?: number, version?: number, heroId?: number, tag?: number, rollupCategory?: number, authorId?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/builds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minPublishedUnixTimestamp !== undefined) {
                localVarQueryParameter['min_published_unix_timestamp'] = minPublishedUnixTimestamp;
            }

            if (maxPublishedUnixTimestamp !== undefined) {
                localVarQueryParameter['max_published_unix_timestamp'] = maxPublishedUnixTimestamp;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sort_direction'] = sortDirection;
            }

            if (searchName !== undefined) {
                localVarQueryParameter['search_name'] = searchName;
            }

            if (searchDescription !== undefined) {
                localVarQueryParameter['search_description'] = searchDescription;
            }

            if (onlyLatest !== undefined) {
                localVarQueryParameter['only_latest'] = onlyLatest;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (buildId !== undefined) {
                localVarQueryParameter['build_id'] = buildId;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (heroId !== undefined) {
                localVarQueryParameter['hero_id'] = heroId;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (rollupCategory !== undefined) {
                localVarQueryParameter['rollup_category'] = rollupCategory;
            }

            if (authorId !== undefined) {
                localVarQueryParameter['author_id'] = authorId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BuildsApi - functional programming interface
 */
export const BuildsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BuildsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Search for builds based on various criteria.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Search
         * @param {number} [minUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [maxUnixTimestamp] Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
         * @param {number} [minPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {number} [maxPublishedUnixTimestamp] Filter builds based on their published time (Unix timestamp).
         * @param {SearchBuildsSortByEnum} [sortBy] The field to sort the builds by.
         * @param {number} [start] The index of the first build to return.
         * @param {number} [limit] The maximum number of builds to return.
         * @param {SearchBuildsSortDirectionEnum} [sortDirection] The direction to sort the builds in.
         * @param {string} [searchName] Search for builds with a name containing this string.
         * @param {string} [searchDescription] Search for builds with a description containing this string.
         * @param {boolean} [onlyLatest] Only return the latest version of each build.
         * @param {number} [language] Filter builds by language.
         * @param {number} [buildId] Filter builds by ID.
         * @param {number} [version] Filter builds by version.
         * @param {number} [heroId] Filter builds by hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number} [tag] Filter builds by tag.
         * @param {number} [rollupCategory] Filter builds by rollup category.
         * @param {number} [authorId] The author\&#39;s &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBuilds(minUnixTimestamp?: number, maxUnixTimestamp?: number, minPublishedUnixTimestamp?: number, maxPublishedUnixTimestamp?: number, sortBy?: SearchBuildsSortByEnum, start?: number, limit?: number, sortDirection?: SearchBuildsSortDirectionEnum, searchName?: string, searchDescription?: string, onlyLatest?: boolean, language?: number, buildId?: number, version?: number, heroId?: number, tag?: number, rollupCategory?: number, authorId?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Build>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBuilds(minUnixTimestamp, maxUnixTimestamp, minPublishedUnixTimestamp, maxPublishedUnixTimestamp, sortBy, start, limit, sortDirection, searchName, searchDescription, onlyLatest, language, buildId, version, heroId, tag, rollupCategory, authorId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BuildsApi.searchBuilds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BuildsApi - factory interface
 */
export const BuildsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BuildsApiFp(configuration)
    return {
        /**
         *  Search for builds based on various criteria.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Search
         * @param {BuildsApiSearchBuildsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBuilds(requestParameters: BuildsApiSearchBuildsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<Build>> {
            return localVarFp.searchBuilds(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minPublishedUnixTimestamp, requestParameters.maxPublishedUnixTimestamp, requestParameters.sortBy, requestParameters.start, requestParameters.limit, requestParameters.sortDirection, requestParameters.searchName, requestParameters.searchDescription, requestParameters.onlyLatest, requestParameters.language, requestParameters.buildId, requestParameters.version, requestParameters.heroId, requestParameters.tag, requestParameters.rollupCategory, requestParameters.authorId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for searchBuilds operation in BuildsApi.
 */
export interface BuildsApiSearchBuildsRequest {
    /**
     * Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
     */
    readonly minUnixTimestamp?: number

    /**
     * Filter builds based on their &#x60;last_updated&#x60; time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number

    /**
     * Filter builds based on their published time (Unix timestamp).
     */
    readonly minPublishedUnixTimestamp?: number

    /**
     * Filter builds based on their published time (Unix timestamp).
     */
    readonly maxPublishedUnixTimestamp?: number

    /**
     * The field to sort the builds by.
     */
    readonly sortBy?: SearchBuildsSortByEnum

    /**
     * The index of the first build to return.
     */
    readonly start?: number

    /**
     * The maximum number of builds to return.
     */
    readonly limit?: number

    /**
     * The direction to sort the builds in.
     */
    readonly sortDirection?: SearchBuildsSortDirectionEnum

    /**
     * Search for builds with a name containing this string.
     */
    readonly searchName?: string

    /**
     * Search for builds with a description containing this string.
     */
    readonly searchDescription?: string

    /**
     * Only return the latest version of each build.
     */
    readonly onlyLatest?: boolean

    /**
     * Filter builds by language.
     */
    readonly language?: number

    /**
     * Filter builds by ID.
     */
    readonly buildId?: number

    /**
     * Filter builds by version.
     */
    readonly version?: number

    /**
     * Filter builds by hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId?: number

    /**
     * Filter builds by tag.
     */
    readonly tag?: number

    /**
     * Filter builds by rollup category.
     */
    readonly rollupCategory?: number

    /**
     * The author\&#39;s &#x60;SteamID3&#x60;
     */
    readonly authorId?: number
}

/**
 * BuildsApi - object-oriented interface
 */
export class BuildsApi extends BaseAPI {
    /**
     *  Search for builds based on various criteria.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Search
     * @param {BuildsApiSearchBuildsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public searchBuilds(requestParameters: BuildsApiSearchBuildsRequest = {}, options?: RawAxiosRequestConfig) {
        return BuildsApiFp(this.configuration).searchBuilds(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minPublishedUnixTimestamp, requestParameters.maxPublishedUnixTimestamp, requestParameters.sortBy, requestParameters.start, requestParameters.limit, requestParameters.sortDirection, requestParameters.searchName, requestParameters.searchDescription, requestParameters.onlyLatest, requestParameters.language, requestParameters.buildId, requestParameters.version, requestParameters.heroId, requestParameters.tag, requestParameters.rollupCategory, requestParameters.authorId, options).then((request) => request(this.axios, this.basePath));
    }
}

export const SearchBuildsSortByEnum = {
    WeeklyFavorites: 'weekly_favorites',
    Favorites: 'favorites',
    Ignores: 'ignores',
    Reports: 'reports',
    UpdatedAt: 'updated_at',
    PublishedAt: 'published_at',
    Version: 'version'
} as const;
export type SearchBuildsSortByEnum = typeof SearchBuildsSortByEnum[keyof typeof SearchBuildsSortByEnum];
export const SearchBuildsSortDirectionEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;
export type SearchBuildsSortDirectionEnum = typeof SearchBuildsSortDirectionEnum[keyof typeof SearchBuildsSortDirectionEnum];


/**
 * CommandsApi - axios parameter creator
 */
export const CommandsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a list of available variables that can be used in the command endpoint.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Available Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableVariables: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/commands/variables/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *      Resolves a command and returns the resolved command.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/60s | | Key | - | | Global | 300req/60s |     
         * @summary Resolve Command
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {CommandResolveRegionEnum} [region] The players region
         * @param {string} [template] The command template to resolve
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandResolve: async (accountId: number, region?: CommandResolveRegionEnum, template?: string, heroName?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('commandResolve', 'accountId', accountId)
            const localVarPath = `/v1/commands/resolve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (template !== undefined) {
                localVarQueryParameter['template'] = template;
            }

            if (heroName !== undefined) {
                localVarQueryParameter['hero_name'] = heroName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Resolves variables and returns a map of variable name to resolved value.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/min | | Key | - | | Global | 300req/min |     
         * @summary Resolve Variables
         * @param {number} accountId 
         * @param {VariablesResolveRegionEnum} [region] 
         * @param {string} [variables] Variables to resolve, separated by commas.
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variablesResolve: async (accountId: number, region?: VariablesResolveRegionEnum, variables?: string, heroName?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('variablesResolve', 'accountId', accountId)
            const localVarPath = `/v1/commands/variables/resolve`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (heroName !== undefined) {
                localVarQueryParameter['hero_name'] = heroName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a map of str->int of widget versions.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Widget Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetVersions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/commands/widgets/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandsApi - functional programming interface
 */
export const CommandsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a list of available variables that can be used in the command endpoint.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Available Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availableVariables(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VariableDescription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availableVariables(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.availableVariables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *      Resolves a command and returns the resolved command.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/60s | | Key | - | | Global | 300req/60s |     
         * @summary Resolve Command
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {CommandResolveRegionEnum} [region] The players region
         * @param {string} [template] The command template to resolve
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandResolve(accountId: number, region?: CommandResolveRegionEnum, template?: string, heroName?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandResolve(accountId, region, template, heroName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.commandResolve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Resolves variables and returns a map of variable name to resolved value.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/min | | Key | - | | Global | 300req/min |     
         * @summary Resolve Variables
         * @param {number} accountId 
         * @param {VariablesResolveRegionEnum} [region] 
         * @param {string} [variables] Variables to resolve, separated by commas.
         * @param {string | null} [heroName] Hero name to check for hero specific stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variablesResolve(accountId: number, region?: VariablesResolveRegionEnum, variables?: string, heroName?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variablesResolve(accountId, region, variables, heroName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.variablesResolve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns a map of str->int of widget versions.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Widget Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async widgetVersions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.widgetVersions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandsApi.widgetVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommandsApi - factory interface
 */
export const CommandsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandsApiFp(configuration)
    return {
        /**
         *  Returns a list of available variables that can be used in the command endpoint.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Available Variables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availableVariables(options?: RawAxiosRequestConfig): AxiosPromise<Array<VariableDescription>> {
            return localVarFp.availableVariables(options).then((request) => request(axios, basePath));
        },
        /**
         *      Resolves a command and returns the resolved command.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/60s | | Key | - | | Global | 300req/60s |     
         * @summary Resolve Command
         * @param {CommandsApiCommandResolveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandResolve(requestParameters: CommandsApiCommandResolveRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.commandResolve(requestParameters.accountId, requestParameters.region, requestParameters.template, requestParameters.heroName, options).then((request) => request(axios, basePath));
        },
        /**
         *  Resolves variables and returns a map of variable name to resolved value.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/min | | Key | - | | Global | 300req/min |     
         * @summary Resolve Variables
         * @param {CommandsApiVariablesResolveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variablesResolve(requestParameters: CommandsApiVariablesResolveRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.variablesResolve(requestParameters.accountId, requestParameters.region, requestParameters.variables, requestParameters.heroName, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a map of str->int of widget versions.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Widget Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        widgetVersions(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.widgetVersions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for commandResolve operation in CommandsApi.
 */
export interface CommandsApiCommandResolveRequest {
    /**
     * The players &#x60;SteamID3&#x60;
     */
    readonly accountId: number

    /**
     * The players region
     */
    readonly region?: CommandResolveRegionEnum

    /**
     * The command template to resolve
     */
    readonly template?: string

    /**
     * Hero name to check for hero specific stats
     */
    readonly heroName?: string | null
}

/**
 * Request parameters for variablesResolve operation in CommandsApi.
 */
export interface CommandsApiVariablesResolveRequest {
    readonly accountId: number

    readonly region?: VariablesResolveRegionEnum

    /**
     * Variables to resolve, separated by commas.
     */
    readonly variables?: string

    /**
     * Hero name to check for hero specific stats
     */
    readonly heroName?: string | null
}

/**
 * CommandsApi - object-oriented interface
 */
export class CommandsApi extends BaseAPI {
    /**
     *  Returns a list of available variables that can be used in the command endpoint.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Available Variables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public availableVariables(options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).availableVariables(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *      Resolves a command and returns the resolved command.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/60s | | Key | - | | Global | 300req/60s |     
     * @summary Resolve Command
     * @param {CommandsApiCommandResolveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public commandResolve(requestParameters: CommandsApiCommandResolveRequest, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).commandResolve(requestParameters.accountId, requestParameters.region, requestParameters.template, requestParameters.heroName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Resolves variables and returns a map of variable name to resolved value.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 60req/min | | Key | - | | Global | 300req/min |     
     * @summary Resolve Variables
     * @param {CommandsApiVariablesResolveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public variablesResolve(requestParameters: CommandsApiVariablesResolveRequest, options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).variablesResolve(requestParameters.accountId, requestParameters.region, requestParameters.variables, requestParameters.heroName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a map of str->int of widget versions.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
     * @summary Widget Versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public widgetVersions(options?: RawAxiosRequestConfig) {
        return CommandsApiFp(this.configuration).widgetVersions(options).then((request) => request(this.axios, this.basePath));
    }
}

export const CommandResolveRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type CommandResolveRegionEnum = typeof CommandResolveRegionEnum[keyof typeof CommandResolveRegionEnum];
export const VariablesResolveRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type VariablesResolveRegionEnum = typeof VariablesResolveRegionEnum[keyof typeof VariablesResolveRegionEnum];


/**
 * CustomMatchesApi - axios parameter creator
 */
export const CustomMatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  This endpoint creates a custom match using a bot account.  **Process:** 1. A party is created with your provided settings. 2. The system waits for the party code to be generated. 3. The party code is returned in the response. 4. The bot switches to spectator mode. 5. The bot marks itself as ready. 6. You and other players join, ready up, and start the match.  **Callbacks:** If a callback URL is provided, POST requests will be sent to it: - **settings:** When lobby settings change, a POST is sent to `{callback_url}/settings` with the `CsoCitadelParty` protobuf message as JSON. - **match start:** When the match starts, a POST is sent to `{callback_url}` with the match ID.  _Protobuf definitions: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)_  **Note:** The bot will leave the match 15 minutes after creation, regardless of match state.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
         * @summary Create Match
         * @param {CreateCustomRequest} createCustomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustom: async (createCustomRequest: CreateCustomRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomRequest' is not null or undefined
            assertParamExists('createCustom', 'createCustomRequest', createCustomRequest)
            const localVarPath = `/v1/matches/custom/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint allows you to get the match id of a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Get Match ID
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustom: async (partyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partyId' is not null or undefined
            assertParamExists('getCustom', 'partyId', partyId)
            const localVarPath = `/v1/matches/custom/{party_id}/match-id`
                .replace(`{${"party_id"}}`, encodeURIComponent(String(partyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint allows you to ready up for a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
         * @summary Ready Up
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readyUp: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/custom/{lobby_id}/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomMatchesApi - functional programming interface
 */
export const CustomMatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomMatchesApiAxiosParamCreator(configuration)
    return {
        /**
         *  This endpoint creates a custom match using a bot account.  **Process:** 1. A party is created with your provided settings. 2. The system waits for the party code to be generated. 3. The party code is returned in the response. 4. The bot switches to spectator mode. 5. The bot marks itself as ready. 6. You and other players join, ready up, and start the match.  **Callbacks:** If a callback URL is provided, POST requests will be sent to it: - **settings:** When lobby settings change, a POST is sent to `{callback_url}/settings` with the `CsoCitadelParty` protobuf message as JSON. - **match start:** When the match starts, a POST is sent to `{callback_url}` with the match ID.  _Protobuf definitions: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)_  **Note:** The bot will leave the match 15 minutes after creation, regardless of match state.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
         * @summary Create Match
         * @param {CreateCustomRequest} createCustomRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustom(createCustomRequest: CreateCustomRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustom(createCustomRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomMatchesApi.createCustom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint allows you to get the match id of a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Get Match ID
         * @param {number} partyId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustom(partyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomMatchIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustom(partyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomMatchesApi.getCustom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint allows you to ready up for a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
         * @summary Ready Up
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readyUp(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readyUp(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomMatchesApi.readyUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomMatchesApi - factory interface
 */
export const CustomMatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomMatchesApiFp(configuration)
    return {
        /**
         *  This endpoint creates a custom match using a bot account.  **Process:** 1. A party is created with your provided settings. 2. The system waits for the party code to be generated. 3. The party code is returned in the response. 4. The bot switches to spectator mode. 5. The bot marks itself as ready. 6. You and other players join, ready up, and start the match.  **Callbacks:** If a callback URL is provided, POST requests will be sent to it: - **settings:** When lobby settings change, a POST is sent to `{callback_url}/settings` with the `CsoCitadelParty` protobuf message as JSON. - **match start:** When the match starts, a POST is sent to `{callback_url}` with the match ID.  _Protobuf definitions: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)_  **Note:** The bot will leave the match 15 minutes after creation, regardless of match state.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
         * @summary Create Match
         * @param {CustomMatchesApiCreateCustomRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustom(requestParameters: CustomMatchesApiCreateCustomRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateCustomResponse> {
            return localVarFp.createCustom(requestParameters.createCustomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint allows you to get the match id of a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
         * @summary Get Match ID
         * @param {CustomMatchesApiGetCustomRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustom(requestParameters: CustomMatchesApiGetCustomRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetCustomMatchIdResponse> {
            return localVarFp.getCustom(requestParameters.partyId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint allows you to ready up for a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
         * @summary Ready Up
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readyUp(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.readyUp(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCustom operation in CustomMatchesApi.
 */
export interface CustomMatchesApiCreateCustomRequest {
    readonly createCustomRequest: CreateCustomRequest
}

/**
 * Request parameters for getCustom operation in CustomMatchesApi.
 */
export interface CustomMatchesApiGetCustomRequest {
    readonly partyId: number
}

/**
 * CustomMatchesApi - object-oriented interface
 */
export class CustomMatchesApi extends BaseAPI {
    /**
     *  This endpoint creates a custom match using a bot account.  **Process:** 1. A party is created with your provided settings. 2. The system waits for the party code to be generated. 3. The party code is returned in the response. 4. The bot switches to spectator mode. 5. The bot marks itself as ready. 6. You and other players join, ready up, and start the match.  **Callbacks:** If a callback URL is provided, POST requests will be sent to it: - **settings:** When lobby settings change, a POST is sent to `{callback_url}/settings` with the `CsoCitadelParty` protobuf message as JSON. - **match start:** When the match starts, a POST is sent to `{callback_url}` with the match ID.  _Protobuf definitions: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)_  **Note:** The bot will leave the match 15 minutes after creation, regardless of match state.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
     * @summary Create Match
     * @param {CustomMatchesApiCreateCustomRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createCustom(requestParameters: CustomMatchesApiCreateCustomRequest, options?: RawAxiosRequestConfig) {
        return CustomMatchesApiFp(this.configuration).createCustom(requestParameters.createCustomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint allows you to get the match id of a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - | 
     * @summary Get Match ID
     * @param {CustomMatchesApiGetCustomRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getCustom(requestParameters: CustomMatchesApiGetCustomRequest, options?: RawAxiosRequestConfig) {
        return CustomMatchesApiFp(this.configuration).getCustom(requestParameters.partyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint allows you to ready up for a custom match.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | API-Key ONLY | | Key | 100req/30min | | Global | 1000req/h | 
     * @summary Ready Up
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public readyUp(options?: RawAxiosRequestConfig) {
        return CustomMatchesApiFp(this.configuration).readyUp(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DataPrivacyApi - axios parameter creator
 */
export const DataPrivacyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Endpoint to request deletion of personal data.     
         * @summary Request Data Deletion
         * @param {DataPrivacyRequest} dataPrivacyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestDeletion: async (dataPrivacyRequest: DataPrivacyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPrivacyRequest' is not null or undefined
            assertParamExists('requestDeletion', 'dataPrivacyRequest', dataPrivacyRequest)
            const localVarPath = `/v1/data-privacy/request-deletion`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataPrivacyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Endpoint to request tracking of personal data.  Use this to opt back into data tracking after previously requesting deletion.     
         * @summary Request Data Tracking
         * @param {DataPrivacyRequest} dataPrivacyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTracking: async (dataPrivacyRequest: DataPrivacyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dataPrivacyRequest' is not null or undefined
            assertParamExists('requestTracking', 'dataPrivacyRequest', dataPrivacyRequest)
            const localVarPath = `/v1/data-privacy/request-tracking`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataPrivacyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataPrivacyApi - functional programming interface
 */
export const DataPrivacyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataPrivacyApiAxiosParamCreator(configuration)
    return {
        /**
         *  Endpoint to request deletion of personal data.     
         * @summary Request Data Deletion
         * @param {DataPrivacyRequest} dataPrivacyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestDeletion(dataPrivacyRequest: DataPrivacyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestDeletion(dataPrivacyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataPrivacyApi.requestDeletion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Endpoint to request tracking of personal data.  Use this to opt back into data tracking after previously requesting deletion.     
         * @summary Request Data Tracking
         * @param {DataPrivacyRequest} dataPrivacyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTracking(dataPrivacyRequest: DataPrivacyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTracking(dataPrivacyRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataPrivacyApi.requestTracking']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataPrivacyApi - factory interface
 */
export const DataPrivacyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataPrivacyApiFp(configuration)
    return {
        /**
         *  Endpoint to request deletion of personal data.     
         * @summary Request Data Deletion
         * @param {DataPrivacyApiRequestDeletionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestDeletion(requestParameters: DataPrivacyApiRequestDeletionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.requestDeletion(requestParameters.dataPrivacyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Endpoint to request tracking of personal data.  Use this to opt back into data tracking after previously requesting deletion.     
         * @summary Request Data Tracking
         * @param {DataPrivacyApiRequestTrackingRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTracking(requestParameters: DataPrivacyApiRequestTrackingRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.requestTracking(requestParameters.dataPrivacyRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for requestDeletion operation in DataPrivacyApi.
 */
export interface DataPrivacyApiRequestDeletionRequest {
    readonly dataPrivacyRequest: DataPrivacyRequest
}

/**
 * Request parameters for requestTracking operation in DataPrivacyApi.
 */
export interface DataPrivacyApiRequestTrackingRequest {
    readonly dataPrivacyRequest: DataPrivacyRequest
}

/**
 * DataPrivacyApi - object-oriented interface
 */
export class DataPrivacyApi extends BaseAPI {
    /**
     *  Endpoint to request deletion of personal data.     
     * @summary Request Data Deletion
     * @param {DataPrivacyApiRequestDeletionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestDeletion(requestParameters: DataPrivacyApiRequestDeletionRequest, options?: RawAxiosRequestConfig) {
        return DataPrivacyApiFp(this.configuration).requestDeletion(requestParameters.dataPrivacyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Endpoint to request tracking of personal data.  Use this to opt back into data tracking after previously requesting deletion.     
     * @summary Request Data Tracking
     * @param {DataPrivacyApiRequestTrackingRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public requestTracking(requestParameters: DataPrivacyApiRequestTrackingRequest, options?: RawAxiosRequestConfig) {
        return DataPrivacyApiFp(this.configuration).requestTracking(requestParameters.dataPrivacyRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ESportsApi - axios parameter creator
 */
export const ESportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  To use this Endpoint you need to have special permissions. Please contact us if you organize E-Sports Matches and want to ingest them to us.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 1000req/h | | Key | - | | Global | 10000req/h |     
         * @summary Ingest
         * @param {ESportsMatch} eSportsMatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestMatch: async (eSportsMatch: ESportsMatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eSportsMatch' is not null or undefined
            assertParamExists('ingestMatch', 'eSportsMatch', eSportsMatch)
            const localVarPath = `/v1/esports/ingest/match`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eSportsMatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matches: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/esports/matches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ESportsApi - functional programming interface
 */
export const ESportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ESportsApiAxiosParamCreator(configuration)
    return {
        /**
         *  To use this Endpoint you need to have special permissions. Please contact us if you organize E-Sports Matches and want to ingest them to us.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 1000req/h | | Key | - | | Global | 10000req/h |     
         * @summary Ingest
         * @param {ESportsMatch} eSportsMatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestMatch(eSportsMatch: ESportsMatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestMatch(eSportsMatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ESportsApi.ingestMatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matches(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ESportsMatch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matches(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ESportsApi.matches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ESportsApi - factory interface
 */
export const ESportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ESportsApiFp(configuration)
    return {
        /**
         *  To use this Endpoint you need to have special permissions. Please contact us if you organize E-Sports Matches and want to ingest them to us.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 1000req/h | | Key | - | | Global | 10000req/h |     
         * @summary Ingest
         * @param {ESportsApiIngestMatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestMatch(requestParameters: ESportsApiIngestMatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ingestMatch(requestParameters.eSportsMatch, options).then((request) => request(axios, basePath));
        },
        /**
         *  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Matches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matches(options?: RawAxiosRequestConfig): AxiosPromise<Array<ESportsMatch>> {
            return localVarFp.matches(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ingestMatch operation in ESportsApi.
 */
export interface ESportsApiIngestMatchRequest {
    readonly eSportsMatch: ESportsMatch
}

/**
 * ESportsApi - object-oriented interface
 */
export class ESportsApi extends BaseAPI {
    /**
     *  To use this Endpoint you need to have special permissions. Please contact us if you organize E-Sports Matches and want to ingest them to us.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 1000req/h | | Key | - | | Global | 10000req/h |     
     * @summary Ingest
     * @param {ESportsApiIngestMatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ingestMatch(requestParameters: ESportsApiIngestMatchRequest, options?: RawAxiosRequestConfig) {
        return ESportsApiFp(this.configuration).ingestMatch(requestParameters.eSportsMatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary List Matches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public matches(options?: RawAxiosRequestConfig) {
        return ESportsApiFp(this.configuration).matches(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InfoApi - axios parameter creator
 */
export const InfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Checks the health of the services.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/info/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns information about the API.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary API Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoApi - functional programming interface
 */
export const InfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoApiAxiosParamCreator(configuration)
    return {
        /**
         *  Checks the health of the services.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheck(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheck(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.healthCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns information about the API.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary API Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async info(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.info(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InfoApi.info']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InfoApi - factory interface
 */
export const InfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoApiFp(configuration)
    return {
        /**
         *  Checks the health of the services.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Health Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: RawAxiosRequestConfig): AxiosPromise<Status> {
            return localVarFp.healthCheck(options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns information about the API.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary API Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info(options?: RawAxiosRequestConfig): AxiosPromise<APIInfo> {
            return localVarFp.info(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoApi - object-oriented interface
 */
export class InfoApi extends BaseAPI {
    /**
     *  Checks the health of the services.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public healthCheck(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).healthCheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns information about the API.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary API Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public info(options?: RawAxiosRequestConfig) {
        return InfoApiFp(this.configuration).info(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InternalApi - axios parameter creator
 */
export const InternalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  You can use this endpoint to help us collecting data.  The endpoint accepts a list of MatchSalts objects, which contain the following fields:  - `match_id`: The match ID - `cluster_id`: The cluster ID - `metadata_salt`: The metadata salt - `replay_salt`: The replay salt - `username`: The username of the person who submitted the match  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Match Salts Ingest
         * @param {Array<ClickhouseSalts>} clickhouseSalts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestSalts: async (clickhouseSalts: Array<ClickhouseSalts>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clickhouseSalts' is not null or undefined
            assertParamExists('ingestSalts', 'clickhouseSalts', clickhouseSalts)
            const localVarPath = `/v1/matches/salts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clickhouseSalts, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InternalApi - functional programming interface
 */
export const InternalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InternalApiAxiosParamCreator(configuration)
    return {
        /**
         *  You can use this endpoint to help us collecting data.  The endpoint accepts a list of MatchSalts objects, which contain the following fields:  - `match_id`: The match ID - `cluster_id`: The cluster ID - `metadata_salt`: The metadata salt - `replay_salt`: The replay salt - `username`: The username of the person who submitted the match  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Match Salts Ingest
         * @param {Array<ClickhouseSalts>} clickhouseSalts 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestSalts(clickhouseSalts: Array<ClickhouseSalts>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestSalts(clickhouseSalts, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InternalApi.ingestSalts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InternalApi - factory interface
 */
export const InternalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InternalApiFp(configuration)
    return {
        /**
         *  You can use this endpoint to help us collecting data.  The endpoint accepts a list of MatchSalts objects, which contain the following fields:  - `match_id`: The match ID - `cluster_id`: The cluster ID - `metadata_salt`: The metadata salt - `replay_salt`: The replay salt - `username`: The username of the person who submitted the match  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Match Salts Ingest
         * @param {InternalApiIngestSaltsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestSalts(requestParameters: InternalApiIngestSaltsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.ingestSalts(requestParameters.clickhouseSalts, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ingestSalts operation in InternalApi.
 */
export interface InternalApiIngestSaltsRequest {
    readonly clickhouseSalts: Array<ClickhouseSalts>
}

/**
 * InternalApi - object-oriented interface
 */
export class InternalApi extends BaseAPI {
    /**
     *  You can use this endpoint to help us collecting data.  The endpoint accepts a list of MatchSalts objects, which contain the following fields:  - `match_id`: The match ID - `cluster_id`: The cluster ID - `metadata_salt`: The metadata salt - `replay_salt`: The replay salt - `username`: The username of the person who submitted the match  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Match Salts Ingest
     * @param {InternalApiIngestSaltsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ingestSalts(requestParameters: InternalApiIngestSaltsRequest, options?: RawAxiosRequestConfig) {
        return InternalApiFp(this.configuration).ingestSalts(requestParameters.clickhouseSalts, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LeaderboardApi - axios parameter creator
 */
export const LeaderboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns the leaderboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard
         * @param {LeaderboardRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboard: async (region: LeaderboardRegionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('leaderboard', 'region', region)
            const localVarPath = `/v1/leaderboard/{region}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the leaderboard for a specific hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard
         * @param {LeaderboardHeroRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardHero: async (region: LeaderboardHeroRegionEnum, heroId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('leaderboardHero', 'region', region)
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('leaderboardHero', 'heroId', heroId)
            const localVarPath = `/v1/leaderboard/{region}/{hero_id}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"hero_id"}}`, encodeURIComponent(String(heroId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the leaderboard for a specific hero, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard as Protobuf
         * @param {LeaderboardHeroRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardHeroRaw: async (region: LeaderboardHeroRawRegionEnum, heroId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('leaderboardHeroRaw', 'region', region)
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('leaderboardHeroRaw', 'heroId', heroId)
            const localVarPath = `/v1/leaderboard/{region}/{hero_id}/raw`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"hero_id"}}`, encodeURIComponent(String(heroId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the leaderboard, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard as Protobuf
         * @param {LeaderboardRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardRaw: async (region: LeaderboardRawRegionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('leaderboardRaw', 'region', region)
            const localVarPath = `/v1/leaderboard/{region}/raw`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeaderboardApi - functional programming interface
 */
export const LeaderboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeaderboardApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns the leaderboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard
         * @param {LeaderboardRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboard(region: LeaderboardRegionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Leaderboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboard(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.leaderboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the leaderboard for a specific hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard
         * @param {LeaderboardHeroRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardHero(region: LeaderboardHeroRegionEnum, heroId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Leaderboard>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardHero(region, heroId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.leaderboardHero']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the leaderboard for a specific hero, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard as Protobuf
         * @param {LeaderboardHeroRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {number} heroId The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardHeroRaw(region: LeaderboardHeroRawRegionEnum, heroId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardHeroRaw(region, heroId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.leaderboardHeroRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the leaderboard, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard as Protobuf
         * @param {LeaderboardRawRegionEnum} region The region to fetch the leaderboard for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leaderboardRaw(region: LeaderboardRawRegionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leaderboardRaw(region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeaderboardApi.leaderboardRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeaderboardApi - factory interface
 */
export const LeaderboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeaderboardApiFp(configuration)
    return {
        /**
         *  Returns the leaderboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard
         * @param {LeaderboardApiLeaderboardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboard(requestParameters: LeaderboardApiLeaderboardRequest, options?: RawAxiosRequestConfig): AxiosPromise<Leaderboard> {
            return localVarFp.leaderboard(requestParameters.region, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the leaderboard for a specific hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard
         * @param {LeaderboardApiLeaderboardHeroRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardHero(requestParameters: LeaderboardApiLeaderboardHeroRequest, options?: RawAxiosRequestConfig): AxiosPromise<Leaderboard> {
            return localVarFp.leaderboardHero(requestParameters.region, requestParameters.heroId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the leaderboard for a specific hero, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Leaderboard as Protobuf
         * @param {LeaderboardApiLeaderboardHeroRawRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardHeroRaw(requestParameters: LeaderboardApiLeaderboardHeroRawRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.leaderboardHeroRaw(requestParameters.region, requestParameters.heroId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the leaderboard, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Leaderboard as Protobuf
         * @param {LeaderboardApiLeaderboardRawRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaderboardRaw(requestParameters: LeaderboardApiLeaderboardRawRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.leaderboardRaw(requestParameters.region, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for leaderboard operation in LeaderboardApi.
 */
export interface LeaderboardApiLeaderboardRequest {
    /**
     * The region to fetch the leaderboard for.
     */
    readonly region: LeaderboardRegionEnum
}

/**
 * Request parameters for leaderboardHero operation in LeaderboardApi.
 */
export interface LeaderboardApiLeaderboardHeroRequest {
    /**
     * The region to fetch the leaderboard for.
     */
    readonly region: LeaderboardHeroRegionEnum

    /**
     * The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId: number
}

/**
 * Request parameters for leaderboardHeroRaw operation in LeaderboardApi.
 */
export interface LeaderboardApiLeaderboardHeroRawRequest {
    /**
     * The region to fetch the leaderboard for.
     */
    readonly region: LeaderboardHeroRawRegionEnum

    /**
     * The hero ID to fetch the leaderboard for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId: number
}

/**
 * Request parameters for leaderboardRaw operation in LeaderboardApi.
 */
export interface LeaderboardApiLeaderboardRawRequest {
    /**
     * The region to fetch the leaderboard for.
     */
    readonly region: LeaderboardRawRegionEnum
}

/**
 * LeaderboardApi - object-oriented interface
 */
export class LeaderboardApi extends BaseAPI {
    /**
     *  Returns the leaderboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Leaderboard
     * @param {LeaderboardApiLeaderboardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaderboard(requestParameters: LeaderboardApiLeaderboardRequest, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).leaderboard(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the leaderboard for a specific hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Leaderboard
     * @param {LeaderboardApiLeaderboardHeroRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaderboardHero(requestParameters: LeaderboardApiLeaderboardHeroRequest, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).leaderboardHero(requestParameters.region, requestParameters.heroId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the leaderboard for a specific hero, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Leaderboard as Protobuf
     * @param {LeaderboardApiLeaderboardHeroRawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaderboardHeroRaw(requestParameters: LeaderboardApiLeaderboardHeroRawRequest, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).leaderboardHeroRaw(requestParameters.region, requestParameters.heroId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the leaderboard, serialized as protobuf message.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetLeaderboardResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Leaderboard as Protobuf
     * @param {LeaderboardApiLeaderboardRawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public leaderboardRaw(requestParameters: LeaderboardApiLeaderboardRawRequest, options?: RawAxiosRequestConfig) {
        return LeaderboardApiFp(this.configuration).leaderboardRaw(requestParameters.region, options).then((request) => request(this.axios, this.basePath));
    }
}

export const LeaderboardRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type LeaderboardRegionEnum = typeof LeaderboardRegionEnum[keyof typeof LeaderboardRegionEnum];
export const LeaderboardHeroRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type LeaderboardHeroRegionEnum = typeof LeaderboardHeroRegionEnum[keyof typeof LeaderboardHeroRegionEnum];
export const LeaderboardHeroRawRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type LeaderboardHeroRawRegionEnum = typeof LeaderboardHeroRawRegionEnum[keyof typeof LeaderboardHeroRawRegionEnum];
export const LeaderboardRawRegionEnum = {
    Europe: 'Europe',
    Asia: 'Asia',
    NAmerica: 'NAmerica',
    SAmerica: 'SAmerica',
    Oceania: 'Oceania'
} as const;
export type LeaderboardRawRegionEnum = typeof LeaderboardRawRegionEnum[keyof typeof LeaderboardRawRegionEnum];


/**
 * MMRApi - axios parameter creator
 */
export const MMRApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Player Hero MMR Distribution 
         * @summary Hero MMR Distribution
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmr: async (heroId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, minMatchId?: number | null, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('heroMmr', 'heroId', heroId)
            const localVarPath = `/v1/players/mmr/distribution/{hero_id}`
                .replace(`{${"hero_id"}}`, encodeURIComponent(String(heroId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (isHighSkillRangeParties !== undefined) {
                localVarQueryParameter['is_high_skill_range_parties'] = isHighSkillRangeParties;
            }

            if (isLowPriPool !== undefined) {
                localVarQueryParameter['is_low_pri_pool'] = isLowPriPool;
            }

            if (isNewPlayerPool !== undefined) {
                localVarQueryParameter['is_new_player_pool'] = isNewPlayerPool;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Player Hero MMR History
         * @summary Hero MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmrHistory: async (accountId: number, heroId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('heroMmrHistory', 'accountId', accountId)
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('heroMmrHistory', 'heroId', heroId)
            const localVarPath = `/v1/players/{account_id}/mmr-history/{hero_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"hero_id"}}`, encodeURIComponent(String(heroId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Batch Player Hero MMR  Filters for the last 90 days if no `max_match_id` is provided. 
         * @summary Batch Hero MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmr_1: async (accountIds: Array<number>, heroId: number, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIds' is not null or undefined
            assertParamExists('heroMmr_1', 'accountIds', accountIds)
            // verify required parameter 'heroId' is not null or undefined
            assertParamExists('heroMmr_1', 'heroId', heroId)
            const localVarPath = `/v1/players/mmr/{hero_id}`
                .replace(`{${"hero_id"}}`, encodeURIComponent(String(heroId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Batch Player MMR  Filters for the last 90 days if no `max_match_id` is provided. 
         * @summary Batch MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmr: async (accountIds: Array<number>, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIds' is not null or undefined
            assertParamExists('mmr', 'accountIds', accountIds)
            const localVarPath = `/v1/players/mmr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Player MMR History
         * @summary MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmrHistory: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('mmrHistory', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/mmr-history`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Player MMR Distribution 
         * @summary MMR Distribution
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmr_2: async (minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, minMatchId?: number | null, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/players/mmr/distribution`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (isHighSkillRangeParties !== undefined) {
                localVarQueryParameter['is_high_skill_range_parties'] = isHighSkillRangeParties;
            }

            if (isLowPriPool !== undefined) {
                localVarQueryParameter['is_low_pri_pool'] = isLowPriPool;
            }

            if (isNewPlayerPool !== undefined) {
                localVarQueryParameter['is_new_player_pool'] = isNewPlayerPool;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MMRApi - functional programming interface
 */
export const MMRApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MMRApiAxiosParamCreator(configuration)
    return {
        /**
         *  Player Hero MMR Distribution 
         * @summary Hero MMR Distribution
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroMmr(heroId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DistributionEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroMmr(heroId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.heroMmr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Player Hero MMR History
         * @summary Hero MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroMmrHistory(accountId: number, heroId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MMRHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroMmrHistory(accountId, heroId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.heroMmrHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Batch Player Hero MMR  Filters for the last 90 days if no `max_match_id` is provided. 
         * @summary Batch Hero MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number} heroId The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async heroMmr_1(accountIds: Array<number>, heroId: number, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MMRHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.heroMmr_1(accountIds, heroId, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.heroMmr_1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Batch Player MMR  Filters for the last 90 days if no `max_match_id` is provided. 
         * @summary Batch MMR
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mmr(accountIds: Array<number>, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MMRHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mmr(accountIds, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.mmr']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Player MMR History
         * @summary MMR History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mmrHistory(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MMRHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mmrHistory(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.mmrHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Player MMR Distribution 
         * @summary MMR Distribution
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mmr_2(minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DistributionEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mmr_2(minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, minMatchId, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MMRApi.mmr_2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MMRApi - factory interface
 */
export const MMRApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MMRApiFp(configuration)
    return {
        /**
         *  Player Hero MMR Distribution 
         * @summary Hero MMR Distribution
         * @param {MMRApiHeroMmrRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmr(requestParameters: MMRApiHeroMmrRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DistributionEntry>> {
            return localVarFp.heroMmr(requestParameters.heroId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.isHighSkillRangeParties, requestParameters.isLowPriPool, requestParameters.isNewPlayerPool, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Player Hero MMR History
         * @summary Hero MMR History
         * @param {MMRApiHeroMmrHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmrHistory(requestParameters: MMRApiHeroMmrHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MMRHistory>> {
            return localVarFp.heroMmrHistory(requestParameters.accountId, requestParameters.heroId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Batch Player Hero MMR  Filters for the last 90 days if no `max_match_id` is provided. 
         * @summary Batch Hero MMR
         * @param {MMRApiHeroMmr0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        heroMmr_1(requestParameters: MMRApiHeroMmr0Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<MMRHistory>> {
            return localVarFp.heroMmr_1(requestParameters.accountIds, requestParameters.heroId, requestParameters.maxMatchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Batch Player MMR  Filters for the last 90 days if no `max_match_id` is provided. 
         * @summary Batch MMR
         * @param {MMRApiMmrRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmr(requestParameters: MMRApiMmrRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MMRHistory>> {
            return localVarFp.mmr(requestParameters.accountIds, requestParameters.maxMatchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Player MMR History
         * @summary MMR History
         * @param {MMRApiMmrHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmrHistory(requestParameters: MMRApiMmrHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MMRHistory>> {
            return localVarFp.mmrHistory(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Player MMR Distribution 
         * @summary MMR Distribution
         * @param {MMRApiMmr0Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mmr_2(requestParameters: MMRApiMmr0Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<DistributionEntry>> {
            return localVarFp.mmr_2(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.isHighSkillRangeParties, requestParameters.isLowPriPool, requestParameters.isNewPlayerPool, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for heroMmr operation in MMRApi.
 */
export interface MMRApiHeroMmrRequest {
    /**
     * The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId: number

    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter matches based on whether they are in the high skill range.
     */
    readonly isHighSkillRangeParties?: boolean | null

    /**
     * Filter matches based on whether they are in the low priority pool.
     */
    readonly isLowPriPool?: boolean | null

    /**
     * Filter matches based on whether they are in the new player pool.
     */
    readonly isNewPlayerPool?: boolean | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null
}

/**
 * Request parameters for heroMmrHistory operation in MMRApi.
 */
export interface MMRApiHeroMmrHistoryRequest {
    /**
     * The players &#x60;SteamID3&#x60;
     */
    readonly accountId: number

    /**
     * The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId: number
}

/**
 * Request parameters for heroMmr_1 operation in MMRApi.
 */
export interface MMRApiHeroMmr0Request {
    /**
     * Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     */
    readonly accountIds: Array<number>

    /**
     * The hero ID to fetch the MMR history for. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroId: number

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null
}

/**
 * Request parameters for mmr operation in MMRApi.
 */
export interface MMRApiMmrRequest {
    /**
     * Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     */
    readonly accountIds: Array<number>

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null
}

/**
 * Request parameters for mmrHistory operation in MMRApi.
 */
export interface MMRApiMmrHistoryRequest {
    /**
     * The players &#x60;SteamID3&#x60;
     */
    readonly accountId: number
}

/**
 * Request parameters for mmr_2 operation in MMRApi.
 */
export interface MMRApiMmr0Request {
    /**
     * Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter matches based on whether they are in the high skill range.
     */
    readonly isHighSkillRangeParties?: boolean | null

    /**
     * Filter matches based on whether they are in the low priority pool.
     */
    readonly isLowPriPool?: boolean | null

    /**
     * Filter matches based on whether they are in the new player pool.
     */
    readonly isNewPlayerPool?: boolean | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null
}

/**
 * MMRApi - object-oriented interface
 */
export class MMRApi extends BaseAPI {
    /**
     *  Player Hero MMR Distribution 
     * @summary Hero MMR Distribution
     * @param {MMRApiHeroMmrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public heroMmr(requestParameters: MMRApiHeroMmrRequest, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).heroMmr(requestParameters.heroId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.isHighSkillRangeParties, requestParameters.isLowPriPool, requestParameters.isNewPlayerPool, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Player Hero MMR History
     * @summary Hero MMR History
     * @param {MMRApiHeroMmrHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public heroMmrHistory(requestParameters: MMRApiHeroMmrHistoryRequest, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).heroMmrHistory(requestParameters.accountId, requestParameters.heroId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Batch Player Hero MMR  Filters for the last 90 days if no `max_match_id` is provided. 
     * @summary Batch Hero MMR
     * @param {MMRApiHeroMmr0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public heroMmr_1(requestParameters: MMRApiHeroMmr0Request, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).heroMmr_1(requestParameters.accountIds, requestParameters.heroId, requestParameters.maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Batch Player MMR  Filters for the last 90 days if no `max_match_id` is provided. 
     * @summary Batch MMR
     * @param {MMRApiMmrRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mmr(requestParameters: MMRApiMmrRequest, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).mmr(requestParameters.accountIds, requestParameters.maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Player MMR History
     * @summary MMR History
     * @param {MMRApiMmrHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mmrHistory(requestParameters: MMRApiMmrHistoryRequest, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).mmrHistory(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Player MMR Distribution 
     * @summary MMR Distribution
     * @param {MMRApiMmr0Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mmr_2(requestParameters: MMRApiMmr0Request = {}, options?: RawAxiosRequestConfig) {
        return MMRApiFp(this.configuration).mmr_2(requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.isHighSkillRangeParties, requestParameters.isLowPriPool, requestParameters.isNewPlayerPool, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MatchesApi - axios parameter creator
 */
export const MatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active
         * @param {number | null} [accountId] The account ID to filter active matches by (&#x60;SteamID3&#x60;)
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeMatches: async (accountId?: number | null, accountIds?: Array<number> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active as Protobuf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeMatchesRaw: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/active/raw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
         * @summary Bulk Metadata
         * @param {boolean} [includeInfo] Include match info in the response.
         * @param {boolean} [includeObjectives] Include objectives in the response.
         * @param {boolean} [includeMidBoss] Include midboss in the response.
         * @param {boolean} [includePlayerInfo] Include player info in the response.
         * @param {boolean} [includePlayerItems] Include player items in the response.
         * @param {boolean} [includePlayerStats] Include player stats in the response.
         * @param {boolean} [includePlayerDeathDetails] Include player death details in the response.
         * @param {Array<number> | null} [matchIds] Comma separated list of match ids, limited by &#x60;limit&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {Array<number> | null} [accountIds] Filter matches by account IDs of players that participated in the match.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {BulkMetadataOrderByEnum} [orderBy] The field to order the results by.
         * @param {BulkMetadataOrderDirectionEnum} [orderDirection] The direction to order the results by.
         * @param {number} [limit] The maximum number of matches to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkMetadata: async (includeInfo?: boolean, includeObjectives?: boolean, includeMidBoss?: boolean, includePlayerInfo?: boolean, includePlayerItems?: boolean, includePlayerStats?: boolean, includePlayerDeathDetails?: boolean, matchIds?: Array<number> | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, accountIds?: Array<number> | null, heroIds?: string | null, orderBy?: BulkMetadataOrderByEnum, orderDirection?: BulkMetadataOrderDirectionEnum, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeInfo !== undefined) {
                localVarQueryParameter['include_info'] = includeInfo;
            }

            if (includeObjectives !== undefined) {
                localVarQueryParameter['include_objectives'] = includeObjectives;
            }

            if (includeMidBoss !== undefined) {
                localVarQueryParameter['include_mid_boss'] = includeMidBoss;
            }

            if (includePlayerInfo !== undefined) {
                localVarQueryParameter['include_player_info'] = includePlayerInfo;
            }

            if (includePlayerItems !== undefined) {
                localVarQueryParameter['include_player_items'] = includePlayerItems;
            }

            if (includePlayerStats !== undefined) {
                localVarQueryParameter['include_player_stats'] = includePlayerStats;
            }

            if (includePlayerDeathDetails !== undefined) {
                localVarQueryParameter['include_player_death_details'] = includePlayerDeathDetails;
            }

            if (matchIds) {
                localVarQueryParameter['match_ids'] = matchIds;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (isHighSkillRangeParties !== undefined) {
                localVarQueryParameter['is_high_skill_range_parties'] = isHighSkillRangeParties;
            }

            if (isLowPriPool !== undefined) {
                localVarQueryParameter['is_low_pri_pool'] = isLowPriPool;
            }

            if (isNewPlayerPool !== undefined) {
                localVarQueryParameter['is_new_player_pool'] = isNewPlayerPool;
            }

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }

            if (heroIds !== undefined) {
                localVarQueryParameter['hero_ids'] = heroIds;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata
         * @param {number} matchId The match ID
         * @param {boolean | null} [isCustom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadata: async (matchId: number, isCustom?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('metadata', 'matchId', matchId)
            const localVarPath = `/v1/matches/{match_id}/metadata`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isCustom !== undefined) {
                localVarQueryParameter['is_custom'] = isCustom;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata as Protobuf
         * @param {number} matchId The match ID
         * @param {boolean | null} [isCustom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataRaw: async (matchId: number, isCustom?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('metadataRaw', 'matchId', matchId)
            const localVarPath = `/v1/matches/{match_id}/metadata/raw`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (isCustom !== undefined) {
                localVarQueryParameter['is_custom'] = isCustom;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Recently Fetched
         * @param {boolean | null} [playerIngestedOnly] If true, only return matches that have been ingested by players.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentlyFetched: async (playerIngestedOnly?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/matches/recently-fetched`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (playerIngestedOnly !== undefined) {
                localVarQueryParameter['player_ingested_only'] = playerIngestedOnly;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
         * @summary Salts
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salts: async (matchId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('salts', 'matchId', matchId)
            const localVarPath = `/v1/matches/{match_id}/salts`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
         * @summary Live Broadcast URL
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        url: async (matchId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'matchId' is not null or undefined
            assertParamExists('url', 'matchId', matchId)
            const localVarPath = `/v1/matches/{match_id}/live/url`
                .replace(`{${"match_id"}}`, encodeURIComponent(String(matchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MatchesApi - functional programming interface
 */
export const MatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MatchesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active
         * @param {number | null} [accountId] The account ID to filter active matches by (&#x60;SteamID3&#x60;)
         * @param {Array<number> | null} [accountIds] Comma separated list of account ids to include
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeMatches(accountId?: number | null, accountIds?: Array<number> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActiveMatch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeMatches(accountId, accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.activeMatches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active as Protobuf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeMatchesRaw(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeMatchesRaw(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.activeMatchesRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
         * @summary Bulk Metadata
         * @param {boolean} [includeInfo] Include match info in the response.
         * @param {boolean} [includeObjectives] Include objectives in the response.
         * @param {boolean} [includeMidBoss] Include midboss in the response.
         * @param {boolean} [includePlayerInfo] Include player info in the response.
         * @param {boolean} [includePlayerItems] Include player items in the response.
         * @param {boolean} [includePlayerStats] Include player stats in the response.
         * @param {boolean} [includePlayerDeathDetails] Include player death details in the response.
         * @param {Array<number> | null} [matchIds] Comma separated list of match ids, limited by &#x60;limit&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {boolean | null} [isHighSkillRangeParties] Filter matches based on whether they are in the high skill range.
         * @param {boolean | null} [isLowPriPool] Filter matches based on whether they are in the low priority pool.
         * @param {boolean | null} [isNewPlayerPool] Filter matches based on whether they are in the new player pool.
         * @param {Array<number> | null} [accountIds] Filter matches by account IDs of players that participated in the match.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {BulkMetadataOrderByEnum} [orderBy] The field to order the results by.
         * @param {BulkMetadataOrderDirectionEnum} [orderDirection] The direction to order the results by.
         * @param {number} [limit] The maximum number of matches to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkMetadata(includeInfo?: boolean, includeObjectives?: boolean, includeMidBoss?: boolean, includePlayerInfo?: boolean, includePlayerItems?: boolean, includePlayerStats?: boolean, includePlayerDeathDetails?: boolean, matchIds?: Array<number> | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, isHighSkillRangeParties?: boolean | null, isLowPriPool?: boolean | null, isNewPlayerPool?: boolean | null, accountIds?: Array<number> | null, heroIds?: string | null, orderBy?: BulkMetadataOrderByEnum, orderDirection?: BulkMetadataOrderDirectionEnum, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkMetadata(includeInfo, includeObjectives, includeMidBoss, includePlayerInfo, includePlayerItems, includePlayerStats, includePlayerDeathDetails, matchIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, isHighSkillRangeParties, isLowPriPool, isNewPlayerPool, accountIds, heroIds, orderBy, orderDirection, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.bulkMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata
         * @param {number} matchId The match ID
         * @param {boolean | null} [isCustom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metadata(matchId: number, isCustom?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metadata(matchId, isCustom, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.metadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata as Protobuf
         * @param {number} matchId The match ID
         * @param {boolean | null} [isCustom] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metadataRaw(matchId: number, isCustom?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metadataRaw(matchId, isCustom, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.metadataRaw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Recently Fetched
         * @param {boolean | null} [playerIngestedOnly] If true, only return matches that have been ingested by players.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentlyFetched(playerIngestedOnly?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClickhouseMatchInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentlyFetched(playerIngestedOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.recentlyFetched']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
         * @summary Salts
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async salts(matchId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchSaltsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.salts(matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.salts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
         * @summary Live Broadcast URL
         * @param {number} matchId The match ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async url(matchId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MatchSpectateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.url(matchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MatchesApi.url']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MatchesApi - factory interface
 */
export const MatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MatchesApiFp(configuration)
    return {
        /**
         *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active
         * @param {MatchesApiActiveMatchesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeMatches(requestParameters: MatchesApiActiveMatchesRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<ActiveMatch>> {
            return localVarFp.activeMatches(requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Active as Protobuf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeMatchesRaw(options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.activeMatchesRaw(options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
         * @summary Bulk Metadata
         * @param {MatchesApiBulkMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkMetadata(requestParameters: MatchesApiBulkMetadataRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.bulkMetadata(requestParameters.includeInfo, requestParameters.includeObjectives, requestParameters.includeMidBoss, requestParameters.includePlayerInfo, requestParameters.includePlayerItems, requestParameters.includePlayerStats, requestParameters.includePlayerDeathDetails, requestParameters.matchIds, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.isHighSkillRangeParties, requestParameters.isLowPriPool, requestParameters.isNewPlayerPool, requestParameters.accountIds, requestParameters.heroIds, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata
         * @param {MatchesApiMetadataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadata(requestParameters: MatchesApiMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metadata(requestParameters.matchId, requestParameters.isCustom, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
         * @summary Metadata as Protobuf
         * @param {MatchesApiMetadataRawRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metadataRaw(requestParameters: MatchesApiMetadataRawRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.metadataRaw(requestParameters.matchId, requestParameters.isCustom, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Recently Fetched
         * @param {MatchesApiRecentlyFetchedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentlyFetched(requestParameters: MatchesApiRecentlyFetchedRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<ClickhouseMatchInfo>> {
            return localVarFp.recentlyFetched(requestParameters.playerIngestedOnly, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
         * @summary Salts
         * @param {MatchesApiSaltsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        salts(requestParameters: MatchesApiSaltsRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchSaltsResponse> {
            return localVarFp.salts(requestParameters.matchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
         * @summary Live Broadcast URL
         * @param {MatchesApiUrlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        url(requestParameters: MatchesApiUrlRequest, options?: RawAxiosRequestConfig): AxiosPromise<MatchSpectateResponse> {
            return localVarFp.url(requestParameters.matchId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for activeMatches operation in MatchesApi.
 */
export interface MatchesApiActiveMatchesRequest {
    /**
     * The account ID to filter active matches by (&#x60;SteamID3&#x60;)
     */
    readonly accountId?: number | null

    /**
     * Comma separated list of account ids to include
     */
    readonly accountIds?: Array<number> | null
}

/**
 * Request parameters for bulkMetadata operation in MatchesApi.
 */
export interface MatchesApiBulkMetadataRequest {
    /**
     * Include match info in the response.
     */
    readonly includeInfo?: boolean

    /**
     * Include objectives in the response.
     */
    readonly includeObjectives?: boolean

    /**
     * Include midboss in the response.
     */
    readonly includeMidBoss?: boolean

    /**
     * Include player info in the response.
     */
    readonly includePlayerInfo?: boolean

    /**
     * Include player items in the response.
     */
    readonly includePlayerItems?: boolean

    /**
     * Include player stats in the response.
     */
    readonly includePlayerStats?: boolean

    /**
     * Include player death details in the response.
     */
    readonly includePlayerDeathDetails?: boolean

    /**
     * Comma separated list of match ids, limited by &#x60;limit&#x60;
     */
    readonly matchIds?: Array<number> | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * Filter matches based on whether they are in the high skill range.
     */
    readonly isHighSkillRangeParties?: boolean | null

    /**
     * Filter matches based on whether they are in the low priority pool.
     */
    readonly isLowPriPool?: boolean | null

    /**
     * Filter matches based on whether they are in the new player pool.
     */
    readonly isNewPlayerPool?: boolean | null

    /**
     * Filter matches by account IDs of players that participated in the match.
     */
    readonly accountIds?: Array<number> | null

    /**
     * Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroIds?: string | null

    /**
     * The field to order the results by.
     */
    readonly orderBy?: BulkMetadataOrderByEnum

    /**
     * The direction to order the results by.
     */
    readonly orderDirection?: BulkMetadataOrderDirectionEnum

    /**
     * The maximum number of matches to return.
     */
    readonly limit?: number
}

/**
 * Request parameters for metadata operation in MatchesApi.
 */
export interface MatchesApiMetadataRequest {
    /**
     * The match ID
     */
    readonly matchId: number

    readonly isCustom?: boolean | null
}

/**
 * Request parameters for metadataRaw operation in MatchesApi.
 */
export interface MatchesApiMetadataRawRequest {
    /**
     * The match ID
     */
    readonly matchId: number

    readonly isCustom?: boolean | null
}

/**
 * Request parameters for recentlyFetched operation in MatchesApi.
 */
export interface MatchesApiRecentlyFetchedRequest {
    /**
     * If true, only return matches that have been ingested by players.
     */
    readonly playerIngestedOnly?: boolean | null
}

/**
 * Request parameters for salts operation in MatchesApi.
 */
export interface MatchesApiSaltsRequest {
    /**
     * The match ID
     */
    readonly matchId: number
}

/**
 * Request parameters for url operation in MatchesApi.
 */
export interface MatchesApiUrlRequest {
    /**
     * The match ID
     */
    readonly matchId: number
}

/**
 * MatchesApi - object-oriented interface
 */
export class MatchesApi extends BaseAPI {
    /**
     *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Active
     * @param {MatchesApiActiveMatchesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public activeMatches(requestParameters: MatchesApiActiveMatchesRequest = {}, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).activeMatches(requestParameters.accountId, requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Active as Protobuf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public activeMatchesRaw(options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).activeMatchesRaw(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
     * @summary Bulk Metadata
     * @param {MatchesApiBulkMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bulkMetadata(requestParameters: MatchesApiBulkMetadataRequest = {}, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).bulkMetadata(requestParameters.includeInfo, requestParameters.includeObjectives, requestParameters.includeMidBoss, requestParameters.includePlayerInfo, requestParameters.includePlayerItems, requestParameters.includePlayerStats, requestParameters.includePlayerDeathDetails, requestParameters.matchIds, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.isHighSkillRangeParties, requestParameters.isLowPriPool, requestParameters.isNewPlayerPool, requestParameters.accountIds, requestParameters.heroIds, requestParameters.orderBy, requestParameters.orderDirection, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
     * @summary Metadata
     * @param {MatchesApiMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metadata(requestParameters: MatchesApiMetadataRequest, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).metadata(requestParameters.matchId, requestParameters.isCustom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
     * @summary Metadata as Protobuf
     * @param {MatchesApiMetadataRawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metadataRaw(requestParameters: MatchesApiMetadataRawRequest, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).metadataRaw(requestParameters.matchId, requestParameters.isCustom, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Recently Fetched
     * @param {MatchesApiRecentlyFetchedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public recentlyFetched(requestParameters: MatchesApiRecentlyFetchedRequest = {}, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).recentlyFetched(requestParameters.playerIngestedOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
     * @summary Salts
     * @param {MatchesApiSaltsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public salts(requestParameters: MatchesApiSaltsRequest, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).salts(requestParameters.matchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
     * @summary Live Broadcast URL
     * @param {MatchesApiUrlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public url(requestParameters: MatchesApiUrlRequest, options?: RawAxiosRequestConfig) {
        return MatchesApiFp(this.configuration).url(requestParameters.matchId, options).then((request) => request(this.axios, this.basePath));
    }
}

export const BulkMetadataOrderByEnum = {
    MatchId: 'match_id',
    StartTime: 'start_time'
} as const;
export type BulkMetadataOrderByEnum = typeof BulkMetadataOrderByEnum[keyof typeof BulkMetadataOrderByEnum];
export const BulkMetadataOrderDirectionEnum = {
    Desc: 'desc',
    Asc: 'asc'
} as const;
export type BulkMetadataOrderDirectionEnum = typeof BulkMetadataOrderDirectionEnum[keyof typeof BulkMetadataOrderDirectionEnum];


/**
 * PatchesApi - axios parameter creator
 */
export const PatchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a list of dates where Deadlock\'s \"big\" patch days were, usually bi-weekly. The exact date is the time when the announcement forum post was published.  This list is manually maintained, and so new patch dates may be delayed by a few hours.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Big Days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bigPatchDays: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/patches/big-days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the parsed result of the RSS Feed from the official Forum.  RSS-Feed: https://forums.playdeadlock.com/forums/changelog.10/index.rss  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Notes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feed: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/patches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PatchesApi - functional programming interface
 */
export const PatchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PatchesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a list of dates where Deadlock\'s \"big\" patch days were, usually bi-weekly. The exact date is the time when the announcement forum post was published.  This list is manually maintained, and so new patch dates may be delayed by a few hours.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Big Days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bigPatchDays(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bigPatchDays(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatchesApi.bigPatchDays']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the parsed result of the RSS Feed from the official Forum.  RSS-Feed: https://forums.playdeadlock.com/forums/changelog.10/index.rss  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Notes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feed(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Patch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feed(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PatchesApi.feed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PatchesApi - factory interface
 */
export const PatchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PatchesApiFp(configuration)
    return {
        /**
         *  Returns a list of dates where Deadlock\'s \"big\" patch days were, usually bi-weekly. The exact date is the time when the announcement forum post was published.  This list is manually maintained, and so new patch dates may be delayed by a few hours.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Big Days
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bigPatchDays(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.bigPatchDays(options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the parsed result of the RSS Feed from the official Forum.  RSS-Feed: https://forums.playdeadlock.com/forums/changelog.10/index.rss  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Notes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feed(options?: RawAxiosRequestConfig): AxiosPromise<Array<Patch>> {
            return localVarFp.feed(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PatchesApi - object-oriented interface
 */
export class PatchesApi extends BaseAPI {
    /**
     *  Returns a list of dates where Deadlock\'s \"big\" patch days were, usually bi-weekly. The exact date is the time when the announcement forum post was published.  This list is manually maintained, and so new patch dates may be delayed by a few hours.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Big Days
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public bigPatchDays(options?: RawAxiosRequestConfig) {
        return PatchesApiFp(this.configuration).bigPatchDays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the parsed result of the RSS Feed from the official Forum.  RSS-Feed: https://forums.playdeadlock.com/forums/changelog.10/index.rss  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Notes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public feed(options?: RawAxiosRequestConfig) {
        return PatchesApiFp(this.configuration).feed(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlayersApi - axios parameter creator
 */
export const PlayersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
         * @summary Card
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        card: async (accountId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('card', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/card`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Enemy Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enemyStats: async (accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('enemyStats', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/enemy-stats`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (minMatchesPlayed !== undefined) {
                localVarQueryParameter['min_matches_played'] = minMatchesPlayed;
            }

            if (maxMatchesPlayed !== undefined) {
                localVarQueryParameter['max_matches_played'] = maxMatchesPlayed;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
         * @summary Match History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {boolean} [forceRefetch] Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit.
         * @param {boolean} [onlyStoredHistory] Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchHistory: async (accountId: number, forceRefetch?: boolean, onlyStoredHistory?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('matchHistory', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/match-history`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (forceRefetch !== undefined) {
                localVarQueryParameter['force_refetch'] = forceRefetch;
            }

            if (onlyStoredHistory !== undefined) {
                localVarQueryParameter['only_stored_history'] = onlyStoredHistory;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Mate Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {boolean} [sameParty] Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mateStats: async (accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, sameParty?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('mateStats', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/mate-stats`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }

            if (minMatchesPlayed !== undefined) {
                localVarQueryParameter['min_matches_played'] = minMatchesPlayed;
            }

            if (maxMatchesPlayed !== undefined) {
                localVarQueryParameter['max_matches_played'] = maxMatchesPlayed;
            }

            if (sameParty !== undefined) {
                localVarQueryParameter['same_party'] = sameParty;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Party Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partyStats: async (accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('partyStats', 'accountId', accountId)
            const localVarPath = `/v1/players/{account_id}/party-stats`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerHeroStats: async (accountIds: Array<number>, heroIds?: string | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIds' is not null or undefined
            assertParamExists('playerHeroStats', 'accountIds', accountIds)
            const localVarPath = `/v1/players/hero-stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }

            if (heroIds !== undefined) {
                localVarQueryParameter['hero_ids'] = heroIds;
            }

            if (minUnixTimestamp !== undefined) {
                localVarQueryParameter['min_unix_timestamp'] = minUnixTimestamp;
            }

            if (maxUnixTimestamp !== undefined) {
                localVarQueryParameter['max_unix_timestamp'] = maxUnixTimestamp;
            }

            if (minDurationS !== undefined) {
                localVarQueryParameter['min_duration_s'] = minDurationS;
            }

            if (maxDurationS !== undefined) {
                localVarQueryParameter['max_duration_s'] = maxDurationS;
            }

            if (minNetworth !== undefined) {
                localVarQueryParameter['min_networth'] = minNetworth;
            }

            if (maxNetworth !== undefined) {
                localVarQueryParameter['max_networth'] = maxNetworth;
            }

            if (minAverageBadge !== undefined) {
                localVarQueryParameter['min_average_badge'] = minAverageBadge;
            }

            if (maxAverageBadge !== undefined) {
                localVarQueryParameter['max_average_badge'] = maxAverageBadge;
            }

            if (minMatchId !== undefined) {
                localVarQueryParameter['min_match_id'] = minMatchId;
            }

            if (maxMatchId !== undefined) {
                localVarQueryParameter['max_match_id'] = maxMatchId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Batch Steam Profile
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steam: async (accountIds: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountIds' is not null or undefined
            assertParamExists('steam', 'accountIds', accountIds)
            const localVarPath = `/v1/players/steam`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountIds) {
                localVarQueryParameter['account_ids'] = accountIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Steam Profile Search
         * @param {string} searchQuery Search query for Steam profiles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steamSearch: async (searchQuery: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchQuery' is not null or undefined
            assertParamExists('steamSearch', 'searchQuery', searchQuery)
            const localVarPath = `/v1/players/steam-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayersApi - functional programming interface
 */
export const PlayersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayersApiAxiosParamCreator(configuration)
    return {
        /**
         *  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
         * @summary Card
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async card(accountId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerCard>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.card(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.card']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Enemy Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enemyStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnemyStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enemyStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.enemyStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
         * @summary Match History
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {boolean} [forceRefetch] Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit.
         * @param {boolean} [onlyStoredHistory] Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async matchHistory(accountId: number, forceRefetch?: boolean, onlyStoredHistory?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlayerMatchHistoryEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.matchHistory(accountId, forceRefetch, onlyStoredHistory, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.matchHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Mate Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {number | null} [minMatchesPlayed] Filter based on the number of matches played.
         * @param {number | null} [maxMatchesPlayed] Filter based on the number of matches played.
         * @param {boolean} [sameParty] Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mateStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minMatchId?: number | null, maxMatchId?: number | null, minMatchesPlayed?: number | null, maxMatchesPlayed?: number | null, sameParty?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MateStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mateStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, minMatchesPlayed, maxMatchesPlayed, sameParty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.mateStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Party Stats
         * @param {number} accountId The players &#x60;SteamID3&#x60;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partyStats(accountId: number, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PartyStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partyStats(accountId, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minMatchId, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.partyStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {string | null} [heroIds] Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
         * @param {number | null} [minUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [maxUnixTimestamp] Filter matches based on their start time (Unix timestamp).
         * @param {number | null} [minDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [maxDurationS] Filter matches based on their duration in seconds (up to 7000s).
         * @param {number | null} [minNetworth] Filter players based on their net worth.
         * @param {number | null} [maxNetworth] Filter players based on their net worth.
         * @param {number | null} [minAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [maxAverageBadge] Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
         * @param {number | null} [minMatchId] Filter matches based on their ID.
         * @param {number | null} [maxMatchId] Filter matches based on their ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerHeroStats(accountIds: Array<number>, heroIds?: string | null, minUnixTimestamp?: number | null, maxUnixTimestamp?: number | null, minDurationS?: number | null, maxDurationS?: number | null, minNetworth?: number | null, maxNetworth?: number | null, minAverageBadge?: number | null, maxAverageBadge?: number | null, minMatchId?: number | null, maxMatchId?: number | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HeroStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerHeroStats(accountIds, heroIds, minUnixTimestamp, maxUnixTimestamp, minDurationS, maxDurationS, minNetworth, maxNetworth, minAverageBadge, maxAverageBadge, minMatchId, maxMatchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.playerHeroStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Batch Steam Profile
         * @param {Array<number>} accountIds Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async steam(accountIds: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SteamProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.steam(accountIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.steam']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Steam Profile Search
         * @param {string} searchQuery Search query for Steam profiles.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async steamSearch(searchQuery: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SteamProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.steamSearch(searchQuery, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayersApi.steamSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlayersApi - factory interface
 */
export const PlayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayersApiFp(configuration)
    return {
        /**
         *  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
         * @summary Card
         * @param {PlayersApiCardRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        card(requestParameters: PlayersApiCardRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PlayerCard>> {
            return localVarFp.card(requestParameters.accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Enemy Stats
         * @param {PlayersApiEnemyStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enemyStats(requestParameters: PlayersApiEnemyStatsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<EnemyStats>> {
            return localVarFp.enemyStats(requestParameters.accountId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.minMatchesPlayed, requestParameters.maxMatchesPlayed, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
         * @summary Match History
         * @param {PlayersApiMatchHistoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        matchHistory(requestParameters: PlayersApiMatchHistoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PlayerMatchHistoryEntry>> {
            return localVarFp.matchHistory(requestParameters.accountId, requestParameters.forceRefetch, requestParameters.onlyStoredHistory, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Mate Stats
         * @param {PlayersApiMateStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mateStats(requestParameters: PlayersApiMateStatsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MateStats>> {
            return localVarFp.mateStats(requestParameters.accountId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.minMatchesPlayed, requestParameters.maxMatchesPlayed, requestParameters.sameParty, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Party Stats
         * @param {PlayersApiPartyStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partyStats(requestParameters: PlayersApiPartyStatsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<PartyStats>> {
            return localVarFp.partyStats(requestParameters.accountId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Hero Stats
         * @param {PlayersApiPlayerHeroStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerHeroStats(requestParameters: PlayersApiPlayerHeroStatsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<HeroStats>> {
            return localVarFp.playerHeroStats(requestParameters.accountIds, requestParameters.heroIds, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Batch Steam Profile
         * @param {PlayersApiSteamRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steam(requestParameters: PlayersApiSteamRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SteamProfile>> {
            return localVarFp.steam(requestParameters.accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Steam Profile Search
         * @param {PlayersApiSteamSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        steamSearch(requestParameters: PlayersApiSteamSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<SteamProfile>> {
            return localVarFp.steamSearch(requestParameters.searchQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for card operation in PlayersApi.
 */
export interface PlayersApiCardRequest {
    /**
     * The players &#x60;SteamID3&#x60;
     */
    readonly accountId: number
}

/**
 * Request parameters for enemyStats operation in PlayersApi.
 */
export interface PlayersApiEnemyStatsRequest {
    /**
     * The players &#x60;SteamID3&#x60;
     */
    readonly accountId: number

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * Filter based on the number of matches played.
     */
    readonly minMatchesPlayed?: number | null

    /**
     * Filter based on the number of matches played.
     */
    readonly maxMatchesPlayed?: number | null
}

/**
 * Request parameters for matchHistory operation in PlayersApi.
 */
export interface PlayersApiMatchHistoryRequest {
    /**
     * The players &#x60;SteamID3&#x60;
     */
    readonly accountId: number

    /**
     * Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit.
     */
    readonly forceRefetch?: boolean

    /**
     * Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;.
     */
    readonly onlyStoredHistory?: boolean
}

/**
 * Request parameters for mateStats operation in PlayersApi.
 */
export interface PlayersApiMateStatsRequest {
    /**
     * The players &#x60;SteamID3&#x60;
     */
    readonly accountId: number

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null

    /**
     * Filter based on the number of matches played.
     */
    readonly minMatchesPlayed?: number | null

    /**
     * Filter based on the number of matches played.
     */
    readonly maxMatchesPlayed?: number | null

    /**
     * Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches.
     */
    readonly sameParty?: boolean
}

/**
 * Request parameters for partyStats operation in PlayersApi.
 */
export interface PlayersApiPartyStatsRequest {
    /**
     * The players &#x60;SteamID3&#x60;
     */
    readonly accountId: number

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null
}

/**
 * Request parameters for playerHeroStats operation in PlayersApi.
 */
export interface PlayersApiPlayerHeroStatsRequest {
    /**
     * Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     */
    readonly accountIds: Array<number>

    /**
     * Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
     */
    readonly heroIds?: string | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly minUnixTimestamp?: number | null

    /**
     * Filter matches based on their start time (Unix timestamp).
     */
    readonly maxUnixTimestamp?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly minDurationS?: number | null

    /**
     * Filter matches based on their duration in seconds (up to 7000s).
     */
    readonly maxDurationS?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly minNetworth?: number | null

    /**
     * Filter players based on their net worth.
     */
    readonly maxNetworth?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly minAverageBadge?: number | null

    /**
     * Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
     */
    readonly maxAverageBadge?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly minMatchId?: number | null

    /**
     * Filter matches based on their ID.
     */
    readonly maxMatchId?: number | null
}

/**
 * Request parameters for steam operation in PlayersApi.
 */
export interface PlayersApiSteamRequest {
    /**
     * Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
     */
    readonly accountIds: Array<number>
}

/**
 * Request parameters for steamSearch operation in PlayersApi.
 */
export interface PlayersApiSteamSearchRequest {
    /**
     * Search query for Steam profiles.
     */
    readonly searchQuery: string
}

/**
 * PlayersApi - object-oriented interface
 */
export class PlayersApi extends BaseAPI {
    /**
     *  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
     * @summary Card
     * @param {PlayersApiCardRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public card(requestParameters: PlayersApiCardRequest, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).card(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Enemy Stats
     * @param {PlayersApiEnemyStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public enemyStats(requestParameters: PlayersApiEnemyStatsRequest, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).enemyStats(requestParameters.accountId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.minMatchesPlayed, requestParameters.maxMatchesPlayed, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
     * @summary Match History
     * @param {PlayersApiMatchHistoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public matchHistory(requestParameters: PlayersApiMatchHistoryRequest, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).matchHistory(requestParameters.accountId, requestParameters.forceRefetch, requestParameters.onlyStoredHistory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Mate Stats
     * @param {PlayersApiMateStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public mateStats(requestParameters: PlayersApiMateStatsRequest, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).mateStats(requestParameters.accountId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minMatchId, requestParameters.maxMatchId, requestParameters.minMatchesPlayed, requestParameters.maxMatchesPlayed, requestParameters.sameParty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Party Stats
     * @param {PlayersApiPartyStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public partyStats(requestParameters: PlayersApiPartyStatsRequest, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).partyStats(requestParameters.accountId, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Hero Stats
     * @param {PlayersApiPlayerHeroStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public playerHeroStats(requestParameters: PlayersApiPlayerHeroStatsRequest, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).playerHeroStats(requestParameters.accountIds, requestParameters.heroIds, requestParameters.minUnixTimestamp, requestParameters.maxUnixTimestamp, requestParameters.minDurationS, requestParameters.maxDurationS, requestParameters.minNetworth, requestParameters.maxNetworth, requestParameters.minAverageBadge, requestParameters.maxAverageBadge, requestParameters.minMatchId, requestParameters.maxMatchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Batch Steam Profile
     * @param {PlayersApiSteamRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public steam(requestParameters: PlayersApiSteamRequest, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).steam(requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Steam Profile Search
     * @param {PlayersApiSteamSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public steamSearch(requestParameters: PlayersApiSteamSearchRequest, options?: RawAxiosRequestConfig) {
        return PlayersApiFp(this.configuration).steamSearch(requestParameters.searchQuery, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SQLApi - axios parameter creator
 */
export const SQLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Lists all tables in the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Tables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTables: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sql/tables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Executes a SQL query on the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 300req/5min | | Key | 300req/5min | | Global | 600req/60s |     
         * @summary Query
         * @param {string} query The SQL query to execute. It must follow the Clickhouse SQL syntax.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sql: async (query: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('sql', 'query', query)
            const localVarPath = `/v1/sql`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the schema of a table.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Table Schema
         * @param {string} table The name of the table to fetch the schema for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tableSchema: async (table: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'table' is not null or undefined
            assertParamExists('tableSchema', 'table', table)
            const localVarPath = `/v1/sql/tables/{table}/schema`
                .replace(`{${"table"}}`, encodeURIComponent(String(table)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SQLApi - functional programming interface
 */
export const SQLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SQLApiAxiosParamCreator(configuration)
    return {
        /**
         *  Lists all tables in the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Tables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTables(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTables(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SQLApi.listTables']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Executes a SQL query on the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 300req/5min | | Key | 300req/5min | | Global | 600req/60s |     
         * @summary Query
         * @param {string} query The SQL query to execute. It must follow the Clickhouse SQL syntax.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sql(query: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sql(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SQLApi.sql']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *  Returns the schema of a table.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Table Schema
         * @param {string} table The name of the table to fetch the schema for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tableSchema(table: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tableSchema(table, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SQLApi.tableSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SQLApi - factory interface
 */
export const SQLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SQLApiFp(configuration)
    return {
        /**
         *  Lists all tables in the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary List Tables
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTables(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.listTables(options).then((request) => request(axios, basePath));
        },
        /**
         *  Executes a SQL query on the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 300req/5min | | Key | 300req/5min | | Global | 600req/60s |     
         * @summary Query
         * @param {SQLApiSqlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sql(requestParameters: SQLApiSqlRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.sql(requestParameters.query, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the schema of a table.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
         * @summary Table Schema
         * @param {SQLApiTableSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tableSchema(requestParameters: SQLApiTableSchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.tableSchema(requestParameters.table, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for sql operation in SQLApi.
 */
export interface SQLApiSqlRequest {
    /**
     * The SQL query to execute. It must follow the Clickhouse SQL syntax.
     */
    readonly query: string
}

/**
 * Request parameters for tableSchema operation in SQLApi.
 */
export interface SQLApiTableSchemaRequest {
    /**
     * The name of the table to fetch the schema for.
     */
    readonly table: string
}

/**
 * SQLApi - object-oriented interface
 */
export class SQLApi extends BaseAPI {
    /**
     *  Lists all tables in the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary List Tables
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listTables(options?: RawAxiosRequestConfig) {
        return SQLApiFp(this.configuration).listTables(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Executes a SQL query on the database.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 300req/5min | | Key | 300req/5min | | Global | 600req/60s |     
     * @summary Query
     * @param {SQLApiSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sql(requestParameters: SQLApiSqlRequest, options?: RawAxiosRequestConfig) {
        return SQLApiFp(this.configuration).sql(requestParameters.query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the schema of a table.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
     * @summary Table Schema
     * @param {SQLApiTableSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public tableSchema(requestParameters: SQLApiTableSchemaRequest, options?: RawAxiosRequestConfig) {
        return SQLApiFp(this.configuration).tableSchema(requestParameters.table, options).then((request) => request(this.axios, this.basePath));
    }
}



