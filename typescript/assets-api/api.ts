/* tslint:disable */
/* eslint-disable */
/**
 * Assets - Deadlock API
 *  ## Support the Deadlock API  Whether you\'re building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_ 
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AbilityDescriptionV2 {
    'desc'?: string | null;
    'quip'?: string | null;
    't1_desc'?: string | null;
    't2_desc'?: string | null;
    't3_desc'?: string | null;
    'active'?: string | null;
    'passive'?: string | null;
}
export interface AbilityTooltipDetailsInfoSectionPropertyBlockV2 {
    'loc_string'?: string | null;
    'properties'?: Array<AbilityV2TooltipDetailsInfoSectionPropertyBlockProperty> | null;
}
export interface AbilityTooltipDetailsInfoSectionV2Input {
    'loc_string'?: string | null;
    'property_upgrade_required'?: string | null;
    'properties_block'?: Array<AbilityTooltipDetailsInfoSectionPropertyBlockV2> | null;
    'basic_properties'?: Array<string> | null;
}
export interface AbilityTooltipDetailsInfoSectionV2Output {
    'loc_string'?: string | null;
    'property_upgrade_required'?: string | null;
    'properties_block'?: Array<AbilityTooltipDetailsInfoSectionPropertyBlockV2> | null;
    'basic_properties'?: Array<string> | null;
}
export interface AbilityTooltipDetailsV2Input {
    'info_sections'?: Array<AbilityTooltipDetailsInfoSectionV2Input> | null;
    'additional_header_properties'?: Array<string> | null;
}
export interface AbilityTooltipDetailsV2Output {
    'info_sections'?: Array<AbilityTooltipDetailsInfoSectionV2Output> | null;
    'additional_header_properties'?: Array<string> | null;
}

export const AbilityTypeV2 = {
    Innate: 'innate',
    Item: 'item',
    Signature: 'signature',
    Ultimate: 'ultimate',
    Weapon: 'weapon',
    Melee: 'melee'
} as const;

export type AbilityTypeV2 = typeof AbilityTypeV2[keyof typeof AbilityTypeV2];


export interface AbilityV2Input {
    'id': number;
    'class_name': string;
    'name': string;
    'start_trained'?: boolean | null;
    'image'?: string | null;
    'image_webp'?: string | null;
    'hero'?: number | null;
    'heroes'?: Array<number> | null;
    'update_time'?: number | null;
    'properties'?: { [key: string]: ItemPropertyV2Input; } | null;
    'weapon_info'?: RawItemWeaponInfoV2Input | null;
    'type'?: AbilityV2InputTypeEnum;
    'behaviours'?: Array<string> | null;
    'description': AbilityDescriptionV2;
    'tooltip_details'?: AbilityTooltipDetailsV2Input | null;
    'upgrades'?: Array<RawAbilityUpgradeV2Input> | null;
    'ability_type'?: AbilityTypeV2 | null;
    'boss_damage_scale'?: number | null;
    'dependant_abilities'?: Array<string> | null;
    'videos'?: AbilityVideosV2 | null;
}

export const AbilityV2InputTypeEnum = {
    Ability: 'ability'
} as const;

export type AbilityV2InputTypeEnum = typeof AbilityV2InputTypeEnum[keyof typeof AbilityV2InputTypeEnum];

export interface AbilityV2Output {
    'id': number;
    'class_name': string;
    'name': string;
    'start_trained'?: boolean | null;
    'image'?: string | null;
    'image_webp'?: string | null;
    'hero'?: number | null;
    'heroes'?: Array<number> | null;
    'update_time'?: number | null;
    'properties'?: { [key: string]: ItemPropertyV2Output; } | null;
    'weapon_info'?: RawItemWeaponInfoV2Output | null;
    'type'?: AbilityV2OutputTypeEnum;
    'behaviours'?: Array<string> | null;
    'description': AbilityDescriptionV2;
    'tooltip_details'?: AbilityTooltipDetailsV2Output | null;
    'upgrades'?: Array<RawAbilityUpgradeV2Output> | null;
    'ability_type'?: AbilityTypeV2 | null;
    'boss_damage_scale'?: number | null;
    'dependant_abilities'?: Array<string> | null;
    'videos'?: AbilityVideosV2 | null;
}

export const AbilityV2OutputTypeEnum = {
    Ability: 'ability'
} as const;

export type AbilityV2OutputTypeEnum = typeof AbilityV2OutputTypeEnum[keyof typeof AbilityV2OutputTypeEnum];

export interface AbilityV2TooltipDetailsInfoSectionPropertyBlockProperty {
    'requires_ability_upgrade'?: boolean | null;
    'show_property_value'?: boolean | null;
    'important_property'?: string | null;
    'status_effect_value'?: string | null;
    'status_effect_name'?: string | null;
    'important_property_icon'?: string | null;
}
export interface AbilityVideosV2 {
    'webm'?: string | null;
    'mp4'?: string | null;
}
export interface AimingShotSpreadPenalty {
}
export interface Bonus {
}
export interface BuildTagV2Input {
    'class_name': string;
    'label': string;
}
export interface BuildTagV2Output {
    'class_name': string;
    'label': string;
    'id': number;
    'icon': string;
}
export interface ColorV1 {
    /**
     * The red value of the color.
     */
    'red': number;
    /**
     * The green value of the color.
     */
    'green': number;
    /**
     * The blue value of the color.
     */
    'blue': number;
    /**
     * The alpha value of the color.
     */
    'alpha': number;
}

export const DeadlockAssetsApiRoutesRawValidClientVersions = {
    NUMBER_5945: 5945,
    NUMBER_5920: 5920,
    NUMBER_5902: 5902,
    NUMBER_5885: 5885,
    NUMBER_5878: 5878,
    NUMBER_5869: 5869,
    NUMBER_5852: 5852,
    NUMBER_5831: 5831,
    NUMBER_5826: 5826,
    NUMBER_5818: 5818,
    NUMBER_5789: 5789,
    NUMBER_5748: 5748,
    NUMBER_5723: 5723,
    NUMBER_5712: 5712,
    NUMBER_5710: 5710,
    NUMBER_5690: 5690,
    NUMBER_5675: 5675,
    NUMBER_5668: 5668,
    NUMBER_5664: 5664,
    NUMBER_5658: 5658,
    NUMBER_5650: 5650,
    NUMBER_5636: 5636,
    NUMBER_5624: 5624,
    NUMBER_5615: 5615,
    NUMBER_5602: 5602,
    NUMBER_5583: 5583,
    NUMBER_5554: 5554,
    NUMBER_5538: 5538,
    NUMBER_5533: 5533,
    NUMBER_5529: 5529,
    NUMBER_5527: 5527
} as const;

export type DeadlockAssetsApiRoutesRawValidClientVersions = typeof DeadlockAssetsApiRoutesRawValidClientVersions[keyof typeof DeadlockAssetsApiRoutesRawValidClientVersions];


/**
 * @type GetItemsV2ItemsGet200ResponseInner
 */
export type GetItemsV2ItemsGet200ResponseInner = { type: 'ability' } & AbilityV2Output | { type: 'upgrade' } & UpgradeV2Output | { type: 'weapon' } & WeaponV2Output;

export interface HTTPValidationError {
    'detail'?: Array<ValidationError>;
}
export interface HeroColorsV2 {
    'glow_enemy': Array<any>;
    'glow_friendly': Array<any>;
    'glow_team1': Array<any>;
    'glow_team2': Array<any>;
    'ui': Array<any>;
}
export interface HeroDescriptionV2 {
    'lore'?: string | null;
    'role'?: string | null;
    'playstyle'?: string | null;
}
export interface HeroImagesV2 {
    'icon_hero_card'?: string | null;
    'icon_hero_card_webp'?: string | null;
    'icon_image_small'?: string | null;
    'icon_image_small_webp'?: string | null;
    'minimap_image'?: string | null;
    'minimap_image_webp'?: string | null;
    'selection_image'?: string | null;
    'selection_image_webp'?: string | null;
    'top_bar_image'?: string | null;
    'top_bar_image_webp'?: string | null;
    'top_bar_vertical_image'?: string | null;
    'top_bar_vertical_image_webp'?: string | null;
    'weapon_image'?: string | null;
    'weapon_image_webp'?: string | null;
    'background_image'?: string | null;
    'background_image_webp'?: string | null;
    'name_image'?: string | null;
}

export const HeroItemTypeV2 = {
    WeaponPrimary: 'weapon_primary',
    WeaponSecondary: 'weapon_secondary',
    WeaponMelee: 'weapon_melee',
    AbilityMantle: 'ability_mantle',
    AbilityJump: 'ability_jump',
    AbilitySlide: 'ability_slide',
    AbilityZipLine: 'ability_zip_line',
    AbilityZipLineBoost: 'ability_zip_line_boost',
    AbilityClimbRope: 'ability_climb_rope',
    AbilityInnate1: 'ability_innate1',
    AbilityInnate2: 'ability_innate2',
    AbilityInnate3: 'ability_innate3',
    Signature1: 'signature1',
    Signature2: 'signature2',
    Signature3: 'signature3',
    Signature4: 'signature4'
} as const;

export type HeroItemTypeV2 = typeof HeroItemTypeV2[keyof typeof HeroItemTypeV2];


export interface HeroLevelInfoV2Input {
    'm_bUseStandardUpgrade'?: boolean | null;
    'bonus_currencies'?: Array<string> | null;
    'm_unRequiredGold': number;
}
export interface HeroLevelInfoV2Output {
    'use_standard_upgrade'?: boolean | null;
    'bonus_currencies'?: Array<string> | null;
    'required_gold': number;
}
export interface HeroPhysicsV2 {
    'collision_height': number;
    'collision_radius': number;
    'stealth_speed_meters_per_second': number;
    'step_height': number;
    'footstep_sound_travel_distance_meters'?: number | null;
    'step_sound_time'?: number | null;
    'step_sound_time_sprinting'?: number | null;
}
export interface HeroShopStatDisplayV2Input {
    'm_eSpiritStatsDisplay': RawHeroShopSpiritStatsDisplayV2Input;
    'm_eVitalityStatsDisplay': RawHeroShopVitalityStatsDisplayV2Input;
    'weapon_stats_display': HeroShopWeaponStatsDisplayV2Input;
}
export interface HeroShopStatDisplayV2Output {
    'spirit_stats_display': RawHeroShopSpiritStatsDisplayV2Output;
    'vitality_stats_display': RawHeroShopVitalityStatsDisplayV2Output;
    'weapon_stats_display': HeroShopWeaponStatsDisplayV2Output;
}
export interface HeroShopWeaponStatsDisplayV2Input {
    'm_vecDisplayStats': Array<string>;
    'm_vecOtherDisplayStats': Array<string>;
    'weapon_attributes'?: Array<string> | null;
    'm_strWeaponImage'?: string | null;
    'weapon_image_webp'?: string | null;
}
export interface HeroShopWeaponStatsDisplayV2Output {
    'display_stats': Array<string>;
    'other_display_stats': Array<string>;
    'weapon_attributes'?: Array<string> | null;
    'weapon_image'?: string | null;
    'weapon_image_webp'?: string | null;
}
export interface HeroStartingStatV2 {
    'value': Value;
    'display_stat_name': string;
}
export interface HeroStartingStatsV2 {
    'max_move_speed': HeroStartingStatV2;
    'sprint_speed': HeroStartingStatV2;
    'crouch_speed': HeroStartingStatV2;
    'move_acceleration': HeroStartingStatV2;
    'light_melee_damage': HeroStartingStatV2;
    'heavy_melee_damage': HeroStartingStatV2;
    'max_health': HeroStartingStatV2;
    'weapon_power': HeroStartingStatV2;
    'reload_speed': HeroStartingStatV2;
    'weapon_power_scale': HeroStartingStatV2;
    'proc_build_up_rate_scale': HeroStartingStatV2;
    'stamina': HeroStartingStatV2;
    'base_health_regen': HeroStartingStatV2;
    'stamina_regen_per_second': HeroStartingStatV2;
    'ability_resource_max': HeroStartingStatV2;
    'ability_resource_regen_per_second': HeroStartingStatV2;
    'crit_damage_received_scale': HeroStartingStatV2;
    'tech_duration': HeroStartingStatV2;
    'tech_armor_damage_reduction'?: HeroStartingStatV2 | null;
    'tech_range': HeroStartingStatV2;
    'bullet_armor_damage_reduction'?: HeroStartingStatV2 | null;
}

export const HeroTypeV2 = {
    Assassin: 'assassin',
    Brawler: 'brawler',
    Marksman: 'marksman',
    Mystic: 'mystic'
} as const;

export type HeroTypeV2 = typeof HeroTypeV2[keyof typeof HeroTypeV2];


export interface HeroV2 {
    'id': number;
    'class_name': string;
    'name': string;
    'description': HeroDescriptionV2;
    'recommended_upgrades'?: Array<string> | null;
    'recommended_ability_order'?: Array<string> | null;
    'player_selectable': boolean;
    'disabled': boolean;
    'in_development': boolean;
    'needs_testing': boolean;
    'assigned_players_only': boolean;
    'tags'?: Array<string> | null;
    'gun_tag'?: string | null;
    'hideout_rich_presence'?: string | null;
    'hero_type'?: HeroTypeV2 | null;
    'prerelease_only'?: boolean | null;
    'limited_testing': boolean;
    'complexity': number;
    'skin': number;
    'images': HeroImagesV2;
    'items': { [key: string]: string; };
    'starting_stats': HeroStartingStatsV2;
    'item_slot_info': { [key: string]: RawHeroItemSlotInfoValueV2Output; };
    'physics': HeroPhysicsV2;
    'colors': HeroColorsV2;
    'shop_stat_display': HeroShopStatDisplayV2Output;
    'cost_bonuses'?: { [key: string]: Array<RawHeroMapModCostBonusesV2Output>; } | null;
    'stats_display': RawHeroStatsDisplayV2Output;
    'hero_stats_ui': RawHeroStatsUIV2Output;
    'level_info': { [key: string]: HeroLevelInfoV2Output; };
    'scaling_stats': { [key: string]: RawHeroScalingStatV2Output; };
    'purchase_bonuses': { [key: string]: Array<RawHeroPurchaseBonusV2Output>; };
    'standard_level_up_upgrades': { [key: string]: number; };
}


export interface ItemPropertyV2Input {
    'm_strValue'?: MStrvalue | null;
    'm_bCanSetTokenOverride'?: boolean | null;
    'm_eProvidedPropertyType'?: string | null;
    'm_strCSSClass'?: string | null;
    'm_eStatsUsageFlags'?: MEstatsusageflags | null;
    'm_bIsNegativeAttribute'?: boolean | null;
    'm_strDisableValue'?: string | null;
    'm_strLocTokenOverride'?: string | null;
    'm_eDisplayUnits'?: string | null;
    'scale_function'?: RawItemPropertyScaleFunctionSubclassV2Input | null;
    'prefix'?: string | null;
    'label'?: string | null;
    'postfix'?: string | null;
    'postvalue_label'?: string | null;
    'conditional'?: string | null;
    'icon'?: string | null;
}
export interface ItemPropertyV2Output {
    'value'?: Value1 | null;
    'can_set_token_override'?: boolean | null;
    'provided_property_type'?: string | null;
    'css_class'?: string | null;
    'usage_flags'?: UsageFlags | null;
    'negative_attribute'?: boolean | null;
    'disable_value'?: string | null;
    'loc_token_override'?: string | null;
    'display_units'?: string | null;
    'icon_path'?: string | null;
    'scale_function'?: RawItemPropertyScaleFunctionSubclassV2Output | null;
    'prefix'?: string | null;
    'label'?: string | null;
    'postfix'?: string | null;
    'postvalue_label'?: string | null;
    'conditional'?: string | null;
    'icon'?: string | null;
}

export const ItemSlotTypeV2 = {
    Weapon: 'weapon',
    Spirit: 'spirit',
    Vitality: 'vitality'
} as const;

export type ItemSlotTypeV2 = typeof ItemSlotTypeV2[keyof typeof ItemSlotTypeV2];



export const ItemTierV2 = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4
} as const;

export type ItemTierV2 = typeof ItemTierV2[keyof typeof ItemTierV2];



export const ItemTypeV2 = {
    Weapon: 'weapon',
    Ability: 'ability',
    Upgrade: 'upgrade',
    Tech: 'tech',
    Armor: 'armor'
} as const;

export type ItemTypeV2 = typeof ItemTypeV2[keyof typeof ItemTypeV2];



export const Language = {
    Brazilian: 'brazilian',
    Bulgarian: 'bulgarian',
    Czech: 'czech',
    Danish: 'danish',
    Dutch: 'dutch',
    English: 'english',
    Finnish: 'finnish',
    French: 'french',
    German: 'german',
    Greek: 'greek',
    Hungarian: 'hungarian',
    Indonesian: 'indonesian',
    Italian: 'italian',
    Japanese: 'japanese',
    Koreana: 'koreana',
    Latam: 'latam',
    Norwegian: 'norwegian',
    Polish: 'polish',
    Portuguese: 'portuguese',
    Romanian: 'romanian',
    Russian: 'russian',
    Schinese: 'schinese',
    Spanish: 'spanish',
    Swedish: 'swedish',
    Tchinese: 'tchinese',
    Thai: 'thai',
    Turkish: 'turkish',
    Ukrainian: 'ukrainian',
    Vietnamese: 'vietnamese'
} as const;

export type Language = typeof Language[keyof typeof Language];


export interface MAimingshootspreadpenalty {
}
export interface MEstatsusageflags {
}
export interface MRange {
}
export interface MStandingshootspreadpenalty {
}
export interface MStrbonus {
}
export interface MStrvalue {
}
export interface MapImagesV1 {
    /**
     * The minimap image of the map.
     */
    'minimap': string;
    /**
     * The minimap image of the map without background image and frame image.
     */
    'plain': string;
    /**
     * The background image of the map.
     */
    'background': string;
    /**
     * The frame image of the map.
     */
    'frame': string;
    /**
     * The mid image of the map.
     */
    'mid': string;
}
export interface MapV1 {
    /**
     * The radius of the map.
     */
    'radius'?: number;
    /**
     * The images of the map.
     */
    'images': MapImagesV1;
    'objective_positions': ObjectivePositionsV1;
    /**
     * The ziplane paths of the map. Each path is a list of P0, P1, and P2 points, describing the cubic spline.
     */
    'zipline_paths': Array<ZiplanePathV1>;
}
export interface ObjectivePositionV1 {
    /**
     * The relative margin left of the map image.
     */
    'left_relative': number;
    /**
     * The relative margin top of the map image.
     */
    'top_relative': number;
}
export interface ObjectivePositionsV1 {
    'team0_core': ObjectivePositionV1;
    'team1_core': ObjectivePositionV1;
    'team0_titan': ObjectivePositionV1;
    'team1_titan': ObjectivePositionV1;
    'team0_tier2_1': ObjectivePositionV1;
    'team0_tier2_2'?: ObjectivePositionV1 | null;
    'team0_tier2_3': ObjectivePositionV1;
    'team0_tier2_4': ObjectivePositionV1;
    'team1_tier2_1': ObjectivePositionV1;
    'team1_tier2_2'?: ObjectivePositionV1 | null;
    'team1_tier2_3': ObjectivePositionV1;
    'team1_tier2_4': ObjectivePositionV1;
    'team0_tier1_1': ObjectivePositionV1;
    'team0_tier1_2'?: ObjectivePositionV1 | null;
    'team0_tier1_3': ObjectivePositionV1;
    'team0_tier1_4': ObjectivePositionV1;
    'team1_tier1_1': ObjectivePositionV1;
    'team1_tier1_2'?: ObjectivePositionV1 | null;
    'team1_tier1_3': ObjectivePositionV1;
    'team1_tier1_4': ObjectivePositionV1;
}
export interface Range {
}
export interface RankImagesV2 {
    'large'?: string | null;
    'large_webp'?: string | null;
    'large_subrank1'?: string | null;
    'large_subrank1_webp'?: string | null;
    'large_subrank2'?: string | null;
    'large_subrank2_webp'?: string | null;
    'large_subrank3'?: string | null;
    'large_subrank3_webp'?: string | null;
    'large_subrank4'?: string | null;
    'large_subrank4_webp'?: string | null;
    'large_subrank5'?: string | null;
    'large_subrank5_webp'?: string | null;
    'large_subrank6'?: string | null;
    'large_subrank6_webp'?: string | null;
    'small'?: string | null;
    'small_webp'?: string | null;
    'small_subrank1'?: string | null;
    'small_subrank1_webp'?: string | null;
    'small_subrank2'?: string | null;
    'small_subrank2_webp'?: string | null;
    'small_subrank3'?: string | null;
    'small_subrank3_webp'?: string | null;
    'small_subrank4'?: string | null;
    'small_subrank4_webp'?: string | null;
    'small_subrank5'?: string | null;
    'small_subrank5_webp'?: string | null;
    'small_subrank6'?: string | null;
    'small_subrank6_webp'?: string | null;
}
export interface RankV2Input {
    'tier': number;
    'name': string;
    'images': RankImagesV2;
}
export interface RankV2Output {
    'tier': number;
    'name': string;
    'images': RankImagesV2;
    'color': string;
}

export const RawAbilityActivationV2 = {
    HoldToggle: 'hold_toggle',
    InstantCast: 'instant_cast',
    OnButtonIsDown: 'on_button_is_down',
    Passive: 'passive',
    Press: 'press',
    PressToggle: 'press_toggle'
} as const;

export type RawAbilityActivationV2 = typeof RawAbilityActivationV2[keyof typeof RawAbilityActivationV2];



export const RawAbilityImbueV2 = {
    ImbueActive: 'imbue_active',
    ImbueActiveNonUlt: 'imbue_active_non_ult',
    ImbueModifierValue: 'imbue_modifier_value'
} as const;

export type RawAbilityImbueV2 = typeof RawAbilityImbueV2[keyof typeof RawAbilityImbueV2];



export const RawAbilitySectionTypeV2 = {
    Innate: 'innate',
    Active: 'active',
    Passive: 'passive'
} as const;

export type RawAbilitySectionTypeV2 = typeof RawAbilitySectionTypeV2[keyof typeof RawAbilitySectionTypeV2];


export interface RawAbilityUpgradePropertyUpgradeV2Input {
    'm_strPropertyName': string;
    'm_strBonus': MStrbonus;
    'm_eScaleStatFilter'?: string | null;
    'm_eUpgradeType'?: string | null;
}
export interface RawAbilityUpgradePropertyUpgradeV2Output {
    'name': string;
    'bonus': Bonus;
    'scale_stat_filter'?: string | null;
    'upgrade_type'?: string | null;
}
export interface RawAbilityUpgradeV2Input {
    'm_vecPropertyUpgrades'?: Array<RawAbilityUpgradePropertyUpgradeV2Input>;
}
export interface RawAbilityUpgradeV2Output {
    'property_upgrades'?: Array<RawAbilityUpgradePropertyUpgradeV2Output>;
}
export interface RawHeroItemSlotInfoValueV2Input {
    'm_arMaxPurchasesForTier': Array<number>;
}
export interface RawHeroItemSlotInfoValueV2Output {
    'max_purchases_for_tier': Array<number>;
}
export interface RawHeroMapModCostBonusesV2Input {
    'nGoldThreshold': number;
    'flBonus': number;
    'flPercentOnGraph': number;
}
export interface RawHeroMapModCostBonusesV2Output {
    'gold_threshold': number;
    'bonus': number;
    'percent_on_graph': number;
}
export interface RawHeroPurchaseBonusV2Input {
    'm_ValueType': string;
    'm_nTier': number;
    'm_strValue': string;
}
export interface RawHeroPurchaseBonusV2Output {
    'value_type': string;
    'tier': number;
    'value': string;
}
export interface RawHeroScalingStatV2Input {
    'eScalingStat': string;
    'flScale': number;
}
export interface RawHeroScalingStatV2Output {
    'scaling_stat': string;
    'scale': number;
}
export interface RawHeroShopSpiritStatsDisplayV2Input {
    'm_vecDisplayStats': Array<string>;
}
export interface RawHeroShopSpiritStatsDisplayV2Output {
    'display_stats': Array<string>;
}
export interface RawHeroShopVitalityStatsDisplayV2Input {
    'm_vecDisplayStats': Array<string>;
    'm_vecOtherDisplayStats': Array<string>;
}
export interface RawHeroShopVitalityStatsDisplayV2Output {
    'display_stats': Array<string>;
    'other_display_stats': Array<string>;
}
export interface RawHeroStatsDisplayV2Input {
    'm_vecHealthHeaderStats': Array<string>;
    'm_vecMagicHeaderStats': Array<string>;
    'm_vecMagicStats': Array<string>;
    'm_vecWeaponHeaderStats': Array<string>;
    'm_vecWeaponStats': Array<string>;
}
export interface RawHeroStatsDisplayV2Output {
    'health_header_stats': Array<string>;
    'health_stats': Array<string>;
    'magic_header_stats': Array<string>;
    'magic_stats': Array<string>;
    'weapon_header_stats': Array<string>;
    'weapon_stats': Array<string>;
}
export interface RawHeroStatsUIDisplayV2Input {
    'm_eStatCategory': string;
    'm_eStatType': string;
}
export interface RawHeroStatsUIDisplayV2Output {
    'category': string;
    'stat_type': string;
}
export interface RawHeroStatsUIV2Input {
    'm_eWeaponStatDisplay': string;
    'm_vecDisplayStats': Array<RawHeroStatsUIDisplayV2Input>;
}
export interface RawHeroStatsUIV2Output {
    'weapon_stat_display': string;
    'display_stats': Array<RawHeroStatsUIDisplayV2Output>;
}
export interface RawItemPropertyScaleFunctionSubclassV2Input {
    '_class'?: string | null;
    '_my_subclass_name'?: string | null;
    'm_eSpecificStatScaleType'?: string | null;
    'm_vecScalingStats'?: Array<string> | null;
    'm_flStatScale'?: number | null;
}
export interface RawItemPropertyScaleFunctionSubclassV2Output {
    'class_name'?: string | null;
    'subclass_name'?: string | null;
    'specific_stat_scale_type'?: string | null;
    'scaling_stats'?: Array<string> | null;
    'stat_scale'?: number | null;
}
export interface RawItemWeaponInfoBulletSpeedCurveSplineV2Input {
    'm_flSlopeIncoming': number;
    'm_flSlopeOutgoing': number;
    'x': number;
    'y': number;
}
export interface RawItemWeaponInfoBulletSpeedCurveSplineV2Output {
    'slope_incoming': number;
    'slope_outgoing': number;
    'x': number;
    'y': number;
}
export interface RawItemWeaponInfoBulletSpeedCurveV2Input {
    'm_spline'?: Array<RawItemWeaponInfoBulletSpeedCurveSplineV2Input>;
    'm_vDomainMaxs': Array<number>;
    'm_vDomainMins': Array<number>;
}
export interface RawItemWeaponInfoBulletSpeedCurveV2Output {
    'spline'?: Array<RawItemWeaponInfoBulletSpeedCurveSplineV2Output>;
    'domain_maxs': Array<number>;
    'domain_mins': Array<number>;
}
export interface RawItemWeaponInfoV2Input {
    'm_BulletSpeedCurve'?: RawItemWeaponInfoBulletSpeedCurveV2Input | null;
}
export interface RawItemWeaponInfoV2Output {
    'bullet_speed_curve'?: RawItemWeaponInfoBulletSpeedCurveV2Output | null;
}
export interface RawWeaponInfoHorizontalRecoilV2Input {
    'm_Range'?: MRange | null;
    'm_flBurstExponent'?: number | null;
}
export interface RawWeaponInfoHorizontalRecoilV2Output {
    'range'?: Range | null;
    'burst_exponent'?: number | null;
}
export interface RawWeaponInfoV2Input {
    'm_bCanZoom'?: boolean | null;
    'm_flBulletDamage'?: number | null;
    'm_flBulletGravityScale'?: number | null;
    'm_flBulletInheritShooterVelocityScale'?: number | null;
    'm_flBulletLifetime'?: number | null;
    'm_flBulletRadius'?: number | null;
    'm_flBulletRadiusVsWorld'?: number | null;
    'm_flBulletReflectAmount'?: number | null;
    'm_flBulletReflectScale'?: number | null;
    'm_flBulletWhizDistance'?: number | null;
    'm_flBurstShotCooldown'?: number | null;
    'm_flCritBonusAgainstNpcs'?: number | null;
    'm_flCritBonusEnd'?: number | null;
    'm_flCritBonusEndRange'?: number | null;
    'm_flCritBonusStart'?: number | null;
    'm_flCritBonusStartRange'?: number | null;
    'm_flCycleTime'?: number | null;
    'm_flIntraBurstCycleTime'?: number | null;
    'm_flMaxSpinCycleTime'?: number | null;
    'm_flDamageFalloffBias'?: number | null;
    'm_flDamageFalloffEndRange'?: number | null;
    'm_flDamageFalloffEndScale'?: number | null;
    'm_flDamageFalloffStartRange'?: number | null;
    'm_flDamageFalloffStartScale'?: number | null;
    'm_flHorizontalPunch'?: number | null;
    'm_flRange'?: number | null;
    'm_flRecoilRecoveryDelayFactor'?: number | null;
    'm_flRecoilRecoverySpeed'?: number | null;
    'm_flRecoilShotIndexRecoveryTimeFactor'?: number | null;
    'm_flRecoilSpeed'?: number | null;
    'm_flReloadMoveSpeed'?: number | null;
    'm_flScatterYawScale'?: number | null;
    'm_AimingShootSpreadPenalty'?: MAimingshootspreadpenalty | null;
    'm_StandingShootSpreadPenalty'?: MStandingshootspreadpenalty | null;
    'm_flShootMoveSpeedPercent'?: number | null;
    'm_flShootSpreadPenaltyDecay'?: number | null;
    'm_flShootSpreadPenaltyDecayDelay'?: number | null;
    'm_flShootSpreadPenaltyPerShot'?: number | null;
    'm_flShootingUpSpreadPenalty'?: number | null;
    'm_flVerticalPunch'?: number | null;
    'm_flZoomFov'?: number | null;
    'm_flZoomMoveSpeedPercent'?: number | null;
    'm_iBullets'?: number | null;
    'm_iBurstShotCount'?: number | null;
    'm_iClipSize'?: number | null;
    'm_flSpread'?: number | null;
    'm_flStandingSpread'?: number | null;
    'm_flLowAmmoIndicatorThreshold'?: number | null;
    'm_flRecoilSeed'?: number | null;
    'm_flReloadDuration'?: number | null;
    'm_BulletSpeedCurve'?: RawItemWeaponInfoBulletSpeedCurveV2Input | null;
    'm_HorizontalRecoil'?: RawWeaponInfoHorizontalRecoilV2Input | null;
    'm_VerticalRecoil'?: RawWeaponInfoVerticalRecoilV2Input | null;
}
export interface RawWeaponInfoV2Output {
    'can_zoom'?: boolean | null;
    'bullet_damage'?: number | null;
    'bullet_gravity_scale'?: number | null;
    'bullet_inherit_shooter_velocity_scale'?: number | null;
    'bullet_lifetime'?: number | null;
    'bullet_radius'?: number | null;
    'bullet_radius_vs_world'?: number | null;
    'bullet_reflect_amount'?: number | null;
    'bullet_reflect_scale'?: number | null;
    'bullet_whiz_distance'?: number | null;
    'burst_shot_cooldown'?: number | null;
    'crit_bonus_against_npcs'?: number | null;
    'crit_bonus_end'?: number | null;
    'crit_bonus_end_range'?: number | null;
    'crit_bonus_start'?: number | null;
    'crit_bonus_start_range'?: number | null;
    'cycle_time'?: number | null;
    'intra_burst_cycle_time'?: number | null;
    'max_spin_cycle_time'?: number | null;
    'damage_falloff_bias'?: number | null;
    'damage_falloff_end_range'?: number | null;
    'damage_falloff_end_scale'?: number | null;
    'damage_falloff_start_range'?: number | null;
    'damage_falloff_start_scale'?: number | null;
    'horizontal_punch'?: number | null;
    'range'?: number | null;
    'recoil_recovery_delay_factor'?: number | null;
    'recoil_recovery_speed'?: number | null;
    'recoil_shot_index_recovery_time_factor'?: number | null;
    'recoil_speed'?: number | null;
    'reload_move_speed'?: number | null;
    'scatter_yaw_scale'?: number | null;
    'aiming_shot_spread_penalty'?: AimingShotSpreadPenalty | null;
    'standing_shot_spread_penalty'?: StandingShotSpreadPenalty | null;
    'shoot_move_speed_percent'?: number | null;
    'shoot_spread_penalty_decay'?: number | null;
    'shoot_spread_penalty_decay_delay'?: number | null;
    'shoot_spread_penalty_per_shot'?: number | null;
    'shooting_up_spread_penalty'?: number | null;
    'vertical_punch'?: number | null;
    'zoom_fov'?: number | null;
    'zoom_move_speed_percent'?: number | null;
    'bullets'?: number | null;
    'burst_shot_count'?: number | null;
    'clip_size'?: number | null;
    'spread'?: number | null;
    'standing_spread'?: number | null;
    'low_ammo_indicator_threshold'?: number | null;
    'recoil_seed'?: number | null;
    'reload_duration'?: number | null;
    'bullet_speed_curve'?: RawItemWeaponInfoBulletSpeedCurveV2Output | null;
    'horizontal_recoil'?: RawWeaponInfoHorizontalRecoilV2Output | null;
    'vertical_recoil'?: RawWeaponInfoVerticalRecoilV2Output | null;
}
export interface RawWeaponInfoVerticalRecoilV2Input {
    'm_Range'?: MRange | null;
    'm_flBurstExponent'?: number | null;
    'm_flBurstConstant'?: number | null;
    'm_flBurstSlope'?: number | null;
}
export interface RawWeaponInfoVerticalRecoilV2Output {
    'range'?: Range | null;
    'burst_exponent'?: number | null;
    'burst_constant'?: number | null;
    'burst_slope'?: number | null;
}
/**
 * @type ResponseGetItemV2ItemsIdOrClassNameGet
 */
export type ResponseGetItemV2ItemsIdOrClassNameGet = { type: 'ability' } & AbilityV2Output | { type: 'upgrade' } & UpgradeV2Output | { type: 'weapon' } & WeaponV2Output;

export interface StandingShotSpreadPenalty {
}

export const StatsUsageFlagV2 = {
    ConditionallyApplied: 'ConditionallyApplied',
    ConditionallyEnemyApplied: 'ConditionallyEnemyApplied',
    IntrinsicallyProvidedInAbility: 'IntrinsicallyProvidedInAbility',
    IntrinsicallyProvidedInModifier: 'IntrinsicallyProvidedInModifier'
} as const;

export type StatsUsageFlagV2 = typeof StatsUsageFlagV2[keyof typeof StatsUsageFlagV2];


export interface UpgradeDescriptionV2 {
    'desc'?: string | null;
    'active'?: string | null;
    'passive'?: string | null;
}
export interface UpgradePropertyV2Input {
    'm_strValue'?: MStrvalue | null;
    'm_bCanSetTokenOverride'?: boolean | null;
    'm_eProvidedPropertyType'?: string | null;
    'm_strCSSClass'?: string | null;
    'm_eStatsUsageFlags'?: MEstatsusageflags | null;
    'm_bIsNegativeAttribute'?: boolean | null;
    'm_strDisableValue'?: string | null;
    'm_strLocTokenOverride'?: string | null;
    'm_eDisplayUnits'?: string | null;
    'scale_function'?: RawItemPropertyScaleFunctionSubclassV2Input | null;
    'prefix'?: string | null;
    'label'?: string | null;
    'postfix'?: string | null;
    'postvalue_label'?: string | null;
    'conditional'?: string | null;
    'icon'?: string | null;
    'tooltip_section'?: RawAbilitySectionTypeV2 | null;
    'tooltip_is_elevated'?: boolean | null;
    'tooltip_is_important'?: boolean | null;
}


export interface UpgradePropertyV2Output {
    'value'?: Value1 | null;
    'can_set_token_override'?: boolean | null;
    'provided_property_type'?: string | null;
    'css_class'?: string | null;
    'usage_flags'?: UsageFlags | null;
    'negative_attribute'?: boolean | null;
    'disable_value'?: string | null;
    'loc_token_override'?: string | null;
    'display_units'?: string | null;
    'icon_path'?: string | null;
    'scale_function'?: RawItemPropertyScaleFunctionSubclassV2Output | null;
    'prefix'?: string | null;
    'label'?: string | null;
    'postfix'?: string | null;
    'postvalue_label'?: string | null;
    'conditional'?: string | null;
    'icon'?: string | null;
    'tooltip_section'?: RawAbilitySectionTypeV2 | null;
    'tooltip_is_elevated'?: boolean | null;
    'tooltip_is_important'?: boolean | null;
}


export interface UpgradeTooltipSectionAttributeV2 {
    'loc_string'?: string | null;
    'properties'?: Array<string> | null;
    'elevated_properties'?: Array<string> | null;
    'important_properties'?: Array<string> | null;
    'important_properties_with_icon'?: Array<UpgradeTooltipSectionAttributeV2ImportantPropertyWithIcon> | null;
}
export interface UpgradeTooltipSectionAttributeV2ImportantPropertyWithIcon {
    'name'?: string | null;
    'icon'?: string | null;
    'localized_name'?: string | null;
}
export interface UpgradeTooltipSectionV2Input {
    'section_type'?: RawAbilitySectionTypeV2 | null;
    'section_attributes'?: Array<UpgradeTooltipSectionAttributeV2> | null;
}


export interface UpgradeTooltipSectionV2Output {
    'section_type'?: RawAbilitySectionTypeV2 | null;
    'section_attributes'?: Array<UpgradeTooltipSectionAttributeV2> | null;
}


export interface UpgradeV2Input {
    'id': number;
    'class_name': string;
    'name': string;
    'start_trained'?: boolean | null;
    'image'?: string | null;
    'image_webp'?: string | null;
    'hero'?: number | null;
    'heroes'?: Array<number> | null;
    'update_time'?: number | null;
    'properties'?: { [key: string]: UpgradePropertyV2Input; } | null;
    'weapon_info'?: RawItemWeaponInfoV2Input | null;
    'type'?: UpgradeV2InputTypeEnum;
    'shop_image'?: string | null;
    'shop_image_webp'?: string | null;
    'shop_image_small'?: string | null;
    'shop_image_small_webp'?: string | null;
    'item_slot_type': ItemSlotTypeV2;
    'item_tier': ItemTierV2;
    'disabled'?: boolean | null;
    'description'?: UpgradeDescriptionV2 | null;
    'activation': RawAbilityActivationV2;
    'imbue'?: RawAbilityImbueV2 | null;
    'component_items'?: Array<string> | null;
    'tooltip_sections'?: Array<UpgradeTooltipSectionV2Input> | null;
}

export const UpgradeV2InputTypeEnum = {
    Upgrade: 'upgrade'
} as const;

export type UpgradeV2InputTypeEnum = typeof UpgradeV2InputTypeEnum[keyof typeof UpgradeV2InputTypeEnum];

export interface UpgradeV2Output {
    'id': number;
    'class_name': string;
    'name': string;
    'start_trained'?: boolean | null;
    'image'?: string | null;
    'image_webp'?: string | null;
    'hero'?: number | null;
    'heroes'?: Array<number> | null;
    'update_time'?: number | null;
    'properties'?: { [key: string]: UpgradePropertyV2Output; } | null;
    'weapon_info'?: RawItemWeaponInfoV2Output | null;
    'type'?: UpgradeV2OutputTypeEnum;
    'shop_image'?: string | null;
    'shop_image_webp'?: string | null;
    'shop_image_small'?: string | null;
    'shop_image_small_webp'?: string | null;
    'item_slot_type': ItemSlotTypeV2;
    'item_tier': ItemTierV2;
    'disabled'?: boolean | null;
    'description'?: UpgradeDescriptionV2 | null;
    'activation': RawAbilityActivationV2;
    'imbue'?: RawAbilityImbueV2 | null;
    'component_items'?: Array<string> | null;
    'tooltip_sections'?: Array<UpgradeTooltipSectionV2Output> | null;
    'is_active_item': boolean;
    'shopable': boolean;
    'cost': number | null;
}

export const UpgradeV2OutputTypeEnum = {
    Upgrade: 'upgrade'
} as const;

export type UpgradeV2OutputTypeEnum = typeof UpgradeV2OutputTypeEnum[keyof typeof UpgradeV2OutputTypeEnum];

export interface UsageFlags {
}
export interface ValidationError {
    'loc': Array<ValidationErrorLocInner>;
    'msg': string;
    'type': string;
}
export interface ValidationErrorLocInner {
}
export interface Value {
}
export interface Value1 {
}
export interface WeaponV2Input {
    'id': number;
    'class_name': string;
    'name': string;
    'start_trained'?: boolean | null;
    'image'?: string | null;
    'image_webp'?: string | null;
    'hero'?: number | null;
    'heroes'?: Array<number> | null;
    'update_time'?: number | null;
    'properties'?: { [key: string]: ItemPropertyV2Input; } | null;
    'weapon_info'?: RawWeaponInfoV2Input | null;
    'type'?: WeaponV2InputTypeEnum;
}

export const WeaponV2InputTypeEnum = {
    Weapon: 'weapon'
} as const;

export type WeaponV2InputTypeEnum = typeof WeaponV2InputTypeEnum[keyof typeof WeaponV2InputTypeEnum];

export interface WeaponV2Output {
    'id': number;
    'class_name': string;
    'name': string;
    'start_trained'?: boolean | null;
    'image'?: string | null;
    'image_webp'?: string | null;
    'hero'?: number | null;
    'heroes'?: Array<number> | null;
    'update_time'?: number | null;
    'properties'?: { [key: string]: ItemPropertyV2Output; } | null;
    'weapon_info'?: RawWeaponInfoV2Output | null;
    'type'?: WeaponV2OutputTypeEnum;
}

export const WeaponV2OutputTypeEnum = {
    Weapon: 'weapon'
} as const;

export type WeaponV2OutputTypeEnum = typeof WeaponV2OutputTypeEnum[keyof typeof WeaponV2OutputTypeEnum];

export interface ZiplanePathV1 {
    /**
     * The origin of the path.
     */
    'origin': Array<any>;
    /**
     * The color of the path.
     */
    'color': string;
    /**
     * The P0 points of the path.
     */
    'P0_points': Array<Array<any>>;
    /**
     * The P1 points of the path.
     */
    'P1_points': Array<Array<any>>;
    /**
     * The P2 points of the path.
     */
    'P2_points': Array<Array<any>>;
}

/**
 * DefaultApi - axios parameter creator
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Build Tags
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildTagsV2BuildTagsGet: async (language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/build-tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Client Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientVersionsV2ClientVersionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/client-versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Colors
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColorsV1ColorsGet: async (clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/colors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Icons
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIconsV1IconsGet: async (clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/icons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Map
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapV1MapGet: async (clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/map`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Ranks
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRanksV2RanksGet: async (language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/ranks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sounds
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoundsV1SoundsGet: async (clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/sounds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Steam Info
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSteamInfoV1SteamInfoGet: async (clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/steam-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Build Tags
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBuildTagsV2BuildTagsGet(language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BuildTagV2Output>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildTagsV2BuildTagsGet(language, clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getBuildTagsV2BuildTagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Client Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientVersionsV2ClientVersionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientVersionsV2ClientVersionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getClientVersionsV2ClientVersionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Colors
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getColorsV1ColorsGet(clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: ColorV1; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getColorsV1ColorsGet(clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getColorsV1ColorsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Icons
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIconsV1IconsGet(clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIconsV1IconsGet(clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getIconsV1IconsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Map
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMapV1MapGet(clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MapV1>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMapV1MapGet(clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getMapV1MapGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Ranks
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRanksV2RanksGet(language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RankV2Output>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRanksV2RanksGet(language, clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getRanksV2RanksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Sounds
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSoundsV1SoundsGet(clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSoundsV1SoundsGet(clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSoundsV1SoundsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Steam Info
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSteamInfoV1SteamInfoGet(clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSteamInfoV1SteamInfoGet(clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.getSteamInfoV1SteamInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Build Tags
         * @param {DefaultApiGetBuildTagsV2BuildTagsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuildTagsV2BuildTagsGet(requestParameters: DefaultApiGetBuildTagsV2BuildTagsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<BuildTagV2Output>> {
            return localVarFp.getBuildTagsV2BuildTagsGet(requestParameters.language, requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Client Versions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientVersionsV2ClientVersionsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<number>> {
            return localVarFp.getClientVersionsV2ClientVersionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Colors
         * @param {DefaultApiGetColorsV1ColorsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getColorsV1ColorsGet(requestParameters: DefaultApiGetColorsV1ColorsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: ColorV1; }> {
            return localVarFp.getColorsV1ColorsGet(requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Icons
         * @param {DefaultApiGetIconsV1IconsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIconsV1IconsGet(requestParameters: DefaultApiGetIconsV1IconsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getIconsV1IconsGet(requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Map
         * @param {DefaultApiGetMapV1MapGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMapV1MapGet(requestParameters: DefaultApiGetMapV1MapGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<MapV1> {
            return localVarFp.getMapV1MapGet(requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Ranks
         * @param {DefaultApiGetRanksV2RanksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRanksV2RanksGet(requestParameters: DefaultApiGetRanksV2RanksGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<RankV2Output>> {
            return localVarFp.getRanksV2RanksGet(requestParameters.language, requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sounds
         * @param {DefaultApiGetSoundsV1SoundsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSoundsV1SoundsGet(requestParameters: DefaultApiGetSoundsV1SoundsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getSoundsV1SoundsGet(requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Steam Info
         * @param {DefaultApiGetSteamInfoV1SteamInfoGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSteamInfoV1SteamInfoGet(requestParameters: DefaultApiGetSteamInfoV1SteamInfoGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getSteamInfoV1SteamInfoGet(requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getBuildTagsV2BuildTagsGet operation in DefaultApi.
 */
export interface DefaultApiGetBuildTagsV2BuildTagsGetRequest {
    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getColorsV1ColorsGet operation in DefaultApi.
 */
export interface DefaultApiGetColorsV1ColorsGetRequest {
    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getIconsV1IconsGet operation in DefaultApi.
 */
export interface DefaultApiGetIconsV1IconsGetRequest {
    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getMapV1MapGet operation in DefaultApi.
 */
export interface DefaultApiGetMapV1MapGetRequest {
    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getRanksV2RanksGet operation in DefaultApi.
 */
export interface DefaultApiGetRanksV2RanksGetRequest {
    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getSoundsV1SoundsGet operation in DefaultApi.
 */
export interface DefaultApiGetSoundsV1SoundsGetRequest {
    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getSteamInfoV1SteamInfoGet operation in DefaultApi.
 */
export interface DefaultApiGetSteamInfoV1SteamInfoGetRequest {
    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * DefaultApi - object-oriented interface
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get Build Tags
     * @param {DefaultApiGetBuildTagsV2BuildTagsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBuildTagsV2BuildTagsGet(requestParameters: DefaultApiGetBuildTagsV2BuildTagsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getBuildTagsV2BuildTagsGet(requestParameters.language, requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Client Versions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClientVersionsV2ClientVersionsGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getClientVersionsV2ClientVersionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Colors
     * @param {DefaultApiGetColorsV1ColorsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getColorsV1ColorsGet(requestParameters: DefaultApiGetColorsV1ColorsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getColorsV1ColorsGet(requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Icons
     * @param {DefaultApiGetIconsV1IconsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getIconsV1IconsGet(requestParameters: DefaultApiGetIconsV1IconsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getIconsV1IconsGet(requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Map
     * @param {DefaultApiGetMapV1MapGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getMapV1MapGet(requestParameters: DefaultApiGetMapV1MapGetRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getMapV1MapGet(requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Ranks
     * @param {DefaultApiGetRanksV2RanksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRanksV2RanksGet(requestParameters: DefaultApiGetRanksV2RanksGetRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRanksV2RanksGet(requestParameters.language, requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sounds
     * @param {DefaultApiGetSoundsV1SoundsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSoundsV1SoundsGet(requestParameters: DefaultApiGetSoundsV1SoundsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSoundsV1SoundsGet(requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Steam Info
     * @param {DefaultApiGetSteamInfoV1SteamInfoGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSteamInfoV1SteamInfoGet(requestParameters: DefaultApiGetSteamInfoV1SteamInfoGetRequest = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSteamInfoV1SteamInfoGet(requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HeroesApi - axios parameter creator
 */
export const HeroesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Hero By Name
         * @param {string} name 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeroByNameV2HeroesByNameNameGet: async (name: string, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('getHeroByNameV2HeroesByNameNameGet', 'name', name)
            const localVarPath = `/v2/heroes/by-name/{name}`
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Hero
         * @param {number} id 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeroV2HeroesIdGet: async (id: number, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getHeroV2HeroesIdGet', 'id', id)
            const localVarPath = `/v2/heroes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Heroes
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {boolean | null} [onlyActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeroesV2HeroesGet: async (language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, onlyActive?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/heroes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }

            if (onlyActive !== undefined) {
                localVarQueryParameter['only_active'] = onlyActive;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HeroesApi - functional programming interface
 */
export const HeroesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HeroesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Hero By Name
         * @param {string} name 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHeroByNameV2HeroesByNameNameGet(name: string, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HeroV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHeroByNameV2HeroesByNameNameGet(name, language, clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HeroesApi.getHeroByNameV2HeroesByNameNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Hero
         * @param {number} id 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHeroV2HeroesIdGet(id: number, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HeroV2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHeroV2HeroesIdGet(id, language, clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HeroesApi.getHeroV2HeroesIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Heroes
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {boolean | null} [onlyActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHeroesV2HeroesGet(language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, onlyActive?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HeroV2>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHeroesV2HeroesGet(language, clientVersion, onlyActive, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HeroesApi.getHeroesV2HeroesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HeroesApi - factory interface
 */
export const HeroesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HeroesApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Hero By Name
         * @param {HeroesApiGetHeroByNameV2HeroesByNameNameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeroByNameV2HeroesByNameNameGet(requestParameters: HeroesApiGetHeroByNameV2HeroesByNameNameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<HeroV2> {
            return localVarFp.getHeroByNameV2HeroesByNameNameGet(requestParameters.name, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Hero
         * @param {HeroesApiGetHeroV2HeroesIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeroV2HeroesIdGet(requestParameters: HeroesApiGetHeroV2HeroesIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<HeroV2> {
            return localVarFp.getHeroV2HeroesIdGet(requestParameters.id, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Heroes
         * @param {HeroesApiGetHeroesV2HeroesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHeroesV2HeroesGet(requestParameters: HeroesApiGetHeroesV2HeroesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<HeroV2>> {
            return localVarFp.getHeroesV2HeroesGet(requestParameters.language, requestParameters.clientVersion, requestParameters.onlyActive, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getHeroByNameV2HeroesByNameNameGet operation in HeroesApi.
 */
export interface HeroesApiGetHeroByNameV2HeroesByNameNameGetRequest {
    readonly name: string

    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getHeroV2HeroesIdGet operation in HeroesApi.
 */
export interface HeroesApiGetHeroV2HeroesIdGetRequest {
    readonly id: number

    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getHeroesV2HeroesGet operation in HeroesApi.
 */
export interface HeroesApiGetHeroesV2HeroesGetRequest {
    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null

    readonly onlyActive?: boolean | null
}

/**
 * HeroesApi - object-oriented interface
 */
export class HeroesApi extends BaseAPI {
    /**
     * 
     * @summary Get Hero By Name
     * @param {HeroesApiGetHeroByNameV2HeroesByNameNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHeroByNameV2HeroesByNameNameGet(requestParameters: HeroesApiGetHeroByNameV2HeroesByNameNameGetRequest, options?: RawAxiosRequestConfig) {
        return HeroesApiFp(this.configuration).getHeroByNameV2HeroesByNameNameGet(requestParameters.name, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Hero
     * @param {HeroesApiGetHeroV2HeroesIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHeroV2HeroesIdGet(requestParameters: HeroesApiGetHeroV2HeroesIdGetRequest, options?: RawAxiosRequestConfig) {
        return HeroesApiFp(this.configuration).getHeroV2HeroesIdGet(requestParameters.id, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Heroes
     * @param {HeroesApiGetHeroesV2HeroesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getHeroesV2HeroesGet(requestParameters: HeroesApiGetHeroesV2HeroesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return HeroesApiFp(this.configuration).getHeroesV2HeroesGet(requestParameters.language, requestParameters.clientVersion, requestParameters.onlyActive, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemsApi - axios parameter creator
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Item
         * @param {string} idOrClassName 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemV2ItemsIdOrClassNameGet: async (idOrClassName: string, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idOrClassName' is not null or undefined
            assertParamExists('getItemV2ItemsIdOrClassNameGet', 'idOrClassName', idOrClassName)
            const localVarPath = `/v2/items/{id_or_class_name}`
                .replace(`{${"id_or_class_name"}}`, encodeURIComponent(String(idOrClassName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Items By Hero Id
         * @param {number} id 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByHeroIdV2ItemsByHeroIdIdGet: async (id: number, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getItemsByHeroIdV2ItemsByHeroIdIdGet', 'id', id)
            const localVarPath = `/v2/items/by-hero-id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Items By Slot Type
         * @param {ItemSlotTypeV2} slotType 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet: async (slotType: ItemSlotTypeV2, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slotType' is not null or undefined
            assertParamExists('getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet', 'slotType', slotType)
            const localVarPath = `/v2/items/by-slot-type/{slot_type}`
                .replace(`{${"slot_type"}}`, encodeURIComponent(String(slotType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Items By Type
         * @param {ItemTypeV2} type 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByTypeV2ItemsByTypeTypeGet: async (type: ItemTypeV2, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getItemsByTypeV2ItemsByTypeTypeGet', 'type', type)
            const localVarPath = `/v2/items/by-type/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Items
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsV2ItemsGet: async (language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Item
         * @param {string} idOrClassName 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemV2ItemsIdOrClassNameGet(idOrClassName: string, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseGetItemV2ItemsIdOrClassNameGet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemV2ItemsIdOrClassNameGet(idOrClassName, language, clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemV2ItemsIdOrClassNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Items By Hero Id
         * @param {number} id 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByHeroIdV2ItemsByHeroIdIdGet(id: number, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetItemsV2ItemsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsByHeroIdV2ItemsByHeroIdIdGet(id, language, clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemsByHeroIdV2ItemsByHeroIdIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Items By Slot Type
         * @param {ItemSlotTypeV2} slotType 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet(slotType: ItemSlotTypeV2, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetItemsV2ItemsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet(slotType, language, clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Items By Type
         * @param {ItemTypeV2} type 
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsByTypeV2ItemsByTypeTypeGet(type: ItemTypeV2, language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetItemsV2ItemsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsByTypeV2ItemsByTypeTypeGet(type, language, clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemsByTypeV2ItemsByTypeTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Items
         * @param {Language | null} [language] 
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemsV2ItemsGet(language?: Language | null, clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetItemsV2ItemsGet200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemsV2ItemsGet(language, clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemsApi.getItemsV2ItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemsApi - factory interface
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Item
         * @param {ItemsApiGetItemV2ItemsIdOrClassNameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemV2ItemsIdOrClassNameGet(requestParameters: ItemsApiGetItemV2ItemsIdOrClassNameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResponseGetItemV2ItemsIdOrClassNameGet> {
            return localVarFp.getItemV2ItemsIdOrClassNameGet(requestParameters.idOrClassName, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Items By Hero Id
         * @param {ItemsApiGetItemsByHeroIdV2ItemsByHeroIdIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByHeroIdV2ItemsByHeroIdIdGet(requestParameters: ItemsApiGetItemsByHeroIdV2ItemsByHeroIdIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetItemsV2ItemsGet200ResponseInner>> {
            return localVarFp.getItemsByHeroIdV2ItemsByHeroIdIdGet(requestParameters.id, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Items By Slot Type
         * @param {ItemsApiGetItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet(requestParameters: ItemsApiGetItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetItemsV2ItemsGet200ResponseInner>> {
            return localVarFp.getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet(requestParameters.slotType, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Items By Type
         * @param {ItemsApiGetItemsByTypeV2ItemsByTypeTypeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsByTypeV2ItemsByTypeTypeGet(requestParameters: ItemsApiGetItemsByTypeV2ItemsByTypeTypeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetItemsV2ItemsGet200ResponseInner>> {
            return localVarFp.getItemsByTypeV2ItemsByTypeTypeGet(requestParameters.type, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Items
         * @param {ItemsApiGetItemsV2ItemsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemsV2ItemsGet(requestParameters: ItemsApiGetItemsV2ItemsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<GetItemsV2ItemsGet200ResponseInner>> {
            return localVarFp.getItemsV2ItemsGet(requestParameters.language, requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getItemV2ItemsIdOrClassNameGet operation in ItemsApi.
 */
export interface ItemsApiGetItemV2ItemsIdOrClassNameGetRequest {
    readonly idOrClassName: string

    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getItemsByHeroIdV2ItemsByHeroIdIdGet operation in ItemsApi.
 */
export interface ItemsApiGetItemsByHeroIdV2ItemsByHeroIdIdGetRequest {
    readonly id: number

    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet operation in ItemsApi.
 */
export interface ItemsApiGetItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGetRequest {
    readonly slotType: ItemSlotTypeV2

    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getItemsByTypeV2ItemsByTypeTypeGet operation in ItemsApi.
 */
export interface ItemsApiGetItemsByTypeV2ItemsByTypeTypeGetRequest {
    readonly type: ItemTypeV2

    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getItemsV2ItemsGet operation in ItemsApi.
 */
export interface ItemsApiGetItemsV2ItemsGetRequest {
    readonly language?: Language | null

    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * ItemsApi - object-oriented interface
 */
export class ItemsApi extends BaseAPI {
    /**
     * 
     * @summary Get Item
     * @param {ItemsApiGetItemV2ItemsIdOrClassNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getItemV2ItemsIdOrClassNameGet(requestParameters: ItemsApiGetItemV2ItemsIdOrClassNameGetRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemV2ItemsIdOrClassNameGet(requestParameters.idOrClassName, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Items By Hero Id
     * @param {ItemsApiGetItemsByHeroIdV2ItemsByHeroIdIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getItemsByHeroIdV2ItemsByHeroIdIdGet(requestParameters: ItemsApiGetItemsByHeroIdV2ItemsByHeroIdIdGetRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemsByHeroIdV2ItemsByHeroIdIdGet(requestParameters.id, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Items By Slot Type
     * @param {ItemsApiGetItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet(requestParameters: ItemsApiGetItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGetRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemsBySlotTypeV2ItemsBySlotTypeSlotTypeGet(requestParameters.slotType, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Items By Type
     * @param {ItemsApiGetItemsByTypeV2ItemsByTypeTypeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getItemsByTypeV2ItemsByTypeTypeGet(requestParameters: ItemsApiGetItemsByTypeV2ItemsByTypeTypeGetRequest, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemsByTypeV2ItemsByTypeTypeGet(requestParameters.type, requestParameters.language, requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Items
     * @param {ItemsApiGetItemsV2ItemsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getItemsV2ItemsGet(requestParameters: ItemsApiGetItemsV2ItemsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemsV2ItemsGet(requestParameters.language, requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RawApi - axios parameter creator
 */
export const RawApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Generic Data
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenericDataRawGenericDataGet: async (clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/raw/generic_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Raw Heroes
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawHeroesRawHeroesGet: async (clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/raw/heroes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Raw Items
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawItemsRawItemsGet: async (clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/raw/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientVersion !== undefined) {
                localVarQueryParameter['client_version'] = clientVersion;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RawApi - functional programming interface
 */
export const RawApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RawApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Generic Data
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenericDataRawGenericDataGet(clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGenericDataRawGenericDataGet(clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RawApi.getGenericDataRawGenericDataGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Raw Heroes
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawHeroesRawHeroesGet(clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawHeroesRawHeroesGet(clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RawApi.getRawHeroesRawHeroesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Raw Items
         * @param {DeadlockAssetsApiRoutesRawValidClientVersions | null} [clientVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRawItemsRawItemsGet(clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRawItemsRawItemsGet(clientVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RawApi.getRawItemsRawItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RawApi - factory interface
 */
export const RawApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RawApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Generic Data
         * @param {RawApiGetGenericDataRawGenericDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenericDataRawGenericDataGet(requestParameters: RawApiGetGenericDataRawGenericDataGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getGenericDataRawGenericDataGet(requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Raw Heroes
         * @param {RawApiGetRawHeroesRawHeroesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawHeroesRawHeroesGet(requestParameters: RawApiGetRawHeroesRawHeroesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getRawHeroesRawHeroesGet(requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Raw Items
         * @param {RawApiGetRawItemsRawItemsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRawItemsRawItemsGet(requestParameters: RawApiGetRawItemsRawItemsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.getRawItemsRawItemsGet(requestParameters.clientVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGenericDataRawGenericDataGet operation in RawApi.
 */
export interface RawApiGetGenericDataRawGenericDataGetRequest {
    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getRawHeroesRawHeroesGet operation in RawApi.
 */
export interface RawApiGetRawHeroesRawHeroesGetRequest {
    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * Request parameters for getRawItemsRawItemsGet operation in RawApi.
 */
export interface RawApiGetRawItemsRawItemsGetRequest {
    readonly clientVersion?: DeadlockAssetsApiRoutesRawValidClientVersions | null
}

/**
 * RawApi - object-oriented interface
 */
export class RawApi extends BaseAPI {
    /**
     * 
     * @summary Get Generic Data
     * @param {RawApiGetGenericDataRawGenericDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getGenericDataRawGenericDataGet(requestParameters: RawApiGetGenericDataRawGenericDataGetRequest = {}, options?: RawAxiosRequestConfig) {
        return RawApiFp(this.configuration).getGenericDataRawGenericDataGet(requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Raw Heroes
     * @param {RawApiGetRawHeroesRawHeroesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRawHeroesRawHeroesGet(requestParameters: RawApiGetRawHeroesRawHeroesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return RawApiFp(this.configuration).getRawHeroesRawHeroesGet(requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Raw Items
     * @param {RawApiGetRawItemsRawItemsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRawItemsRawItemsGet(requestParameters: RawApiGetRawItemsRawItemsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return RawApiFp(this.configuration).getRawItemsRawItemsGet(requestParameters.clientVersion, options).then((request) => request(this.axios, this.basePath));
    }
}



