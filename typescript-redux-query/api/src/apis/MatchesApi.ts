// tslint:disable
/**
 * Deadlock API
 *  ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you\'re building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    ActiveMatch,
    ActiveMatchFromJSON,
    ActiveMatchToJSON,
    ClickhouseMatchInfo,
    ClickhouseMatchInfoFromJSON,
    ClickhouseMatchInfoToJSON,
    MatchSaltsResponse,
    MatchSaltsResponseFromJSON,
    MatchSaltsResponseToJSON,
    MatchSpectateResponse,
    MatchSpectateResponseFromJSON,
    MatchSpectateResponseToJSON,
} from '../models';

export interface ActiveMatchesRequest {
    accountId?: number;
    accountIds?: Array<number>;
}

export interface BulkMetadataRequest {
    includeInfo?: boolean;
    includeObjectives?: boolean;
    includeMidBoss?: boolean;
    includePlayerInfo?: boolean;
    includePlayerItems?: boolean;
    includePlayerStats?: boolean;
    includePlayerDeathDetails?: boolean;
    gameMode?: BulkMetadataGameModeEnum;
    matchIds?: Array<number>;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    isHighSkillRangeParties?: boolean;
    isLowPriPool?: boolean;
    isNewPlayerPool?: boolean;
    accountIds?: Array<number>;
    heroIds?: string;
    orderBy?: BulkMetadataOrderByEnum;
    orderDirection?: BulkMetadataOrderDirectionEnum;
    limit?: number;
}

export interface MetadataRequest {
    matchId: number;
    isCustom?: boolean;
}

export interface MetadataRawRequest {
    matchId: number;
    isCustom?: boolean;
}

export interface RecentlyFetchedRequest {
    playerIngestedOnly?: boolean;
}

export interface SaltsRequest {
    matchId: number;
}

export interface UrlRequest {
    matchId: number;
}


/**
 *  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Active
 */
function activeMatchesRaw<T>(requestParameters: ActiveMatchesRequest, requestConfig: runtime.TypedQueryConfig<T, Array<ActiveMatch>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.accountId !== undefined) {
        queryParameters['account_id'] = requestParameters.accountId;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/matches/active`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(ActiveMatchFromJSON), text);
    }

    return config;
}

/**
*  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Active
*/
export function activeMatches<T>(requestParameters: ActiveMatchesRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<ActiveMatch>>): QueryConfig<T> {
    return activeMatchesRaw(requestParameters, requestConfig);
}

/**
 *  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Active as Protobuf
 */
function activeMatchesRawRaw<T>( requestConfig: runtime.TypedQueryConfig<T, Array<number>> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/matches/active/raw`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Active as Protobuf
*/
export function activeMatchesRaw<T>( requestConfig?: runtime.TypedQueryConfig<T, Array<number>>): QueryConfig<T> {
    return activeMatchesRawRaw( requestConfig);
}

/**
 *  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
 * Bulk Metadata
 */
function bulkMetadataRaw<T>(requestParameters: BulkMetadataRequest, requestConfig: runtime.TypedQueryConfig<T, Array<number>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.includeInfo !== undefined) {
        queryParameters['include_info'] = requestParameters.includeInfo;
    }


    if (requestParameters.includeObjectives !== undefined) {
        queryParameters['include_objectives'] = requestParameters.includeObjectives;
    }


    if (requestParameters.includeMidBoss !== undefined) {
        queryParameters['include_mid_boss'] = requestParameters.includeMidBoss;
    }


    if (requestParameters.includePlayerInfo !== undefined) {
        queryParameters['include_player_info'] = requestParameters.includePlayerInfo;
    }


    if (requestParameters.includePlayerItems !== undefined) {
        queryParameters['include_player_items'] = requestParameters.includePlayerItems;
    }


    if (requestParameters.includePlayerStats !== undefined) {
        queryParameters['include_player_stats'] = requestParameters.includePlayerStats;
    }


    if (requestParameters.includePlayerDeathDetails !== undefined) {
        queryParameters['include_player_death_details'] = requestParameters.includePlayerDeathDetails;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.matchIds) {
        queryParameters['match_ids'] = requestParameters.matchIds;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.isHighSkillRangeParties !== undefined) {
        queryParameters['is_high_skill_range_parties'] = requestParameters.isHighSkillRangeParties;
    }


    if (requestParameters.isLowPriPool !== undefined) {
        queryParameters['is_low_pri_pool'] = requestParameters.isLowPriPool;
    }


    if (requestParameters.isNewPlayerPool !== undefined) {
        queryParameters['is_new_player_pool'] = requestParameters.isNewPlayerPool;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }


    if (requestParameters.heroIds !== undefined) {
        queryParameters['hero_ids'] = requestParameters.heroIds;
    }


    if (requestParameters.orderBy !== undefined) {
        queryParameters['order_by'] = requestParameters.orderBy;
    }


    if (requestParameters.orderDirection !== undefined) {
        queryParameters['order_direction'] = requestParameters.orderDirection;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/matches/metadata`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
* Bulk Metadata
*/
export function bulkMetadata<T>(requestParameters: BulkMetadataRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<number>>): QueryConfig<T> {
    return bulkMetadataRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
 * Metadata
 */
function metadataRaw<T>(requestParameters: MetadataRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.matchId === null || requestParameters.matchId === undefined) {
        throw new runtime.RequiredError('matchId','Required parameter requestParameters.matchId was null or undefined when calling metadata.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.isCustom !== undefined) {
        queryParameters['is_custom'] = requestParameters.isCustom;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/matches/{match_id}/metadata`.replace(`{${"match_id"}}`, encodeURIComponent(String(requestParameters.matchId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
* Metadata
*/
export function metadata<T>(requestParameters: MetadataRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return metadataRaw(requestParameters, requestConfig);
}

/**
 *  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
 * Metadata as Protobuf
 */
function metadataRawRaw<T>(requestParameters: MetadataRawRequest, requestConfig: runtime.TypedQueryConfig<T, Array<number>> = {}): QueryConfig<T> {
    if (requestParameters.matchId === null || requestParameters.matchId === undefined) {
        throw new runtime.RequiredError('matchId','Required parameter requestParameters.matchId was null or undefined when calling metadataRaw.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.isCustom !== undefined) {
        queryParameters['is_custom'] = requestParameters.isCustom;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/matches/{match_id}/metadata/raw`.replace(`{${"match_id"}}`, encodeURIComponent(String(requestParameters.matchId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
*  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
* Metadata as Protobuf
*/
export function metadataRaw<T>(requestParameters: MetadataRawRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<number>>): QueryConfig<T> {
    return metadataRawRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Recently Fetched
 */
function recentlyFetchedRaw<T>(requestParameters: RecentlyFetchedRequest, requestConfig: runtime.TypedQueryConfig<T, Array<ClickhouseMatchInfo>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.playerIngestedOnly !== undefined) {
        queryParameters['player_ingested_only'] = requestParameters.playerIngestedOnly;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/matches/recently-fetched`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(ClickhouseMatchInfoFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Recently Fetched
*/
export function recentlyFetched<T>(requestParameters: RecentlyFetchedRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<ClickhouseMatchInfo>>): QueryConfig<T> {
    return recentlyFetchedRaw(requestParameters, requestConfig);
}

/**
 *  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
 * Salts
 */
function saltsRaw<T>(requestParameters: SaltsRequest, requestConfig: runtime.TypedQueryConfig<T, MatchSaltsResponse> = {}): QueryConfig<T> {
    if (requestParameters.matchId === null || requestParameters.matchId === undefined) {
        throw new runtime.RequiredError('matchId','Required parameter requestParameters.matchId was null or undefined when calling salts.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/matches/{match_id}/salts`.replace(`{${"match_id"}}`, encodeURIComponent(String(requestParameters.matchId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MatchSaltsResponseFromJSON(body), text);
    }

    return config;
}

/**
*  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
* Salts
*/
export function salts<T>(requestParameters: SaltsRequest, requestConfig?: runtime.TypedQueryConfig<T, MatchSaltsResponse>): QueryConfig<T> {
    return saltsRaw(requestParameters, requestConfig);
}

/**
 *  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
 * Live Broadcast URL
 */
function urlRaw<T>(requestParameters: UrlRequest, requestConfig: runtime.TypedQueryConfig<T, MatchSpectateResponse> = {}): QueryConfig<T> {
    if (requestParameters.matchId === null || requestParameters.matchId === undefined) {
        throw new runtime.RequiredError('matchId','Required parameter requestParameters.matchId was null or undefined when calling url.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/matches/{match_id}/live/url`.replace(`{${"match_id"}}`, encodeURIComponent(String(requestParameters.matchId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MatchSpectateResponseFromJSON(body), text);
    }

    return config;
}

/**
*  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
* Live Broadcast URL
*/
export function url<T>(requestParameters: UrlRequest, requestConfig?: runtime.TypedQueryConfig<T, MatchSpectateResponse>): QueryConfig<T> {
    return urlRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum BulkMetadataGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum BulkMetadataOrderByEnum {
    MatchId = 'match_id',
    StartTime = 'start_time'
}
/**
    * @export
    * @enum {string}
    */
export enum BulkMetadataOrderDirectionEnum {
    Desc = 'desc',
    Asc = 'asc'
}
