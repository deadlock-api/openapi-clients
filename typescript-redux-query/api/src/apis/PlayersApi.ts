// tslint:disable
/**
 * Deadlock API
 *  ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you\'re building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    EnemyStats,
    EnemyStatsFromJSON,
    EnemyStatsToJSON,
    HeroStats,
    HeroStatsFromJSON,
    HeroStatsToJSON,
    MateStats,
    MateStatsFromJSON,
    MateStatsToJSON,
    PartyStats,
    PartyStatsFromJSON,
    PartyStatsToJSON,
    PlayerAccountStats,
    PlayerAccountStatsFromJSON,
    PlayerAccountStatsToJSON,
    PlayerCard,
    PlayerCardFromJSON,
    PlayerCardToJSON,
    PlayerMatchHistoryEntry,
    PlayerMatchHistoryEntryFromJSON,
    PlayerMatchHistoryEntryToJSON,
    SteamProfile,
    SteamProfileFromJSON,
    SteamProfileToJSON,
} from '../models';

export interface AccountStatsRequest {
    accountId: number;
}

export interface CardRequest {
    accountId: number;
}

export interface EnemyStatsRequest {
    accountId: number;
    gameMode?: EnemyStatsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minMatchId?: number;
    maxMatchId?: number;
    minMatchesPlayed?: number;
    maxMatchesPlayed?: number;
}

export interface MatchHistoryRequest {
    accountId: number;
    forceRefetch?: boolean;
    onlyStoredHistory?: boolean;
}

export interface MateStatsRequest {
    accountId: number;
    gameMode?: MateStatsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minMatchId?: number;
    maxMatchId?: number;
    minMatchesPlayed?: number;
    maxMatchesPlayed?: number;
    sameParty?: boolean;
}

export interface PartyStatsRequest {
    accountId: number;
    gameMode?: PartyStatsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minMatchId?: number;
    maxMatchId?: number;
}

export interface PlayerHeroStatsRequest {
    accountIds: Array<number>;
    gameMode?: PlayerHeroStatsGameModeEnum;
    heroIds?: string;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
}

export interface SteamRequest {
    accountIds: Array<number>;
}

export interface SteamSearchRequest {
    searchQuery: string;
}


/**
 *  This endpoint returns the player account stats for the given `account_id`.  !THIS IS A PATREON ONLY ENDPOINT!  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetAccountStats - CMsgAccountStats  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
 * Account Stats
 */
function accountStatsRaw<T>(requestParameters: AccountStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<PlayerAccountStats>> = {}): QueryConfig<T> {
    if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
        throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling accountStats.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/players/{account_id}/account-stats`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(PlayerAccountStatsFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the player account stats for the given `account_id`.  !THIS IS A PATREON ONLY ENDPOINT!  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetAccountStats - CMsgAccountStats  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
* Account Stats
*/
export function accountStats<T>(requestParameters: AccountStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<PlayerAccountStats>>): QueryConfig<T> {
    return accountStatsRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the player card for the given `account_id`.  !THIS IS A PATREON ONLY ENDPOINT!  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
 * Card
 */
function cardRaw<T>(requestParameters: CardRequest, requestConfig: runtime.TypedQueryConfig<T, Array<PlayerCard>> = {}): QueryConfig<T> {
    if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
        throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling card.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/players/{account_id}/card`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(PlayerCardFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the player card for the given `account_id`.  !THIS IS A PATREON ONLY ENDPOINT!  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
* Card
*/
export function card<T>(requestParameters: CardRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<PlayerCard>>): QueryConfig<T> {
    return cardRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Enemy Stats
 */
function enemyStatsRaw<T>(requestParameters: EnemyStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<EnemyStats>> = {}): QueryConfig<T> {
    if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
        throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling enemyStats.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.minMatchesPlayed !== undefined) {
        queryParameters['min_matches_played'] = requestParameters.minMatchesPlayed;
    }


    if (requestParameters.maxMatchesPlayed !== undefined) {
        queryParameters['max_matches_played'] = requestParameters.maxMatchesPlayed;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/players/{account_id}/enemy-stats`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(EnemyStatsFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Enemy Stats
*/
export function enemyStats<T>(requestParameters: EnemyStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<EnemyStats>>): QueryConfig<T> {
    return enemyStatsRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/h<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 400req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
 * Match History
 */
function matchHistoryRaw<T>(requestParameters: MatchHistoryRequest, requestConfig: runtime.TypedQueryConfig<T, Array<PlayerMatchHistoryEntry>> = {}): QueryConfig<T> {
    if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
        throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling matchHistory.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.forceRefetch !== undefined) {
        queryParameters['force_refetch'] = requestParameters.forceRefetch;
    }


    if (requestParameters.onlyStoredHistory !== undefined) {
        queryParameters['only_stored_history'] = requestParameters.onlyStoredHistory;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/players/{account_id}/match-history`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(PlayerMatchHistoryEntryFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/h<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 400req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
* Match History
*/
export function matchHistory<T>(requestParameters: MatchHistoryRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<PlayerMatchHistoryEntry>>): QueryConfig<T> {
    return matchHistoryRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Mate Stats
 */
function mateStatsRaw<T>(requestParameters: MateStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<MateStats>> = {}): QueryConfig<T> {
    if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
        throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling mateStats.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.minMatchesPlayed !== undefined) {
        queryParameters['min_matches_played'] = requestParameters.minMatchesPlayed;
    }


    if (requestParameters.maxMatchesPlayed !== undefined) {
        queryParameters['max_matches_played'] = requestParameters.maxMatchesPlayed;
    }


    if (requestParameters.sameParty !== undefined) {
        queryParameters['same_party'] = requestParameters.sameParty;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/players/{account_id}/mate-stats`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(MateStatsFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Mate Stats
*/
export function mateStats<T>(requestParameters: MateStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<MateStats>>): QueryConfig<T> {
    return mateStatsRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Party Stats
 */
function partyStatsRaw<T>(requestParameters: PartyStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<PartyStats>> = {}): QueryConfig<T> {
    if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
        throw new runtime.RequiredError('accountId','Required parameter requestParameters.accountId was null or undefined when calling partyStats.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/players/{account_id}/party-stats`.replace(`{${"account_id"}}`, encodeURIComponent(String(requestParameters.accountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(PartyStatsFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Party Stats
*/
export function partyStats<T>(requestParameters: PartyStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<PartyStats>>): QueryConfig<T> {
    return partyStatsRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Hero Stats
 */
function playerHeroStatsRaw<T>(requestParameters: PlayerHeroStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<HeroStats>> = {}): QueryConfig<T> {
    if (requestParameters.accountIds === null || requestParameters.accountIds === undefined) {
        throw new runtime.RequiredError('accountIds','Required parameter requestParameters.accountIds was null or undefined when calling playerHeroStats.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.heroIds !== undefined) {
        queryParameters['hero_ids'] = requestParameters.heroIds;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/players/hero-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(HeroStatsFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Hero Stats
*/
export function playerHeroStats<T>(requestParameters: PlayerHeroStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<HeroStats>>): QueryConfig<T> {
    return playerHeroStatsRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Batch Steam Profile
 */
function steamRaw<T>(requestParameters: SteamRequest, requestConfig: runtime.TypedQueryConfig<T, Array<SteamProfile>> = {}): QueryConfig<T> {
    if (requestParameters.accountIds === null || requestParameters.accountIds === undefined) {
        throw new runtime.RequiredError('accountIds','Required parameter requestParameters.accountIds was null or undefined when calling steam.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/players/steam`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(SteamProfileFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Batch Steam Profile
*/
export function steam<T>(requestParameters: SteamRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<SteamProfile>>): QueryConfig<T> {
    return steamRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Steam Profile Search
 */
function steamSearchRaw<T>(requestParameters: SteamSearchRequest, requestConfig: runtime.TypedQueryConfig<T, Array<SteamProfile>> = {}): QueryConfig<T> {
    if (requestParameters.searchQuery === null || requestParameters.searchQuery === undefined) {
        throw new runtime.RequiredError('searchQuery','Required parameter requestParameters.searchQuery was null or undefined when calling steamSearch.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.searchQuery !== undefined) {
        queryParameters['search_query'] = requestParameters.searchQuery;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/players/steam-search`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(SteamProfileFromJSON), text);
    }

    return config;
}

/**
*  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Steam Profile Search
*/
export function steamSearch<T>(requestParameters: SteamSearchRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<SteamProfile>>): QueryConfig<T> {
    return steamSearchRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum EnemyStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum MateStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum PartyStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum PlayerHeroStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
