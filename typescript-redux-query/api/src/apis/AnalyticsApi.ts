// tslint:disable
/**
 * Deadlock API
 *  ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you\'re building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    AnalyticsAbilityOrderStats,
    AnalyticsAbilityOrderStatsFromJSON,
    AnalyticsAbilityOrderStatsToJSON,
    AnalyticsHeroStats,
    AnalyticsHeroStatsFromJSON,
    AnalyticsHeroStatsToJSON,
    BadgeDistribution,
    BadgeDistributionFromJSON,
    BadgeDistributionToJSON,
    BuildItemStats,
    BuildItemStatsFromJSON,
    BuildItemStatsToJSON,
    Entry,
    EntryFromJSON,
    EntryToJSON,
    HashMapValue,
    HashMapValueFromJSON,
    HashMapValueToJSON,
    HeroCombStats,
    HeroCombStatsFromJSON,
    HeroCombStatsToJSON,
    HeroCounterStats,
    HeroCounterStatsFromJSON,
    HeroCounterStatsToJSON,
    HeroSynergyStats,
    HeroSynergyStatsFromJSON,
    HeroSynergyStatsToJSON,
    ItemPermutationStats,
    ItemPermutationStatsFromJSON,
    ItemPermutationStatsToJSON,
    ItemStats,
    ItemStatsFromJSON,
    ItemStatsToJSON,
    KillDeathStats,
    KillDeathStatsFromJSON,
    KillDeathStatsToJSON,
    PlayerPerformanceCurvePoint,
    PlayerPerformanceCurvePointFromJSON,
    PlayerPerformanceCurvePointToJSON,
} from '../models';

export interface AbilityOrderStatsRequest {
    heroId: number;
    gameMode?: AbilityOrderStatsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minAbilityUpgrades?: number;
    maxAbilityUpgrades?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    minMatches?: number;
    accountId?: number;
    accountIds?: Array<number>;
}

export interface BadgeDistributionRequest {
    gameMode?: BadgeDistributionGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    isHighSkillRangeParties?: boolean;
    isLowPriPool?: boolean;
    isNewPlayerPool?: boolean;
    minMatchId?: number;
    maxMatchId?: number;
}

export interface BuildItemStatsRequest {
    heroId?: number;
    minLastUpdatedUnixTimestamp?: number;
    maxLastUpdatedUnixTimestamp?: number;
}

export interface HeroCombStatsRequest {
    gameMode?: HeroCombStatsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    includeHeroIds?: Array<number>;
    excludeHeroIds?: Array<number>;
    minMatches?: number;
    maxMatches?: number;
    combSize?: number;
    accountId?: number;
    accountIds?: Array<number>;
}

export interface HeroCountersStatsRequest {
    gameMode?: HeroCountersStatsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minEnemyNetworth?: number;
    maxEnemyNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    sameLaneFilter?: boolean;
    minMatches?: number;
    maxMatches?: number;
    accountId?: number;
    accountIds?: Array<number>;
}

export interface HeroScoreboardRequest {
    sortBy: HeroScoreboardSortByEnum;
    sortDirection?: HeroScoreboardSortDirectionEnum;
    gameMode?: HeroScoreboardGameModeEnum;
    minMatches?: number;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    accountId?: number;
    accountIds?: Array<number>;
}

export interface HeroStatsRequest {
    bucket?: HeroStatsBucketEnum;
    gameMode?: HeroStatsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    minHeroMatches?: number;
    maxHeroMatches?: number;
    minHeroMatchesTotal?: number;
    maxHeroMatchesTotal?: number;
    includeItemIds?: Array<number>;
    excludeItemIds?: Array<number>;
    accountId?: number;
    accountIds?: Array<number>;
}

export interface HeroSynergiesStatsRequest {
    gameMode?: HeroSynergiesStatsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    sameLaneFilter?: boolean;
    samePartyFilter?: boolean;
    minMatches?: number;
    maxMatches?: number;
    accountId?: number;
    accountIds?: Array<number>;
}

export interface ItemPermutationStatsRequest {
    itemIds?: Array<number>;
    combSize?: number;
    gameMode?: ItemPermutationStatsGameModeEnum;
    heroIds?: string;
    heroId?: number;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    accountId?: number;
    accountIds?: Array<number>;
}

export interface ItemStatsRequest {
    bucket?: ItemStatsBucketEnum;
    gameMode?: ItemStatsGameModeEnum;
    heroIds?: string;
    heroId?: number;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    includeItemIds?: Array<number>;
    excludeItemIds?: Array<number>;
    minMatches?: number;
    maxMatches?: number;
    accountId?: number;
    accountIds?: Array<number>;
    minBoughtAtS?: number;
    maxBoughtAtS?: number;
}

export interface KillDeathStatsRequest {
    team?: number;
    gameMode?: KillDeathStatsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    accountIds?: Array<number>;
    heroIds?: string;
    minNetworth?: number;
    maxNetworth?: number;
    isHighSkillRangeParties?: boolean;
    isLowPriPool?: boolean;
    isNewPlayerPool?: boolean;
    minMatchId?: number;
    maxMatchId?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minKillsPerRaster?: number;
    maxKillsPerRaster?: number;
    minDeathsPerRaster?: number;
    maxDeathsPerRaster?: number;
    minGameTimeS?: number;
    maxGameTimeS?: number;
}

export interface PlayerPerformanceCurveRequest {
    resolution?: number;
    gameMode?: PlayerPerformanceCurveGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    heroIds?: string;
    includeItemIds?: Array<number>;
    excludeItemIds?: Array<number>;
    accountIds?: Array<number>;
}

export interface PlayerScoreboardRequest {
    sortBy: PlayerScoreboardSortByEnum;
    sortDirection?: PlayerScoreboardSortDirectionEnum;
    gameMode?: PlayerScoreboardGameModeEnum;
    heroId?: number;
    minMatches?: number;
    maxMatches?: number;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    start?: number;
    limit?: number;
    accountIds?: Array<number>;
}

export interface PlayerStatsMetricsRequest {
    heroIds?: string;
    gameMode?: PlayerStatsMetricsGameModeEnum;
    minUnixTimestamp?: number;
    maxUnixTimestamp?: number;
    minDurationS?: number;
    maxDurationS?: number;
    minNetworth?: number;
    maxNetworth?: number;
    minAverageBadge?: number;
    maxAverageBadge?: number;
    minMatchId?: number;
    maxMatchId?: number;
    maxMatches?: number;
    includeItemIds?: Array<number>;
    excludeItemIds?: Array<number>;
    accountIds?: Array<number>;
}


/**
 *  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Ability Order Stats
 */
function abilityOrderStatsRaw<T>(requestParameters: AbilityOrderStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<AnalyticsAbilityOrderStats>> = {}): QueryConfig<T> {
    if (requestParameters.heroId === null || requestParameters.heroId === undefined) {
        throw new runtime.RequiredError('heroId','Required parameter requestParameters.heroId was null or undefined when calling abilityOrderStats.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.heroId !== undefined) {
        queryParameters['hero_id'] = requestParameters.heroId;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minAbilityUpgrades !== undefined) {
        queryParameters['min_ability_upgrades'] = requestParameters.minAbilityUpgrades;
    }


    if (requestParameters.maxAbilityUpgrades !== undefined) {
        queryParameters['max_ability_upgrades'] = requestParameters.maxAbilityUpgrades;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.minMatches !== undefined) {
        queryParameters['min_matches'] = requestParameters.minMatches;
    }


    if (requestParameters.accountId !== undefined) {
        queryParameters['account_id'] = requestParameters.accountId;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/ability-order-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(AnalyticsAbilityOrderStatsFromJSON), text);
    }

    return config;
}

/**
*  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Ability Order Stats
*/
export function abilityOrderStats<T>(requestParameters: AbilityOrderStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<AnalyticsAbilityOrderStats>>): QueryConfig<T> {
    return abilityOrderStatsRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Badge Distribution
 */
function badgeDistributionRaw<T>(requestParameters: BadgeDistributionRequest, requestConfig: runtime.TypedQueryConfig<T, Array<BadgeDistribution>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.isHighSkillRangeParties !== undefined) {
        queryParameters['is_high_skill_range_parties'] = requestParameters.isHighSkillRangeParties;
    }


    if (requestParameters.isLowPriPool !== undefined) {
        queryParameters['is_low_pri_pool'] = requestParameters.isLowPriPool;
    }


    if (requestParameters.isNewPlayerPool !== undefined) {
        queryParameters['is_new_player_pool'] = requestParameters.isNewPlayerPool;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/badge-distribution`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(BadgeDistributionFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Badge Distribution
*/
export function badgeDistribution<T>(requestParameters: BadgeDistributionRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<BadgeDistribution>>): QueryConfig<T> {
    return badgeDistributionRaw(requestParameters, requestConfig);
}

/**
 *  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Build Item Stats
 */
function buildItemStatsRaw<T>(requestParameters: BuildItemStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<BuildItemStats>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.heroId !== undefined) {
        queryParameters['hero_id'] = requestParameters.heroId;
    }


    if (requestParameters.minLastUpdatedUnixTimestamp !== undefined) {
        queryParameters['min_last_updated_unix_timestamp'] = requestParameters.minLastUpdatedUnixTimestamp;
    }


    if (requestParameters.maxLastUpdatedUnixTimestamp !== undefined) {
        queryParameters['max_last_updated_unix_timestamp'] = requestParameters.maxLastUpdatedUnixTimestamp;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/build-item-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(BuildItemStatsFromJSON), text);
    }

    return config;
}

/**
*  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Build Item Stats
*/
export function buildItemStats<T>(requestParameters: BuildItemStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<BuildItemStats>>): QueryConfig<T> {
    return buildItemStatsRaw(requestParameters, requestConfig);
}

/**
 *  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Hero Comb Stats
 */
function heroCombStatsRaw<T>(requestParameters: HeroCombStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<HeroCombStats>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.includeHeroIds) {
        queryParameters['include_hero_ids'] = requestParameters.includeHeroIds;
    }


    if (requestParameters.excludeHeroIds) {
        queryParameters['exclude_hero_ids'] = requestParameters.excludeHeroIds;
    }


    if (requestParameters.minMatches !== undefined) {
        queryParameters['min_matches'] = requestParameters.minMatches;
    }


    if (requestParameters.maxMatches !== undefined) {
        queryParameters['max_matches'] = requestParameters.maxMatches;
    }


    if (requestParameters.combSize !== undefined) {
        queryParameters['comb_size'] = requestParameters.combSize;
    }


    if (requestParameters.accountId !== undefined) {
        queryParameters['account_id'] = requestParameters.accountId;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/hero-comb-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(HeroCombStatsFromJSON), text);
    }

    return config;
}

/**
*  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Hero Comb Stats
*/
export function heroCombStats<T>(requestParameters: HeroCombStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<HeroCombStats>>): QueryConfig<T> {
    return heroCombStatsRaw(requestParameters, requestConfig);
}

/**
 *  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Hero Counter Stats
 */
function heroCountersStatsRaw<T>(requestParameters: HeroCountersStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<HeroCounterStats>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minEnemyNetworth !== undefined) {
        queryParameters['min_enemy_networth'] = requestParameters.minEnemyNetworth;
    }


    if (requestParameters.maxEnemyNetworth !== undefined) {
        queryParameters['max_enemy_networth'] = requestParameters.maxEnemyNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.sameLaneFilter !== undefined) {
        queryParameters['same_lane_filter'] = requestParameters.sameLaneFilter;
    }


    if (requestParameters.minMatches !== undefined) {
        queryParameters['min_matches'] = requestParameters.minMatches;
    }


    if (requestParameters.maxMatches !== undefined) {
        queryParameters['max_matches'] = requestParameters.maxMatches;
    }


    if (requestParameters.accountId !== undefined) {
        queryParameters['account_id'] = requestParameters.accountId;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/hero-counter-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(HeroCounterStatsFromJSON), text);
    }

    return config;
}

/**
*  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Hero Counter Stats
*/
export function heroCountersStats<T>(requestParameters: HeroCountersStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<HeroCounterStats>>): QueryConfig<T> {
    return heroCountersStatsRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Hero Scoreboard
 */
function heroScoreboardRaw<T>(requestParameters: HeroScoreboardRequest, requestConfig: runtime.TypedQueryConfig<T, Array<Entry>> = {}): QueryConfig<T> {
    if (requestParameters.sortBy === null || requestParameters.sortBy === undefined) {
        throw new runtime.RequiredError('sortBy','Required parameter requestParameters.sortBy was null or undefined when calling heroScoreboard.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.sortBy !== undefined) {
        queryParameters['sort_by'] = requestParameters.sortBy;
    }


    if (requestParameters.sortDirection !== undefined) {
        queryParameters['sort_direction'] = requestParameters.sortDirection;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minMatches !== undefined) {
        queryParameters['min_matches'] = requestParameters.minMatches;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.accountId !== undefined) {
        queryParameters['account_id'] = requestParameters.accountId;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/scoreboards/heroes`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(EntryFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Hero Scoreboard
*/
export function heroScoreboard<T>(requestParameters: HeroScoreboardRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<Entry>>): QueryConfig<T> {
    return heroScoreboardRaw(requestParameters, requestConfig);
}

/**
 *  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Hero Stats
 */
function heroStatsRaw<T>(requestParameters: HeroStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<AnalyticsHeroStats>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.bucket !== undefined) {
        queryParameters['bucket'] = requestParameters.bucket;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.minHeroMatches !== undefined) {
        queryParameters['min_hero_matches'] = requestParameters.minHeroMatches;
    }


    if (requestParameters.maxHeroMatches !== undefined) {
        queryParameters['max_hero_matches'] = requestParameters.maxHeroMatches;
    }


    if (requestParameters.minHeroMatchesTotal !== undefined) {
        queryParameters['min_hero_matches_total'] = requestParameters.minHeroMatchesTotal;
    }


    if (requestParameters.maxHeroMatchesTotal !== undefined) {
        queryParameters['max_hero_matches_total'] = requestParameters.maxHeroMatchesTotal;
    }


    if (requestParameters.includeItemIds) {
        queryParameters['include_item_ids'] = requestParameters.includeItemIds;
    }


    if (requestParameters.excludeItemIds) {
        queryParameters['exclude_item_ids'] = requestParameters.excludeItemIds;
    }


    if (requestParameters.accountId !== undefined) {
        queryParameters['account_id'] = requestParameters.accountId;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/hero-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(AnalyticsHeroStatsFromJSON), text);
    }

    return config;
}

/**
*  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Hero Stats
*/
export function heroStats<T>(requestParameters: HeroStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<AnalyticsHeroStats>>): QueryConfig<T> {
    return heroStatsRaw(requestParameters, requestConfig);
}

/**
 *  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Hero Synergy Stats
 */
function heroSynergiesStatsRaw<T>(requestParameters: HeroSynergiesStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<HeroSynergyStats>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.sameLaneFilter !== undefined) {
        queryParameters['same_lane_filter'] = requestParameters.sameLaneFilter;
    }


    if (requestParameters.samePartyFilter !== undefined) {
        queryParameters['same_party_filter'] = requestParameters.samePartyFilter;
    }


    if (requestParameters.minMatches !== undefined) {
        queryParameters['min_matches'] = requestParameters.minMatches;
    }


    if (requestParameters.maxMatches !== undefined) {
        queryParameters['max_matches'] = requestParameters.maxMatches;
    }


    if (requestParameters.accountId !== undefined) {
        queryParameters['account_id'] = requestParameters.accountId;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/hero-synergy-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(HeroSynergyStatsFromJSON), text);
    }

    return config;
}

/**
*  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Hero Synergy Stats
*/
export function heroSynergiesStats<T>(requestParameters: HeroSynergiesStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<HeroSynergyStats>>): QueryConfig<T> {
    return heroSynergiesStatsRaw(requestParameters, requestConfig);
}

/**
 *  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Item Permutation Stats
 */
function itemPermutationStatsRaw<T>(requestParameters: ItemPermutationStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<ItemPermutationStats>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.itemIds) {
        queryParameters['item_ids'] = requestParameters.itemIds;
    }


    if (requestParameters.combSize !== undefined) {
        queryParameters['comb_size'] = requestParameters.combSize;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.heroIds !== undefined) {
        queryParameters['hero_ids'] = requestParameters.heroIds;
    }


    if (requestParameters.heroId !== undefined) {
        queryParameters['hero_id'] = requestParameters.heroId;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.accountId !== undefined) {
        queryParameters['account_id'] = requestParameters.accountId;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/item-permutation-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(ItemPermutationStatsFromJSON), text);
    }

    return config;
}

/**
*  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Item Permutation Stats
*/
export function itemPermutationStats<T>(requestParameters: ItemPermutationStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<ItemPermutationStats>>): QueryConfig<T> {
    return itemPermutationStatsRaw(requestParameters, requestConfig);
}

/**
 *  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Item Stats
 */
function itemStatsRaw<T>(requestParameters: ItemStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<ItemStats>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.bucket !== undefined) {
        queryParameters['bucket'] = requestParameters.bucket;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.heroIds !== undefined) {
        queryParameters['hero_ids'] = requestParameters.heroIds;
    }


    if (requestParameters.heroId !== undefined) {
        queryParameters['hero_id'] = requestParameters.heroId;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.includeItemIds) {
        queryParameters['include_item_ids'] = requestParameters.includeItemIds;
    }


    if (requestParameters.excludeItemIds) {
        queryParameters['exclude_item_ids'] = requestParameters.excludeItemIds;
    }


    if (requestParameters.minMatches !== undefined) {
        queryParameters['min_matches'] = requestParameters.minMatches;
    }


    if (requestParameters.maxMatches !== undefined) {
        queryParameters['max_matches'] = requestParameters.maxMatches;
    }


    if (requestParameters.accountId !== undefined) {
        queryParameters['account_id'] = requestParameters.accountId;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }


    if (requestParameters.minBoughtAtS !== undefined) {
        queryParameters['min_bought_at_s'] = requestParameters.minBoughtAtS;
    }


    if (requestParameters.maxBoughtAtS !== undefined) {
        queryParameters['max_bought_at_s'] = requestParameters.maxBoughtAtS;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/item-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(ItemStatsFromJSON), text);
    }

    return config;
}

/**
*  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Item Stats
*/
export function itemStats<T>(requestParameters: ItemStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<ItemStats>>): QueryConfig<T> {
    return itemStatsRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the kill-death statistics across a 100x100 pixel raster.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Kill Death Stats
 */
function killDeathStatsRaw<T>(requestParameters: KillDeathStatsRequest, requestConfig: runtime.TypedQueryConfig<T, Array<KillDeathStats>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.team !== undefined) {
        queryParameters['team'] = requestParameters.team;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }


    if (requestParameters.heroIds !== undefined) {
        queryParameters['hero_ids'] = requestParameters.heroIds;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.isHighSkillRangeParties !== undefined) {
        queryParameters['is_high_skill_range_parties'] = requestParameters.isHighSkillRangeParties;
    }


    if (requestParameters.isLowPriPool !== undefined) {
        queryParameters['is_low_pri_pool'] = requestParameters.isLowPriPool;
    }


    if (requestParameters.isNewPlayerPool !== undefined) {
        queryParameters['is_new_player_pool'] = requestParameters.isNewPlayerPool;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minKillsPerRaster !== undefined) {
        queryParameters['min_kills_per_raster'] = requestParameters.minKillsPerRaster;
    }


    if (requestParameters.maxKillsPerRaster !== undefined) {
        queryParameters['max_kills_per_raster'] = requestParameters.maxKillsPerRaster;
    }


    if (requestParameters.minDeathsPerRaster !== undefined) {
        queryParameters['min_deaths_per_raster'] = requestParameters.minDeathsPerRaster;
    }


    if (requestParameters.maxDeathsPerRaster !== undefined) {
        queryParameters['max_deaths_per_raster'] = requestParameters.maxDeathsPerRaster;
    }


    if (requestParameters.minGameTimeS !== undefined) {
        queryParameters['min_game_time_s'] = requestParameters.minGameTimeS;
    }


    if (requestParameters.maxGameTimeS !== undefined) {
        queryParameters['max_game_time_s'] = requestParameters.maxGameTimeS;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/kill-death-stats`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(KillDeathStatsFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the kill-death statistics across a 100x100 pixel raster.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Kill Death Stats
*/
export function killDeathStats<T>(requestParameters: KillDeathStatsRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<KillDeathStats>>): QueryConfig<T> {
    return killDeathStatsRaw(requestParameters, requestConfig);
}

/**
 *  Retrieves player performance statistics (net worth, kills, deaths, assists) over time throughout matches.  Results are cached for **1 hour** based on the unique combination of query parameters provided.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Player Performance Curve
 */
function playerPerformanceCurveRaw<T>(requestParameters: PlayerPerformanceCurveRequest, requestConfig: runtime.TypedQueryConfig<T, Array<PlayerPerformanceCurvePoint>> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.resolution !== undefined) {
        queryParameters['resolution'] = requestParameters.resolution;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.heroIds !== undefined) {
        queryParameters['hero_ids'] = requestParameters.heroIds;
    }


    if (requestParameters.includeItemIds) {
        queryParameters['include_item_ids'] = requestParameters.includeItemIds;
    }


    if (requestParameters.excludeItemIds) {
        queryParameters['exclude_item_ids'] = requestParameters.excludeItemIds;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/player-performance-curve`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(PlayerPerformanceCurvePointFromJSON), text);
    }

    return config;
}

/**
*  Retrieves player performance statistics (net worth, kills, deaths, assists) over time throughout matches.  Results are cached for **1 hour** based on the unique combination of query parameters provided.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Player Performance Curve
*/
export function playerPerformanceCurve<T>(requestParameters: PlayerPerformanceCurveRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<PlayerPerformanceCurvePoint>>): QueryConfig<T> {
    return playerPerformanceCurveRaw(requestParameters, requestConfig);
}

/**
 *  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Player Scoreboard
 */
function playerScoreboardRaw<T>(requestParameters: PlayerScoreboardRequest, requestConfig: runtime.TypedQueryConfig<T, Array<Entry>> = {}): QueryConfig<T> {
    if (requestParameters.sortBy === null || requestParameters.sortBy === undefined) {
        throw new runtime.RequiredError('sortBy','Required parameter requestParameters.sortBy was null or undefined when calling playerScoreboard.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.sortBy !== undefined) {
        queryParameters['sort_by'] = requestParameters.sortBy;
    }


    if (requestParameters.sortDirection !== undefined) {
        queryParameters['sort_direction'] = requestParameters.sortDirection;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.heroId !== undefined) {
        queryParameters['hero_id'] = requestParameters.heroId;
    }


    if (requestParameters.minMatches !== undefined) {
        queryParameters['min_matches'] = requestParameters.minMatches;
    }


    if (requestParameters.maxMatches !== undefined) {
        queryParameters['max_matches'] = requestParameters.maxMatches;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.start !== undefined) {
        queryParameters['start'] = requestParameters.start;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/scoreboards/players`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(EntryFromJSON), text);
    }

    return config;
}

/**
*  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Player Scoreboard
*/
export function playerScoreboard<T>(requestParameters: PlayerScoreboardRequest, requestConfig?: runtime.TypedQueryConfig<T, Array<Entry>>): QueryConfig<T> {
    return playerScoreboardRaw(requestParameters, requestConfig);
}

/**
 *  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
 * Player Stats Metrics
 */
function playerStatsMetricsRaw<T>(requestParameters: PlayerStatsMetricsRequest, requestConfig: runtime.TypedQueryConfig<T, { [key: string]: HashMapValue; }> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.heroIds !== undefined) {
        queryParameters['hero_ids'] = requestParameters.heroIds;
    }


    if (requestParameters.gameMode !== undefined) {
        queryParameters['game_mode'] = requestParameters.gameMode;
    }


    if (requestParameters.minUnixTimestamp !== undefined) {
        queryParameters['min_unix_timestamp'] = requestParameters.minUnixTimestamp;
    }


    if (requestParameters.maxUnixTimestamp !== undefined) {
        queryParameters['max_unix_timestamp'] = requestParameters.maxUnixTimestamp;
    }


    if (requestParameters.minDurationS !== undefined) {
        queryParameters['min_duration_s'] = requestParameters.minDurationS;
    }


    if (requestParameters.maxDurationS !== undefined) {
        queryParameters['max_duration_s'] = requestParameters.maxDurationS;
    }


    if (requestParameters.minNetworth !== undefined) {
        queryParameters['min_networth'] = requestParameters.minNetworth;
    }


    if (requestParameters.maxNetworth !== undefined) {
        queryParameters['max_networth'] = requestParameters.maxNetworth;
    }


    if (requestParameters.minAverageBadge !== undefined) {
        queryParameters['min_average_badge'] = requestParameters.minAverageBadge;
    }


    if (requestParameters.maxAverageBadge !== undefined) {
        queryParameters['max_average_badge'] = requestParameters.maxAverageBadge;
    }


    if (requestParameters.minMatchId !== undefined) {
        queryParameters['min_match_id'] = requestParameters.minMatchId;
    }


    if (requestParameters.maxMatchId !== undefined) {
        queryParameters['max_match_id'] = requestParameters.maxMatchId;
    }


    if (requestParameters.maxMatches !== undefined) {
        queryParameters['max_matches'] = requestParameters.maxMatches;
    }


    if (requestParameters.includeItemIds) {
        queryParameters['include_item_ids'] = requestParameters.includeItemIds;
    }


    if (requestParameters.excludeItemIds) {
        queryParameters['exclude_item_ids'] = requestParameters.excludeItemIds;
    }


    if (requestParameters.accountIds) {
        queryParameters['account_ids'] = requestParameters.accountIds;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/v1/analytics/player-stats/metrics`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(HashMapValueFromJSON(body), text);
    }

    return config;
}

/**
*  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
* Player Stats Metrics
*/
export function playerStatsMetrics<T>(requestParameters: PlayerStatsMetricsRequest, requestConfig?: runtime.TypedQueryConfig<T, { [key: string]: HashMapValue; }>): QueryConfig<T> {
    return playerStatsMetricsRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum AbilityOrderStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum BadgeDistributionGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum HeroCombStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum HeroCountersStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum HeroScoreboardSortByEnum {
    Matches = 'matches',
    Wins = 'wins',
    Losses = 'losses',
    Winrate = 'winrate',
    MaxKillsPerMatch = 'max_kills_per_match',
    AvgKillsPerMatch = 'avg_kills_per_match',
    Kills = 'kills',
    MaxDeathsPerMatch = 'max_deaths_per_match',
    AvgDeathsPerMatch = 'avg_deaths_per_match',
    Deaths = 'deaths',
    MaxDamageTakenPerMatch = 'max_damage_taken_per_match',
    AvgDamageTakenPerMatch = 'avg_damage_taken_per_match',
    DamageTaken = 'damage_taken',
    MaxAssistsPerMatch = 'max_assists_per_match',
    AvgAssistsPerMatch = 'avg_assists_per_match',
    Assists = 'assists',
    MaxNetWorthPerMatch = 'max_net_worth_per_match',
    AvgNetWorthPerMatch = 'avg_net_worth_per_match',
    NetWorth = 'net_worth',
    MaxLastHitsPerMatch = 'max_last_hits_per_match',
    AvgLastHitsPerMatch = 'avg_last_hits_per_match',
    LastHits = 'last_hits',
    MaxDeniesPerMatch = 'max_denies_per_match',
    AvgDeniesPerMatch = 'avg_denies_per_match',
    Denies = 'denies',
    MaxPlayerLevelPerMatch = 'max_player_level_per_match',
    AvgPlayerLevelPerMatch = 'avg_player_level_per_match',
    PlayerLevel = 'player_level',
    MaxCreepKillsPerMatch = 'max_creep_kills_per_match',
    AvgCreepKillsPerMatch = 'avg_creep_kills_per_match',
    CreepKills = 'creep_kills',
    MaxNeutralKillsPerMatch = 'max_neutral_kills_per_match',
    AvgNeutralKillsPerMatch = 'avg_neutral_kills_per_match',
    NeutralKills = 'neutral_kills',
    MaxCreepDamagePerMatch = 'max_creep_damage_per_match',
    AvgCreepDamagePerMatch = 'avg_creep_damage_per_match',
    CreepDamage = 'creep_damage',
    MaxPlayerDamagePerMatch = 'max_player_damage_per_match',
    AvgPlayerDamagePerMatch = 'avg_player_damage_per_match',
    PlayerDamage = 'player_damage',
    MaxNeutralDamagePerMatch = 'max_neutral_damage_per_match',
    AvgNeutralDamagePerMatch = 'avg_neutral_damage_per_match',
    NeutralDamage = 'neutral_damage',
    MaxBossDamagePerMatch = 'max_boss_damage_per_match',
    AvgBossDamagePerMatch = 'avg_boss_damage_per_match',
    BossDamage = 'boss_damage',
    MaxMaxHealthPerMatch = 'max_max_health_per_match',
    AvgMaxHealthPerMatch = 'avg_max_health_per_match',
    MaxHealth = 'max_health',
    MaxShotsHitPerMatch = 'max_shots_hit_per_match',
    AvgShotsHitPerMatch = 'avg_shots_hit_per_match',
    ShotsHit = 'shots_hit',
    MaxShotsMissedPerMatch = 'max_shots_missed_per_match',
    AvgShotsMissedPerMatch = 'avg_shots_missed_per_match',
    ShotsMissed = 'shots_missed',
    MaxHeroBulletsHitPerMatch = 'max_hero_bullets_hit_per_match',
    AvgHeroBulletsHitPerMatch = 'avg_hero_bullets_hit_per_match',
    HeroBulletsHit = 'hero_bullets_hit',
    MaxHeroBulletsHitCritPerMatch = 'max_hero_bullets_hit_crit_per_match',
    AvgHeroBulletsHitCritPerMatch = 'avg_hero_bullets_hit_crit_per_match',
    HeroBulletsHitCrit = 'hero_bullets_hit_crit'
}
/**
    * @export
    * @enum {string}
    */
export enum HeroScoreboardSortDirectionEnum {
    Desc = 'desc',
    Asc = 'asc'
}
/**
    * @export
    * @enum {string}
    */
export enum HeroScoreboardGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum HeroStatsBucketEnum {
    NoBucket = 'no_bucket',
    StartTimeHour = 'start_time_hour',
    StartTimeDay = 'start_time_day',
    StartTimeWeek = 'start_time_week',
    StartTimeMonth = 'start_time_month'
}
/**
    * @export
    * @enum {string}
    */
export enum HeroStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum HeroSynergiesStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum ItemPermutationStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum ItemStatsBucketEnum {
    NoBucket = 'no_bucket',
    Hero = 'hero',
    Team = 'team',
    StartTimeHour = 'start_time_hour',
    StartTimeDay = 'start_time_day',
    StartTimeWeek = 'start_time_week',
    StartTimeMonth = 'start_time_month',
    GameTimeMin = 'game_time_min',
    GameTimeNormalizedPercentage = 'game_time_normalized_percentage',
    NetWorthBy1000 = 'net_worth_by_1000',
    NetWorthBy2000 = 'net_worth_by_2000',
    NetWorthBy3000 = 'net_worth_by_3000',
    NetWorthBy5000 = 'net_worth_by_5000',
    NetWorthBy10000 = 'net_worth_by_10000'
}
/**
    * @export
    * @enum {string}
    */
export enum ItemStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum KillDeathStatsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum PlayerPerformanceCurveGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum PlayerScoreboardSortByEnum {
    Matches = 'matches',
    Wins = 'wins',
    Losses = 'losses',
    Winrate = 'winrate',
    MaxKillsPerMatch = 'max_kills_per_match',
    AvgKillsPerMatch = 'avg_kills_per_match',
    Kills = 'kills',
    MaxDeathsPerMatch = 'max_deaths_per_match',
    AvgDeathsPerMatch = 'avg_deaths_per_match',
    Deaths = 'deaths',
    MaxDamageTakenPerMatch = 'max_damage_taken_per_match',
    AvgDamageTakenPerMatch = 'avg_damage_taken_per_match',
    DamageTaken = 'damage_taken',
    MaxAssistsPerMatch = 'max_assists_per_match',
    AvgAssistsPerMatch = 'avg_assists_per_match',
    Assists = 'assists',
    MaxNetWorthPerMatch = 'max_net_worth_per_match',
    AvgNetWorthPerMatch = 'avg_net_worth_per_match',
    NetWorth = 'net_worth',
    MaxLastHitsPerMatch = 'max_last_hits_per_match',
    AvgLastHitsPerMatch = 'avg_last_hits_per_match',
    LastHits = 'last_hits',
    MaxDeniesPerMatch = 'max_denies_per_match',
    AvgDeniesPerMatch = 'avg_denies_per_match',
    Denies = 'denies',
    MaxPlayerLevelPerMatch = 'max_player_level_per_match',
    AvgPlayerLevelPerMatch = 'avg_player_level_per_match',
    PlayerLevel = 'player_level',
    MaxCreepKillsPerMatch = 'max_creep_kills_per_match',
    AvgCreepKillsPerMatch = 'avg_creep_kills_per_match',
    CreepKills = 'creep_kills',
    MaxNeutralKillsPerMatch = 'max_neutral_kills_per_match',
    AvgNeutralKillsPerMatch = 'avg_neutral_kills_per_match',
    NeutralKills = 'neutral_kills',
    MaxCreepDamagePerMatch = 'max_creep_damage_per_match',
    AvgCreepDamagePerMatch = 'avg_creep_damage_per_match',
    CreepDamage = 'creep_damage',
    MaxPlayerDamagePerMatch = 'max_player_damage_per_match',
    AvgPlayerDamagePerMatch = 'avg_player_damage_per_match',
    PlayerDamage = 'player_damage',
    MaxNeutralDamagePerMatch = 'max_neutral_damage_per_match',
    AvgNeutralDamagePerMatch = 'avg_neutral_damage_per_match',
    NeutralDamage = 'neutral_damage',
    MaxBossDamagePerMatch = 'max_boss_damage_per_match',
    AvgBossDamagePerMatch = 'avg_boss_damage_per_match',
    BossDamage = 'boss_damage',
    MaxMaxHealthPerMatch = 'max_max_health_per_match',
    AvgMaxHealthPerMatch = 'avg_max_health_per_match',
    MaxHealth = 'max_health',
    MaxShotsHitPerMatch = 'max_shots_hit_per_match',
    AvgShotsHitPerMatch = 'avg_shots_hit_per_match',
    ShotsHit = 'shots_hit',
    MaxShotsMissedPerMatch = 'max_shots_missed_per_match',
    AvgShotsMissedPerMatch = 'avg_shots_missed_per_match',
    ShotsMissed = 'shots_missed',
    MaxHeroBulletsHitPerMatch = 'max_hero_bullets_hit_per_match',
    AvgHeroBulletsHitPerMatch = 'avg_hero_bullets_hit_per_match',
    HeroBulletsHit = 'hero_bullets_hit',
    MaxHeroBulletsHitCritPerMatch = 'max_hero_bullets_hit_crit_per_match',
    AvgHeroBulletsHitCritPerMatch = 'avg_hero_bullets_hit_crit_per_match',
    HeroBulletsHitCrit = 'hero_bullets_hit_crit'
}
/**
    * @export
    * @enum {string}
    */
export enum PlayerScoreboardSortDirectionEnum {
    Desc = 'desc',
    Asc = 'asc'
}
/**
    * @export
    * @enum {string}
    */
export enum PlayerScoreboardGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
/**
    * @export
    * @enum {string}
    */
export enum PlayerStatsMetricsGameModeEnum {
    Normal = 'normal',
    StreetBrawl = 'street_brawl'
}
