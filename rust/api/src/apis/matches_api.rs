/*
 * Deadlock API
 *
 *  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`active_matches`]
#[derive(Clone, Debug)]
pub struct ActiveMatchesParams {
    /// The account ID to filter active matches by (`SteamID3`)
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`bulk_metadata`]
#[derive(Clone, Debug)]
pub struct BulkMetadataParams {
    /// Include match info in the response.
    pub include_info: Option<bool>,
    /// Include objectives in the response.
    pub include_objectives: Option<bool>,
    /// Include midboss in the response.
    pub include_mid_boss: Option<bool>,
    /// Include player info in the response.
    pub include_player_info: Option<bool>,
    /// Include player items in the response.
    pub include_player_items: Option<bool>,
    /// Include player stats in the response.
    pub include_player_stats: Option<bool>,
    /// Include player death details in the response.
    pub include_player_death_details: Option<bool>,
    /// Comma separated list of match ids, limited by `limit`
    pub match_ids: Option<Vec<u64>>,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter matches based on whether they are in the high skill range.
    pub is_high_skill_range_parties: Option<bool>,
    /// Filter matches based on whether they are in the low priority pool.
    pub is_low_pri_pool: Option<bool>,
    /// Filter matches based on whether they are in the new player pool.
    pub is_new_player_pool: Option<bool>,
    /// Filter matches by account IDs of players that participated in the match.
    pub account_ids: Option<Vec<u32>>,
    /// Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_ids: Option<String>,
    /// The field to order the results by.
    pub order_by: Option<String>,
    /// The direction to order the results by.
    pub order_direction: Option<String>,
    /// The maximum number of matches to return.
    pub limit: Option<u32>
}

/// struct for passing parameters to the method [`metadata`]
#[derive(Clone, Debug)]
pub struct MetadataParams {
    /// The match ID
    pub match_id: u64,
    pub is_custom: Option<bool>
}

/// struct for passing parameters to the method [`metadata_raw`]
#[derive(Clone, Debug)]
pub struct MetadataRawParams {
    /// The match ID
    pub match_id: u64,
    pub is_custom: Option<bool>
}

/// struct for passing parameters to the method [`recently_fetched`]
#[derive(Clone, Debug)]
pub struct RecentlyFetchedParams {
    /// If true, only return matches that have been ingested by players.
    pub player_ingested_only: Option<bool>
}

/// struct for passing parameters to the method [`salts`]
#[derive(Clone, Debug)]
pub struct SaltsParams {
    /// The match ID
    pub match_id: u64
}

/// struct for passing parameters to the method [`url`]
#[derive(Clone, Debug)]
pub struct UrlParams {
    /// The match ID
    pub match_id: u64
}


/// struct for typed errors of method [`active_matches`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActiveMatchesError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`active_matches_raw`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActiveMatchesRawError {
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkMetadataError {
    Status400(),
    Status429(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataError {
    Status400(),
    Status404(),
    Status429(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`metadata_raw`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MetadataRawError {
    Status400(),
    Status404(),
    Status429(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`recently_fetched`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RecentlyFetchedError {
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`salts`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SaltsError {
    Status400(),
    Status429(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UrlError {
    Status400(),
    Status429(),
    Status500(),
    UnknownValue(serde_json::Value),
}


///  Returns active matches that are currently being played.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn active_matches(configuration: &configuration::Configuration, params: ActiveMatchesParams) -> Result<Vec<models::ActiveMatch>, Error<ActiveMatchesError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/matches/active", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = account_id {
        local_var_req_builder = local_var_req_builder.query(&[("account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActiveMatchesError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Returns active matches that are currently being played, serialized as protobuf message.  Fetched from the watch tab in game, which is limited to the **top 200 matches**.  You have to decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Message: - CMsgClientToGcGetActiveMatchesResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn active_matches_raw(configuration: &configuration::Configuration) -> Result<Vec<u32>, Error<ActiveMatchesRawError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/matches/active/raw", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ActiveMatchesRawError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 4req/s | | Key | - | | Global | 10req/s |     
pub async fn bulk_metadata(configuration: &configuration::Configuration, params: BulkMetadataParams) -> Result<Vec<u32>, Error<BulkMetadataError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let include_info = params.include_info;
    let include_objectives = params.include_objectives;
    let include_mid_boss = params.include_mid_boss;
    let include_player_info = params.include_player_info;
    let include_player_items = params.include_player_items;
    let include_player_stats = params.include_player_stats;
    let include_player_death_details = params.include_player_death_details;
    let match_ids = params.match_ids;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let is_high_skill_range_parties = params.is_high_skill_range_parties;
    let is_low_pri_pool = params.is_low_pri_pool;
    let is_new_player_pool = params.is_new_player_pool;
    let account_ids = params.account_ids;
    let hero_ids = params.hero_ids;
    let order_by = params.order_by;
    let order_direction = params.order_direction;
    let limit = params.limit;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/matches/metadata", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = include_info {
        local_var_req_builder = local_var_req_builder.query(&[("include_info", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_objectives {
        local_var_req_builder = local_var_req_builder.query(&[("include_objectives", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_mid_boss {
        local_var_req_builder = local_var_req_builder.query(&[("include_mid_boss", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_player_info {
        local_var_req_builder = local_var_req_builder.query(&[("include_player_info", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_player_items {
        local_var_req_builder = local_var_req_builder.query(&[("include_player_items", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_player_stats {
        local_var_req_builder = local_var_req_builder.query(&[("include_player_stats", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_player_death_details {
        local_var_req_builder = local_var_req_builder.query(&[("include_player_death_details", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = match_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("match_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("match_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_high_skill_range_parties {
        local_var_req_builder = local_var_req_builder.query(&[("is_high_skill_range_parties", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_low_pri_pool {
        local_var_req_builder = local_var_req_builder.query(&[("is_low_pri_pool", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_new_player_pool {
        local_var_req_builder = local_var_req_builder.query(&[("is_new_player_pool", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = hero_ids {
        local_var_req_builder = local_var_req_builder.query(&[("hero_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order_by {
        local_var_req_builder = local_var_req_builder.query(&[("order_by", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = order_direction {
        local_var_req_builder = local_var_req_builder.query(&[("order_direction", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BulkMetadataError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns the match metadata for the given `match_id` parsed into JSON.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
pub async fn metadata(configuration: &configuration::Configuration, params: MetadataParams) -> Result<(), Error<MetadataError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let match_id = params.match_id;
    let is_custom = params.is_custom;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/matches/{match_id}/metadata", local_var_configuration.base_path, match_id=match_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_custom {
        local_var_req_builder = local_var_req_builder.query(&[("is_custom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<MetadataError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoints returns the raw .meta.bz2 file for the given `match_id`.  You have to decompress it and decode the protobuf message.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgMatchMetaData - CMsgMatchMetaDataContents  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins | | Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min | | Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |     
pub async fn metadata_raw(configuration: &configuration::Configuration, params: MetadataRawParams) -> Result<Vec<u32>, Error<MetadataRawError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let match_id = params.match_id;
    let is_custom = params.is_custom;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/matches/{match_id}/metadata/raw", local_var_configuration.base_path, match_id=match_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = is_custom {
        local_var_req_builder = local_var_req_builder.query(&[("is_custom", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MetadataRawError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns a list of match ids that have been fetched within the last 10 minutes.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn recently_fetched(configuration: &configuration::Configuration, params: RecentlyFetchedParams) -> Result<Vec<models::ClickhouseMatchInfo>, Error<RecentlyFetchedError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let player_ingested_only = params.player_ingested_only;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/matches/recently-fetched", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = player_ingested_only {
        local_var_req_builder = local_var_req_builder.query(&[("player_ingested_only", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RecentlyFetchedError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoints returns salts that can be used to fetch metadata and demofile for a match.  **Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | From DB: 100req/s<br>From Steam: 10req/30mins | | Key | From DB: -<br>From Steam: 10req/min | | Global | From DB: -<br>From Steam: 10req/10s |     
pub async fn salts(configuration: &configuration::Configuration, params: SaltsParams) -> Result<models::MatchSaltsResponse, Error<SaltsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let match_id = params.match_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/matches/{match_id}/salts", local_var_configuration.base_path, match_id=match_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SaltsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.  Example Parsers: - [Demofile-Net](https://github.com/saul/demofile-net) - [Haste](https://github.com/blukai/haste/)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 10req/30mins | | Key | 60req/min | | Global | 100req/10s |     
pub async fn url(configuration: &configuration::Configuration, params: UrlParams) -> Result<models::MatchSpectateResponse, Error<UrlError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let match_id = params.match_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/matches/{match_id}/live/url", local_var_configuration.base_path, match_id=match_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UrlError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

