/*
 * Deadlock API
 *
 *  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`card`]
#[derive(Clone, Debug)]
pub struct CardParams {
    /// The players `SteamID3`
    pub account_id: u32
}

/// struct for passing parameters to the method [`enemy_stats`]
#[derive(Clone, Debug)]
pub struct EnemyStatsParams {
    /// The players `SteamID3`
    pub account_id: u32,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter based on the number of matches played.
    pub min_matches_played: Option<u64>,
    /// Filter based on the number of matches played.
    pub max_matches_played: Option<u64>
}

/// struct for passing parameters to the method [`match_history`]
#[derive(Clone, Debug)]
pub struct MatchHistoryParams {
    /// The players `SteamID3`
    pub account_id: u32,
    /// Refetch the match history from Steam, even if it is already cached in `ClickHouse`. Only use this if you are sure that the data in `ClickHouse` is outdated. Enabling this flag results in a strict rate limit.
    pub force_refetch: Option<bool>,
    /// Return only the already stored match history from `ClickHouse`. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with `force_refetch`.
    pub only_stored_history: Option<bool>
}

/// struct for passing parameters to the method [`mate_stats`]
#[derive(Clone, Debug)]
pub struct MateStatsParams {
    /// The players `SteamID3`
    pub account_id: u32,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter based on the number of matches played.
    pub min_matches_played: Option<u64>,
    /// Filter based on the number of matches played.
    pub max_matches_played: Option<u64>,
    /// Filter based on whether the mates were on the same party.
    pub same_party: Option<bool>
}

/// struct for passing parameters to the method [`party_stats`]
#[derive(Clone, Debug)]
pub struct PartyStatsParams {
    /// The players `SteamID3`
    pub account_id: u32,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>
}

/// struct for passing parameters to the method [`player_hero_stats`]
#[derive(Clone, Debug)]
pub struct PlayerHeroStatsParams {
    /// Comma separated list of account ids, Account IDs are in `SteamID3` format.
    pub account_ids: Vec<u32>,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>
}

/// struct for passing parameters to the method [`steam`]
#[derive(Clone, Debug)]
pub struct SteamParams {
    /// Comma separated list of account ids, Account IDs are in `SteamID3` format.
    pub account_ids: Vec<u64>
}

/// struct for passing parameters to the method [`steam_search`]
#[derive(Clone, Debug)]
pub struct SteamSearchParams {
    /// Search query for Steam profiles.
    pub search_query: String
}


/// struct for typed errors of method [`card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CardError {
    Status400(),
    Status429(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enemy_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnemyStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`match_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MatchHistoryError {
    Status400(),
    Status429(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mate_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MateStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`party_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartyStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`player_hero_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayerHeroStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`steam`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SteamError {
    Status400(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`steam_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SteamSearchError {
    Status400(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}


///  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
pub async fn card(configuration: &configuration::Configuration, params: CardParams) -> Result<Vec<models::PlayerCard>, Error<CardError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/players/{account_id}/card", local_var_configuration.base_path, account_id=account_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CardError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn enemy_stats(configuration: &configuration::Configuration, params: EnemyStatsParams) -> Result<Vec<models::EnemyStats>, Error<EnemyStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let min_matches_played = params.min_matches_played;
    let max_matches_played = params.max_matches_played;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/players/{account_id}/enemy-stats", local_var_configuration.base_path, account_id=account_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_matches_played {
        local_var_req_builder = local_var_req_builder.query(&[("min_matches_played", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_matches_played {
        local_var_req_builder = local_var_req_builder.query(&[("max_matches_played", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<EnemyStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
pub async fn match_history(configuration: &configuration::Configuration, params: MatchHistoryParams) -> Result<Vec<models::PlayerMatchHistoryEntry>, Error<MatchHistoryError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let force_refetch = params.force_refetch;
    let only_stored_history = params.only_stored_history;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/players/{account_id}/match-history", local_var_configuration.base_path, account_id=account_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = force_refetch {
        local_var_req_builder = local_var_req_builder.query(&[("force_refetch", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = only_stored_history {
        local_var_req_builder = local_var_req_builder.query(&[("only_stored_history", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MatchHistoryError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn mate_stats(configuration: &configuration::Configuration, params: MateStatsParams) -> Result<Vec<models::MateStats>, Error<MateStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let min_matches_played = params.min_matches_played;
    let max_matches_played = params.max_matches_played;
    let same_party = params.same_party;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/players/{account_id}/mate-stats", local_var_configuration.base_path, account_id=account_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_matches_played {
        local_var_req_builder = local_var_req_builder.query(&[("min_matches_played", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_matches_played {
        local_var_req_builder = local_var_req_builder.query(&[("max_matches_played", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = same_party {
        local_var_req_builder = local_var_req_builder.query(&[("same_party", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<MateStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn party_stats(configuration: &configuration::Configuration, params: PartyStatsParams) -> Result<Vec<models::PartyStats>, Error<PartyStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_id = params.account_id;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/players/{account_id}/party-stats", local_var_configuration.base_path, account_id=account_id);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PartyStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn player_hero_stats(configuration: &configuration::Configuration, params: PlayerHeroStatsParams) -> Result<Vec<models::HeroStats>, Error<PlayerHeroStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_ids = params.account_ids;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/players/hero-stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&account_ids.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("account_ids", &account_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PlayerHeroStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn steam(configuration: &configuration::Configuration, params: SteamParams) -> Result<Vec<models::SteamProfile>, Error<SteamError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/players/steam", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = match "multi" {
        "multi" => local_var_req_builder.query(&account_ids.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => local_var_req_builder.query(&[("account_ids", &account_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SteamError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn steam_search(configuration: &configuration::Configuration, params: SteamSearchParams) -> Result<Vec<models::SteamProfile>, Error<SteamSearchError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let search_query = params.search_query;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/players/steam-search", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("search_query", &search_query.to_string())]);
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SteamSearchError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

