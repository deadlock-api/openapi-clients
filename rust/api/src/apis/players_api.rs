/*
 * Deadlock API
 *
 *  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`card`]
#[derive(Clone, Debug)]
pub struct CardParams {
    /// The players `SteamID3`
    pub account_id: u32
}

/// struct for passing parameters to the method [`enemy_stats`]
#[derive(Clone, Debug)]
pub struct EnemyStatsParams {
    /// The players `SteamID3`
    pub account_id: u32,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter based on the number of matches played.
    pub min_matches_played: Option<u64>,
    /// Filter based on the number of matches played.
    pub max_matches_played: Option<u64>
}

/// struct for passing parameters to the method [`match_history`]
#[derive(Clone, Debug)]
pub struct MatchHistoryParams {
    /// The players `SteamID3`
    pub account_id: u32,
    /// Refetch the match history from Steam, even if it is already cached in `ClickHouse`. Only use this if you are sure that the data in `ClickHouse` is outdated. Enabling this flag results in a strict rate limit.
    pub force_refetch: Option<bool>,
    /// Return only the already stored match history from `ClickHouse`. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with `force_refetch`.
    pub only_stored_history: Option<bool>
}

/// struct for passing parameters to the method [`mate_stats`]
#[derive(Clone, Debug)]
pub struct MateStatsParams {
    /// The players `SteamID3`
    pub account_id: u32,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter based on the number of matches played.
    pub min_matches_played: Option<u64>,
    /// Filter based on the number of matches played.
    pub max_matches_played: Option<u64>,
    /// Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches.
    pub same_party: Option<bool>
}

/// struct for passing parameters to the method [`party_stats`]
#[derive(Clone, Debug)]
pub struct PartyStatsParams {
    /// The players `SteamID3`
    pub account_id: u32,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>
}

/// struct for passing parameters to the method [`player_hero_stats`]
#[derive(Clone, Debug)]
pub struct PlayerHeroStatsParams {
    /// Comma separated list of account ids, Account IDs are in `SteamID3` format.
    pub account_ids: Vec<u32>,
    /// Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_ids: Option<String>,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>
}

/// struct for passing parameters to the method [`steam`]
#[derive(Clone, Debug)]
pub struct SteamParams {
    /// Comma separated list of account ids, Account IDs are in `SteamID3` format.
    pub account_ids: Vec<u64>
}

/// struct for passing parameters to the method [`steam_search`]
#[derive(Clone, Debug)]
pub struct SteamSearchParams {
    /// Search query for Steam profiles.
    pub search_query: String
}


/// struct for typed errors of method [`card`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CardError {
    Status400(),
    Status429(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enemy_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnemyStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`match_history`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MatchHistoryError {
    Status400(),
    Status429(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`mate_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MateStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`party_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PartyStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`player_hero_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayerHeroStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`steam`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SteamError {
    Status400(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`steam_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SteamSearchError {
    Status400(),
    Status404(),
    Status500(),
    UnknownValue(serde_json::Value),
}


///  This endpoint returns the player card for the given `account_id`.  You have to be friend with one of the bots to use this endpoint. On first use this endpoint will return an error with a list of invite links to add the bot as friend. From then on you can use this endpoint.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetProfileCard - CMsgCitadelProfileCard  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min | | Key | 20req/min & 800req/h | | Global | 200req/min |     
pub async fn card(configuration: &configuration::Configuration, params: CardParams) -> Result<Vec<models::PlayerCard>, Error<CardError>> {

    let uri_str = format!("{}/v1/players/{account_id}/card", configuration.base_path, account_id=params.account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PlayerCard&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PlayerCard&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint returns the enemy stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn enemy_stats(configuration: &configuration::Configuration, params: EnemyStatsParams) -> Result<Vec<models::EnemyStats>, Error<EnemyStatsError>> {

    let uri_str = format!("{}/v1/players/{account_id}/enemy-stats", configuration.base_path, account_id=params.account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_matches_played {
        req_builder = req_builder.query(&[("min_matches_played", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_matches_played {
        req_builder = req_builder.query(&[("max_matches_played", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EnemyStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EnemyStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnemyStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint returns the player match history for the given `account_id`.  The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.  Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)  Relevant Protobuf Messages: - CMsgClientToGcGetMatchHistory - CMsgClientToGcGetMatchHistoryResponse  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 5req/min<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h | | Key | 50req/min & 1000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h | | Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |     
pub async fn match_history(configuration: &configuration::Configuration, params: MatchHistoryParams) -> Result<Vec<models::PlayerMatchHistoryEntry>, Error<MatchHistoryError>> {

    let uri_str = format!("{}/v1/players/{account_id}/match-history", configuration.base_path, account_id=params.account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.force_refetch {
        req_builder = req_builder.query(&[("force_refetch", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.only_stored_history {
        req_builder = req_builder.query(&[("only_stored_history", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PlayerMatchHistoryEntry&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PlayerMatchHistoryEntry&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MatchHistoryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint returns the mate stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn mate_stats(configuration: &configuration::Configuration, params: MateStatsParams) -> Result<Vec<models::MateStats>, Error<MateStatsError>> {

    let uri_str = format!("{}/v1/players/{account_id}/mate-stats", configuration.base_path, account_id=params.account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_matches_played {
        req_builder = req_builder.query(&[("min_matches_played", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_matches_played {
        req_builder = req_builder.query(&[("max_matches_played", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.same_party {
        req_builder = req_builder.query(&[("same_party", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MateStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MateStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<MateStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint returns the party stats.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn party_stats(configuration: &configuration::Configuration, params: PartyStatsParams) -> Result<Vec<models::PartyStats>, Error<PartyStatsError>> {

    let uri_str = format!("{}/v1/players/{account_id}/party-stats", configuration.base_path, account_id=params.account_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::PartyStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::PartyStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PartyStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint returns statistics for each hero played by a given player account.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn player_hero_stats(configuration: &configuration::Configuration, params: PlayerHeroStatsParams) -> Result<Vec<models::HeroStats>, Error<PlayerHeroStatsError>> {

    let uri_str = format!("{}/v1/players/hero-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&params.account_ids.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("account_ids", &params.account_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref param_value) = params.hero_ids {
        req_builder = req_builder.query(&[("hero_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HeroStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::HeroStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlayerHeroStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint returns Steam profiles of players.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn steam(configuration: &configuration::Configuration, params: SteamParams) -> Result<Vec<models::SteamProfile>, Error<SteamError>> {

    let uri_str = format!("{}/v1/players/steam", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = match "multi" {
        "multi" => req_builder.query(&params.account_ids.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
        _ => req_builder.query(&[("account_ids", &params.account_ids.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
    };
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SteamProfile&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SteamProfile&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SteamError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint lets you search for Steam profiles by account_id or personaname.  See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn steam_search(configuration: &configuration::Configuration, params: SteamSearchParams) -> Result<Vec<models::SteamProfile>, Error<SteamSearchError>> {

    let uri_str = format!("{}/v1/players/steam-search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("search_query", &params.search_query.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SteamProfile&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SteamProfile&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SteamSearchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

