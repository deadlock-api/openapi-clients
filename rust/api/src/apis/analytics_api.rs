/*
 * Deadlock API
 *
 *  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`ability_order_stats`]
#[derive(Clone, Debug)]
pub struct AbilityOrderStatsParams {
    /// See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: u32,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their minimum number of ability upgrades over the whole match.
    pub min_ability_upgrades: Option<u64>,
    /// Filter players based on their maximum number of ability upgrades over the whole match.
    pub max_ability_upgrades: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// The minimum number of matches played for an ability order to be included in the response.
    pub min_matches: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`badge_distribution`]
#[derive(Clone, Debug)]
pub struct BadgeDistributionParams {
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter matches based on whether they are in the high skill range.
    pub is_high_skill_range_parties: Option<bool>,
    /// Filter matches based on whether they are in the low priority pool.
    pub is_low_pri_pool: Option<bool>,
    /// Filter matches based on whether they are in the new player pool.
    pub is_new_player_pool: Option<bool>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>
}

/// struct for passing parameters to the method [`build_item_stats`]
#[derive(Clone, Debug)]
pub struct BuildItemStatsParams {
    /// Filter builds based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: Option<u32>,
    /// Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
    pub min_last_updated_unix_timestamp: Option<i64>,
    /// Filter builds based on their last updated time (Unix timestamp).
    pub max_last_updated_unix_timestamp: Option<i64>
}

/// struct for passing parameters to the method [`hero_comb_stats`]
#[derive(Clone, Debug)]
pub struct HeroCombStatsParams {
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Comma separated list of hero ids to include. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub include_hero_ids: Option<Vec<u32>>,
    /// Comma separated list of hero ids to exclude. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub exclude_hero_ids: Option<Vec<u32>>,
    /// The minimum number of matches played for a hero combination to be included in the response.
    pub min_matches: Option<u32>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// The combination size to return.
    pub comb_size: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`hero_counters_stats`]
#[derive(Clone, Debug)]
pub struct HeroCountersStatsParams {
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter enemy players based on their net worth.
    pub min_enemy_networth: Option<u64>,
    /// Filter enemy players based on their net worth.
    pub max_enemy_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// When `true`, only considers matchups where both `hero_id` and `enemy_hero_id` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
    pub same_lane_filter: Option<bool>,
    /// The minimum number of matches played for a hero combination to be included in the response.
    pub min_matches: Option<u64>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`hero_scoreboard`]
#[derive(Clone, Debug)]
pub struct HeroScoreboardParams {
    /// The field to sort by.
    pub sort_by: String,
    /// The direction to sort heroes in.
    pub sort_direction: Option<String>,
    /// Filter by min number of matches played.
    pub min_matches: Option<u32>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`hero_stats`]
#[derive(Clone, Debug)]
pub struct HeroStatsParams {
    /// Bucket allows you to group the stats by a specific field.
    pub bucket: Option<String>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter players based on the number of matches they have played with a specific hero within the filtered time range.
    pub min_hero_matches: Option<u64>,
    /// Filter players based on the number of matches they have played with a specific hero within the filtered time range.
    pub max_hero_matches: Option<u64>,
    /// Filter players based on the number of matches they have played with a specific hero in their entire history.
    pub min_hero_matches_total: Option<u64>,
    /// Filter players based on the number of matches they have played with a specific hero in their entire history.
    pub max_hero_matches_total: Option<u64>,
    /// Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
    pub include_item_ids: Option<Vec<u32>>,
    /// Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
    pub exclude_item_ids: Option<Vec<u32>>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`hero_synergies_stats`]
#[derive(Clone, Debug)]
pub struct HeroSynergiesStatsParams {
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// When `true`, only considers matchups where both `hero_id1` and `hero_id2` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
    pub same_lane_filter: Option<bool>,
    /// When `true`, only considers matchups where both `hero_id` and `hero_id2` were on the same party. When `false`, considers all matchups regardless of party affiliation.
    pub same_party_filter: Option<bool>,
    /// The minimum number of matches played for a hero combination to be included in the response.
    pub min_matches: Option<u64>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`item_permutation_stats`]
#[derive(Clone, Debug)]
pub struct ItemPermutationStatsParams {
    /// Comma separated list of item ids. See more: <https://assets.deadlock-api.com/v2/items>
    pub item_ids: Option<Vec<u32>>,
    /// The combination size to return.
    pub comb_size: Option<u32>,
    /// Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_ids: Option<String>,
    /// Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: Option<u32>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`item_stats`]
#[derive(Clone, Debug)]
pub struct ItemStatsParams {
    /// Bucket allows you to group the stats by a specific field.
    pub bucket: Option<String>,
    /// Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_ids: Option<String>,
    /// Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: Option<u32>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Comma separated list of item ids to include. See more: <https://assets.deadlock-api.com/v2/items>
    pub include_item_ids: Option<Vec<u32>>,
    /// Comma separated list of item ids to exclude. See more: <https://assets.deadlock-api.com/v2/items>
    pub exclude_item_ids: Option<Vec<u32>>,
    /// The minimum number of matches played for an item to be included in the response.
    pub min_matches: Option<u32>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`player_scoreboard`]
#[derive(Clone, Debug)]
pub struct PlayerScoreboardParams {
    /// The field to sort by.
    pub sort_by: String,
    /// The direction to sort players in.
    pub sort_direction: Option<String>,
    /// Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: Option<u32>,
    /// The minimum number of matches played for a player to be included in the scoreboard.
    pub min_matches: Option<u32>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// The offset to start fetching players from.
    pub start: Option<u32>,
    /// The maximum number of players to fetch.
    pub limit: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`player_stats_metrics`]
#[derive(Clone, Debug)]
pub struct PlayerStatsMetricsParams {
    /// Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_ids: Option<String>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// The maximum number of matches to analyze.
    pub max_matches: Option<u32>,
    /// Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
    pub include_item_ids: Option<Vec<u32>>,
    /// Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
    pub exclude_item_ids: Option<Vec<u32>>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}


/// struct for typed errors of method [`ability_order_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbilityOrderStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`badge_distribution`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BadgeDistributionError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`build_item_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BuildItemStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_comb_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroCombStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_counters_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroCountersStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_scoreboard`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroScoreboardError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_synergies_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroSynergiesStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`item_permutation_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ItemPermutationStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`item_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ItemStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`player_scoreboard`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayerScoreboardError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`player_stats_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayerStatsMetricsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}


///  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn ability_order_stats(configuration: &configuration::Configuration, params: AbilityOrderStatsParams) -> Result<Vec<models::AnalyticsAbilityOrderStats>, Error<AbilityOrderStatsError>> {

    let uri_str = format!("{}/v1/analytics/ability-order-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("hero_id", &params.hero_id.to_string())]);
    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_ability_upgrades {
        req_builder = req_builder.query(&[("min_ability_upgrades", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_ability_upgrades {
        req_builder = req_builder.query(&[("max_ability_upgrades", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_matches {
        req_builder = req_builder.query(&[("min_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_id {
        req_builder = req_builder.query(&[("account_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AnalyticsAbilityOrderStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AnalyticsAbilityOrderStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AbilityOrderStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn badge_distribution(configuration: &configuration::Configuration, params: BadgeDistributionParams) -> Result<Vec<models::BadgeDistribution>, Error<BadgeDistributionError>> {

    let uri_str = format!("{}/v1/analytics/badge-distribution", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.is_high_skill_range_parties {
        req_builder = req_builder.query(&[("is_high_skill_range_parties", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.is_low_pri_pool {
        req_builder = req_builder.query(&[("is_low_pri_pool", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.is_new_player_pool {
        req_builder = req_builder.query(&[("is_new_player_pool", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BadgeDistribution&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BadgeDistribution&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BadgeDistributionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn build_item_stats(configuration: &configuration::Configuration, params: BuildItemStatsParams) -> Result<Vec<models::BuildItemStats>, Error<BuildItemStatsError>> {

    let uri_str = format!("{}/v1/analytics/build-item-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.hero_id {
        req_builder = req_builder.query(&[("hero_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_last_updated_unix_timestamp {
        req_builder = req_builder.query(&[("min_last_updated_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_last_updated_unix_timestamp {
        req_builder = req_builder.query(&[("max_last_updated_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::BuildItemStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::BuildItemStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BuildItemStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_comb_stats(configuration: &configuration::Configuration, params: HeroCombStatsParams) -> Result<Vec<models::HeroCombStats>, Error<HeroCombStatsError>> {

    let uri_str = format!("{}/v1/analytics/hero-comb-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_hero_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("include_hero_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("include_hero_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.exclude_hero_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("exclude_hero_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("exclude_hero_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.min_matches {
        req_builder = req_builder.query(&[("min_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_matches {
        req_builder = req_builder.query(&[("max_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.comb_size {
        req_builder = req_builder.query(&[("comb_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_id {
        req_builder = req_builder.query(&[("account_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HeroCombStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::HeroCombStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HeroCombStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_counters_stats(configuration: &configuration::Configuration, params: HeroCountersStatsParams) -> Result<Vec<models::HeroCounterStats>, Error<HeroCountersStatsError>> {

    let uri_str = format!("{}/v1/analytics/hero-counter-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_enemy_networth {
        req_builder = req_builder.query(&[("min_enemy_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_enemy_networth {
        req_builder = req_builder.query(&[("max_enemy_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.same_lane_filter {
        req_builder = req_builder.query(&[("same_lane_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_matches {
        req_builder = req_builder.query(&[("min_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_matches {
        req_builder = req_builder.query(&[("max_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_id {
        req_builder = req_builder.query(&[("account_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HeroCounterStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::HeroCounterStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HeroCountersStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_scoreboard(configuration: &configuration::Configuration, params: HeroScoreboardParams) -> Result<Vec<models::Entry>, Error<HeroScoreboardError>> {

    let uri_str = format!("{}/v1/analytics/scoreboards/heroes", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sort_by", &params.sort_by.to_string())]);
    if let Some(ref param_value) = params.sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_matches {
        req_builder = req_builder.query(&[("min_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_id {
        req_builder = req_builder.query(&[("account_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Entry&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Entry&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HeroScoreboardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_stats(configuration: &configuration::Configuration, params: HeroStatsParams) -> Result<Vec<models::AnalyticsHeroStats>, Error<HeroStatsError>> {

    let uri_str = format!("{}/v1/analytics/hero-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.bucket {
        req_builder = req_builder.query(&[("bucket", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_hero_matches {
        req_builder = req_builder.query(&[("min_hero_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_hero_matches {
        req_builder = req_builder.query(&[("max_hero_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_hero_matches_total {
        req_builder = req_builder.query(&[("min_hero_matches_total", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_hero_matches_total {
        req_builder = req_builder.query(&[("max_hero_matches_total", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_item_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("include_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("include_item_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.exclude_item_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("exclude_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("exclude_item_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.account_id {
        req_builder = req_builder.query(&[("account_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AnalyticsHeroStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AnalyticsHeroStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HeroStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_synergies_stats(configuration: &configuration::Configuration, params: HeroSynergiesStatsParams) -> Result<Vec<models::HeroSynergyStats>, Error<HeroSynergiesStatsError>> {

    let uri_str = format!("{}/v1/analytics/hero-synergy-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.same_lane_filter {
        req_builder = req_builder.query(&[("same_lane_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.same_party_filter {
        req_builder = req_builder.query(&[("same_party_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_matches {
        req_builder = req_builder.query(&[("min_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_matches {
        req_builder = req_builder.query(&[("max_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_id {
        req_builder = req_builder.query(&[("account_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::HeroSynergyStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::HeroSynergyStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HeroSynergiesStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn item_permutation_stats(configuration: &configuration::Configuration, params: ItemPermutationStatsParams) -> Result<Vec<models::ItemPermutationStats>, Error<ItemPermutationStatsError>> {

    let uri_str = format!("{}/v1/analytics/item-permutation-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.item_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("item_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.comb_size {
        req_builder = req_builder.query(&[("comb_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hero_ids {
        req_builder = req_builder.query(&[("hero_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hero_id {
        req_builder = req_builder.query(&[("hero_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_id {
        req_builder = req_builder.query(&[("account_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ItemPermutationStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ItemPermutationStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ItemPermutationStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn item_stats(configuration: &configuration::Configuration, params: ItemStatsParams) -> Result<Vec<models::ItemStats>, Error<ItemStatsError>> {

    let uri_str = format!("{}/v1/analytics/item-stats", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.bucket {
        req_builder = req_builder.query(&[("bucket", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hero_ids {
        req_builder = req_builder.query(&[("hero_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hero_id {
        req_builder = req_builder.query(&[("hero_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_item_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("include_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("include_item_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.exclude_item_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("exclude_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("exclude_item_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.min_matches {
        req_builder = req_builder.query(&[("min_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_matches {
        req_builder = req_builder.query(&[("max_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_id {
        req_builder = req_builder.query(&[("account_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ItemStats&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ItemStats&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ItemStatsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn player_scoreboard(configuration: &configuration::Configuration, params: PlayerScoreboardParams) -> Result<Vec<models::Entry>, Error<PlayerScoreboardError>> {

    let uri_str = format!("{}/v1/analytics/scoreboards/players", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("sort_by", &params.sort_by.to_string())]);
    if let Some(ref param_value) = params.sort_direction {
        req_builder = req_builder.query(&[("sort_direction", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.hero_id {
        req_builder = req_builder.query(&[("hero_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_matches {
        req_builder = req_builder.query(&[("min_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_matches {
        req_builder = req_builder.query(&[("max_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.start {
        req_builder = req_builder.query(&[("start", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Entry&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Entry&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlayerScoreboardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

///  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn player_stats_metrics(configuration: &configuration::Configuration, params: PlayerStatsMetricsParams) -> Result<std::collections::HashMap<String, models::HashMapValue>, Error<PlayerStatsMetricsError>> {

    let uri_str = format!("{}/v1/analytics/player-stats/metrics", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.hero_ids {
        req_builder = req_builder.query(&[("hero_ids", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_unix_timestamp {
        req_builder = req_builder.query(&[("min_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_unix_timestamp {
        req_builder = req_builder.query(&[("max_unix_timestamp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_duration_s {
        req_builder = req_builder.query(&[("min_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_duration_s {
        req_builder = req_builder.query(&[("max_duration_s", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_networth {
        req_builder = req_builder.query(&[("min_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_networth {
        req_builder = req_builder.query(&[("max_networth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_average_badge {
        req_builder = req_builder.query(&[("min_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_average_badge {
        req_builder = req_builder.query(&[("max_average_badge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.min_match_id {
        req_builder = req_builder.query(&[("min_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_match_id {
        req_builder = req_builder.query(&[("max_match_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.max_matches {
        req_builder = req_builder.query(&[("max_matches", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.include_item_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("include_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("include_item_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.exclude_item_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("exclude_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("exclude_item_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = params.account_ids {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("account_ids", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::HashMapValue&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `std::collections::HashMap&lt;String, models::HashMapValue&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PlayerStatsMetricsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

