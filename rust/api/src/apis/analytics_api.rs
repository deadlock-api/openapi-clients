/*
 * Deadlock API
 *
 *  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::{apis::ResponseContent, models};
use super::{Error, configuration};

/// struct for passing parameters to the method [`ability_order_stats`]
#[derive(Clone, Debug)]
pub struct AbilityOrderStatsParams {
    /// See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: u32,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their minimum number of ability upgrades over the whole match.
    pub min_ability_upgrades: Option<u64>,
    /// Filter players based on their maximum number of ability upgrades over the whole match.
    pub max_ability_upgrades: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// The minimum number of matches played for an ability order to be included in the response.
    pub min_matches: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`badge_distribution`]
#[derive(Clone, Debug)]
pub struct BadgeDistributionParams {
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter matches based on whether they are in the high skill range.
    pub is_high_skill_range_parties: Option<bool>,
    /// Filter matches based on whether they are in the low priority pool.
    pub is_low_pri_pool: Option<bool>,
    /// Filter matches based on whether they are in the new player pool.
    pub is_new_player_pool: Option<bool>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>
}

/// struct for passing parameters to the method [`build_item_stats`]
#[derive(Clone, Debug)]
pub struct BuildItemStatsParams {
    /// Filter builds based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: Option<u32>,
    /// Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
    pub min_last_updated_unix_timestamp: Option<i64>,
    /// Filter builds based on their last updated time (Unix timestamp).
    pub max_last_updated_unix_timestamp: Option<i64>
}

/// struct for passing parameters to the method [`hero_comb_stats`]
#[derive(Clone, Debug)]
pub struct HeroCombStatsParams {
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Comma separated list of hero ids to include. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub include_hero_ids: Option<Vec<u32>>,
    /// Comma separated list of hero ids to exclude. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub exclude_hero_ids: Option<Vec<u32>>,
    /// The minimum number of matches played for a hero combination to be included in the response.
    pub min_matches: Option<u32>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// The combination size to return.
    pub comb_size: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`hero_counters_stats`]
#[derive(Clone, Debug)]
pub struct HeroCountersStatsParams {
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter enemy players based on their net worth.
    pub min_enemy_networth: Option<u64>,
    /// Filter enemy players based on their net worth.
    pub max_enemy_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// When `true`, only considers matchups where both `hero_id` and `enemy_hero_id` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
    pub same_lane_filter: Option<bool>,
    /// The minimum number of matches played for a hero combination to be included in the response.
    pub min_matches: Option<u64>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`hero_scoreboard`]
#[derive(Clone, Debug)]
pub struct HeroScoreboardParams {
    /// The field to sort by.
    pub sort_by: String,
    /// The direction to sort heroes in.
    pub sort_direction: Option<String>,
    /// Filter by min number of matches played.
    pub min_matches: Option<u32>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`hero_stats`]
#[derive(Clone, Debug)]
pub struct HeroStatsParams {
    /// Bucket allows you to group the stats by a specific field.
    pub bucket: Option<String>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter players based on the number of matches they have played with a specific hero.
    pub min_hero_matches: Option<u64>,
    /// Filter players based on the number of matches they have played with a specific hero.
    pub max_hero_matches: Option<u64>,
    /// Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
    pub include_item_ids: Option<Vec<u32>>,
    /// Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
    pub exclude_item_ids: Option<Vec<u32>>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`hero_synergies_stats`]
#[derive(Clone, Debug)]
pub struct HeroSynergiesStatsParams {
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// When `true`, only considers matchups where both `hero_id1` and `hero_id2` were assigned to the same lane (e.g., both Mid Lane). When `false`, considers all matchups regardless of assigned lane.
    pub same_lane_filter: Option<bool>,
    /// When `true`, only considers matchups where both `hero_id` and `hero_id2` were on the same party. When `false`, considers all matchups regardless of party affiliation.
    pub same_party_filter: Option<bool>,
    /// The minimum number of matches played for a hero combination to be included in the response.
    pub min_matches: Option<u64>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`item_permutation_stats`]
#[derive(Clone, Debug)]
pub struct ItemPermutationStatsParams {
    /// Comma separated list of item ids. See more: <https://assets.deadlock-api.com/v2/items>
    pub item_ids: Option<Vec<u32>>,
    /// The combination size to return.
    pub comb_size: Option<u32>,
    /// Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_ids: Option<String>,
    /// Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: Option<u32>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`item_stats`]
#[derive(Clone, Debug)]
pub struct ItemStatsParams {
    /// Bucket allows you to group the stats by a specific field.
    pub bucket: Option<String>,
    /// Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_ids: Option<String>,
    /// Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: Option<u32>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// Comma separated list of item ids to include. See more: <https://assets.deadlock-api.com/v2/items>
    pub include_item_ids: Option<Vec<u32>>,
    /// Comma separated list of item ids to exclude. See more: <https://assets.deadlock-api.com/v2/items>
    pub exclude_item_ids: Option<Vec<u32>>,
    /// The minimum number of matches played for an item to be included in the response.
    pub min_matches: Option<u32>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// Filter for matches with a specific player account ID.
    pub account_id: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`player_scoreboard`]
#[derive(Clone, Debug)]
pub struct PlayerScoreboardParams {
    /// The field to sort by.
    pub sort_by: String,
    /// The direction to sort players in.
    pub sort_direction: Option<String>,
    /// Filter matches based on the hero ID. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_id: Option<u32>,
    /// The minimum number of matches played for a player to be included in the scoreboard.
    pub min_matches: Option<u32>,
    /// The maximum number of matches played for a hero combination to be included in the response.
    pub max_matches: Option<u32>,
    /// Filter matches based on their start time (Unix timestamp).
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// The offset to start fetching players from.
    pub start: Option<u32>,
    /// The maximum number of players to fetch.
    pub limit: Option<u32>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}

/// struct for passing parameters to the method [`player_stats_metrics`]
#[derive(Clone, Debug)]
pub struct PlayerStatsMetricsParams {
    /// Filter matches based on the hero IDs. See more: <https://assets.deadlock-api.com/v2/heroes>
    pub hero_ids: Option<String>,
    /// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
    pub min_unix_timestamp: Option<i64>,
    /// Filter matches based on their start time (Unix timestamp).
    pub max_unix_timestamp: Option<i64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub min_duration_s: Option<u64>,
    /// Filter matches based on their duration in seconds (up to 7000s).
    pub max_duration_s: Option<u64>,
    /// Filter players based on their net worth.
    pub min_networth: Option<u64>,
    /// Filter players based on their net worth.
    pub max_networth: Option<u64>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub min_average_badge: Option<u32>,
    /// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: <https://assets.deadlock-api.com/v2/ranks>
    pub max_average_badge: Option<u32>,
    /// Filter matches based on their ID.
    pub min_match_id: Option<u64>,
    /// Filter matches based on their ID.
    pub max_match_id: Option<u64>,
    /// The maximum number of matches to analyze.
    pub max_matches: Option<u32>,
    /// Comma separated list of item ids to include (only heroes who have purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
    pub include_item_ids: Option<Vec<u32>>,
    /// Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: <https://assets.deadlock-api.com/v2/items>
    pub exclude_item_ids: Option<Vec<u32>>,
    /// Comma separated list of account ids to include
    pub account_ids: Option<Vec<u32>>
}


/// struct for typed errors of method [`ability_order_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AbilityOrderStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`badge_distribution`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BadgeDistributionError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`build_item_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BuildItemStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_comb_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroCombStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_counters_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroCountersStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_scoreboard`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroScoreboardError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`hero_synergies_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HeroSynergiesStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`item_permutation_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ItemPermutationStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`item_stats`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ItemStatsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`player_scoreboard`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayerScoreboardError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`player_stats_metrics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PlayerStatsMetricsError {
    Status400(),
    Status500(),
    UnknownValue(serde_json::Value),
}


///  Retrieves statistics for the ability order of a hero.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn ability_order_stats(configuration: &configuration::Configuration, params: AbilityOrderStatsParams) -> Result<Vec<models::AnalyticsAbilityOrderStats>, Error<AbilityOrderStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let hero_id = params.hero_id;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_ability_upgrades = params.min_ability_upgrades;
    let max_ability_upgrades = params.max_ability_upgrades;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let min_matches = params.min_matches;
    let account_id = params.account_id;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/ability-order-stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("hero_id", &hero_id.to_string())]);
    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_ability_upgrades {
        local_var_req_builder = local_var_req_builder.query(&[("min_ability_upgrades", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_ability_upgrades {
        local_var_req_builder = local_var_req_builder.query(&[("max_ability_upgrades", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_matches {
        local_var_req_builder = local_var_req_builder.query(&[("min_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_id {
        local_var_req_builder = local_var_req_builder.query(&[("account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<AbilityOrderStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns the player badge distribution.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn badge_distribution(configuration: &configuration::Configuration, params: BadgeDistributionParams) -> Result<Vec<models::BadgeDistribution>, Error<BadgeDistributionError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let is_high_skill_range_parties = params.is_high_skill_range_parties;
    let is_low_pri_pool = params.is_low_pri_pool;
    let is_new_player_pool = params.is_new_player_pool;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/badge-distribution", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_high_skill_range_parties {
        local_var_req_builder = local_var_req_builder.query(&[("is_high_skill_range_parties", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_low_pri_pool {
        local_var_req_builder = local_var_req_builder.query(&[("is_low_pri_pool", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = is_new_player_pool {
        local_var_req_builder = local_var_req_builder.query(&[("is_new_player_pool", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BadgeDistributionError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Retrieves item statistics from hero builds.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn build_item_stats(configuration: &configuration::Configuration, params: BuildItemStatsParams) -> Result<Vec<models::BuildItemStats>, Error<BuildItemStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let hero_id = params.hero_id;
    let min_last_updated_unix_timestamp = params.min_last_updated_unix_timestamp;
    let max_last_updated_unix_timestamp = params.max_last_updated_unix_timestamp;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/build-item-stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = hero_id {
        local_var_req_builder = local_var_req_builder.query(&[("hero_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_last_updated_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_last_updated_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_last_updated_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_last_updated_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<BuildItemStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Retrieves overall statistics for each hero combination.  Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_comb_stats(configuration: &configuration::Configuration, params: HeroCombStatsParams) -> Result<Vec<models::HeroCombStats>, Error<HeroCombStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let include_hero_ids = params.include_hero_ids;
    let exclude_hero_ids = params.exclude_hero_ids;
    let min_matches = params.min_matches;
    let max_matches = params.max_matches;
    let comb_size = params.comb_size;
    let account_id = params.account_id;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/hero-comb-stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_hero_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("include_hero_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("include_hero_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = exclude_hero_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("exclude_hero_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("exclude_hero_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = min_matches {
        local_var_req_builder = local_var_req_builder.query(&[("min_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_matches {
        local_var_req_builder = local_var_req_builder.query(&[("max_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = comb_size {
        local_var_req_builder = local_var_req_builder.query(&[("comb_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_id {
        local_var_req_builder = local_var_req_builder.query(&[("account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeroCombStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Retrieves hero-versus-hero matchup statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_counters_stats(configuration: &configuration::Configuration, params: HeroCountersStatsParams) -> Result<Vec<models::HeroCounterStats>, Error<HeroCountersStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_enemy_networth = params.min_enemy_networth;
    let max_enemy_networth = params.max_enemy_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let same_lane_filter = params.same_lane_filter;
    let min_matches = params.min_matches;
    let max_matches = params.max_matches;
    let account_id = params.account_id;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/hero-counter-stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_enemy_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_enemy_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_enemy_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_enemy_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = same_lane_filter {
        local_var_req_builder = local_var_req_builder.query(&[("same_lane_filter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_matches {
        local_var_req_builder = local_var_req_builder.query(&[("min_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_matches {
        local_var_req_builder = local_var_req_builder.query(&[("max_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_id {
        local_var_req_builder = local_var_req_builder.query(&[("account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeroCountersStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns the hero scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_scoreboard(configuration: &configuration::Configuration, params: HeroScoreboardParams) -> Result<Vec<models::Entry>, Error<HeroScoreboardError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sort_by = params.sort_by;
    let sort_direction = params.sort_direction;
    let min_matches = params.min_matches;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let account_id = params.account_id;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/scoreboards/heroes", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sort_by", &sort_by.to_string())]);
    if let Some(ref local_var_str) = sort_direction {
        local_var_req_builder = local_var_req_builder.query(&[("sort_direction", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_matches {
        local_var_req_builder = local_var_req_builder.query(&[("min_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_id {
        local_var_req_builder = local_var_req_builder.query(&[("account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeroScoreboardError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Retrieves performance statistics for each hero based on historical match data.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_stats(configuration: &configuration::Configuration, params: HeroStatsParams) -> Result<Vec<models::AnalyticsHeroStats>, Error<HeroStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let min_hero_matches = params.min_hero_matches;
    let max_hero_matches = params.max_hero_matches;
    let include_item_ids = params.include_item_ids;
    let exclude_item_ids = params.exclude_item_ids;
    let account_id = params.account_id;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/hero-stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = bucket {
        local_var_req_builder = local_var_req_builder.query(&[("bucket", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_hero_matches {
        local_var_req_builder = local_var_req_builder.query(&[("min_hero_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_hero_matches {
        local_var_req_builder = local_var_req_builder.query(&[("max_hero_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("include_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("include_item_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = exclude_item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("exclude_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("exclude_item_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = account_id {
        local_var_req_builder = local_var_req_builder.query(&[("account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeroStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Retrieves hero pair synergy statistics based on historical match data.  This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.  Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn hero_synergies_stats(configuration: &configuration::Configuration, params: HeroSynergiesStatsParams) -> Result<Vec<models::HeroSynergyStats>, Error<HeroSynergiesStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let same_lane_filter = params.same_lane_filter;
    let same_party_filter = params.same_party_filter;
    let min_matches = params.min_matches;
    let max_matches = params.max_matches;
    let account_id = params.account_id;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/hero-synergy-stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = same_lane_filter {
        local_var_req_builder = local_var_req_builder.query(&[("same_lane_filter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = same_party_filter {
        local_var_req_builder = local_var_req_builder.query(&[("same_party_filter", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_matches {
        local_var_req_builder = local_var_req_builder.query(&[("min_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_matches {
        local_var_req_builder = local_var_req_builder.query(&[("max_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_id {
        local_var_req_builder = local_var_req_builder.query(&[("account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<HeroSynergiesStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Retrieves item permutation statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn item_permutation_stats(configuration: &configuration::Configuration, params: ItemPermutationStatsParams) -> Result<Vec<models::ItemPermutationStats>, Error<ItemPermutationStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let item_ids = params.item_ids;
    let comb_size = params.comb_size;
    let hero_ids = params.hero_ids;
    let hero_id = params.hero_id;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let account_id = params.account_id;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/item-permutation-stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("item_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = comb_size {
        local_var_req_builder = local_var_req_builder.query(&[("comb_size", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = hero_ids {
        local_var_req_builder = local_var_req_builder.query(&[("hero_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = hero_id {
        local_var_req_builder = local_var_req_builder.query(&[("hero_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_id {
        local_var_req_builder = local_var_req_builder.query(&[("account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ItemPermutationStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Retrieves item statistics based on historical match data.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn item_stats(configuration: &configuration::Configuration, params: ItemStatsParams) -> Result<Vec<models::ItemStats>, Error<ItemStatsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let bucket = params.bucket;
    let hero_ids = params.hero_ids;
    let hero_id = params.hero_id;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let include_item_ids = params.include_item_ids;
    let exclude_item_ids = params.exclude_item_ids;
    let min_matches = params.min_matches;
    let max_matches = params.max_matches;
    let account_id = params.account_id;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/item-stats", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = bucket {
        local_var_req_builder = local_var_req_builder.query(&[("bucket", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = hero_ids {
        local_var_req_builder = local_var_req_builder.query(&[("hero_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = hero_id {
        local_var_req_builder = local_var_req_builder.query(&[("hero_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("include_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("include_item_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = exclude_item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("exclude_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("exclude_item_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = min_matches {
        local_var_req_builder = local_var_req_builder.query(&[("min_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_matches {
        local_var_req_builder = local_var_req_builder.query(&[("max_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_id {
        local_var_req_builder = local_var_req_builder.query(&[("account_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ItemStatsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  This endpoint returns the player scoreboard.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn player_scoreboard(configuration: &configuration::Configuration, params: PlayerScoreboardParams) -> Result<Vec<models::Entry>, Error<PlayerScoreboardError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let sort_by = params.sort_by;
    let sort_direction = params.sort_direction;
    let hero_id = params.hero_id;
    let min_matches = params.min_matches;
    let max_matches = params.max_matches;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let start = params.start;
    let limit = params.limit;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/scoreboards/players", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    local_var_req_builder = local_var_req_builder.query(&[("sort_by", &sort_by.to_string())]);
    if let Some(ref local_var_str) = sort_direction {
        local_var_req_builder = local_var_req_builder.query(&[("sort_direction", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = hero_id {
        local_var_req_builder = local_var_req_builder.query(&[("hero_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_matches {
        local_var_req_builder = local_var_req_builder.query(&[("min_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_matches {
        local_var_req_builder = local_var_req_builder.query(&[("max_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = start {
        local_var_req_builder = local_var_req_builder.query(&[("start", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PlayerScoreboardError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

///  Returns comprehensive statistical analysis of player performance.  Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.  > Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.  ### Rate Limits: | Type | Limit | | ---- | ----- | | IP | 100req/s | | Key | - | | Global | - |     
pub async fn player_stats_metrics(configuration: &configuration::Configuration, params: PlayerStatsMetricsParams) -> Result<serde_json::Value, Error<PlayerStatsMetricsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let hero_ids = params.hero_ids;
    let min_unix_timestamp = params.min_unix_timestamp;
    let max_unix_timestamp = params.max_unix_timestamp;
    let min_duration_s = params.min_duration_s;
    let max_duration_s = params.max_duration_s;
    let min_networth = params.min_networth;
    let max_networth = params.max_networth;
    let min_average_badge = params.min_average_badge;
    let max_average_badge = params.max_average_badge;
    let min_match_id = params.min_match_id;
    let max_match_id = params.max_match_id;
    let max_matches = params.max_matches;
    let include_item_ids = params.include_item_ids;
    let exclude_item_ids = params.exclude_item_ids;
    let account_ids = params.account_ids;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/v1/analytics/player-stats/metrics", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = hero_ids {
        local_var_req_builder = local_var_req_builder.query(&[("hero_ids", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("min_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_unix_timestamp {
        local_var_req_builder = local_var_req_builder.query(&[("max_unix_timestamp", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("min_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_duration_s {
        local_var_req_builder = local_var_req_builder.query(&[("max_duration_s", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_networth {
        local_var_req_builder = local_var_req_builder.query(&[("min_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_networth {
        local_var_req_builder = local_var_req_builder.query(&[("max_networth", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("min_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_average_badge {
        local_var_req_builder = local_var_req_builder.query(&[("max_average_badge", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = min_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("min_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_match_id {
        local_var_req_builder = local_var_req_builder.query(&[("max_match_id", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = max_matches {
        local_var_req_builder = local_var_req_builder.query(&[("max_matches", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = include_item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("include_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("include_item_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = exclude_item_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("exclude_item_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("exclude_item_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_str) = account_ids {
        local_var_req_builder = match "multi" {
            "multi" => local_var_req_builder.query(&local_var_str.into_iter().map(|p| ("account_ids".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => local_var_req_builder.query(&[("account_ids", &local_var_str.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<PlayerStatsMetricsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

