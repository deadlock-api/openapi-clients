/*
Assets - Deadlock API

 ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_ 

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package assets-deadlock-api-client

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the MapV1 type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &MapV1{}

// MapV1 struct for MapV1
type MapV1 struct {
	// The radius of the map.
	Radius *int32 `json:"radius,omitempty"`
	// The images of the map.
	Images MapImagesV1 `json:"images"`
	ObjectivePositions ObjectivePositionsV1 `json:"objective_positions"`
	// The ziplane paths of the map. Each path is a list of P0, P1, and P2 points, describing the cubic spline.
	ZiplinePaths []ZiplanePathV1 `json:"zipline_paths"`
}

type _MapV1 MapV1

// NewMapV1 instantiates a new MapV1 object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewMapV1(images MapImagesV1, objectivePositions ObjectivePositionsV1, ziplinePaths []ZiplanePathV1) *MapV1 {
	this := MapV1{}
	var radius int32 = 10752
	this.Radius = &radius
	this.Images = images
	this.ObjectivePositions = objectivePositions
	this.ZiplinePaths = ziplinePaths
	return &this
}

// NewMapV1WithDefaults instantiates a new MapV1 object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewMapV1WithDefaults() *MapV1 {
	this := MapV1{}
	var radius int32 = 10752
	this.Radius = &radius
	return &this
}

// GetRadius returns the Radius field value if set, zero value otherwise.
func (o *MapV1) GetRadius() int32 {
	if o == nil || IsNil(o.Radius) {
		var ret int32
		return ret
	}
	return *o.Radius
}

// GetRadiusOk returns a tuple with the Radius field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *MapV1) GetRadiusOk() (*int32, bool) {
	if o == nil || IsNil(o.Radius) {
		return nil, false
	}
	return o.Radius, true
}

// HasRadius returns a boolean if a field has been set.
func (o *MapV1) HasRadius() bool {
	if o != nil && !IsNil(o.Radius) {
		return true
	}

	return false
}

// SetRadius gets a reference to the given int32 and assigns it to the Radius field.
func (o *MapV1) SetRadius(v int32) {
	o.Radius = &v
}

// GetImages returns the Images field value
func (o *MapV1) GetImages() MapImagesV1 {
	if o == nil {
		var ret MapImagesV1
		return ret
	}

	return o.Images
}

// GetImagesOk returns a tuple with the Images field value
// and a boolean to check if the value has been set.
func (o *MapV1) GetImagesOk() (*MapImagesV1, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Images, true
}

// SetImages sets field value
func (o *MapV1) SetImages(v MapImagesV1) {
	o.Images = v
}

// GetObjectivePositions returns the ObjectivePositions field value
func (o *MapV1) GetObjectivePositions() ObjectivePositionsV1 {
	if o == nil {
		var ret ObjectivePositionsV1
		return ret
	}

	return o.ObjectivePositions
}

// GetObjectivePositionsOk returns a tuple with the ObjectivePositions field value
// and a boolean to check if the value has been set.
func (o *MapV1) GetObjectivePositionsOk() (*ObjectivePositionsV1, bool) {
	if o == nil {
		return nil, false
	}
	return &o.ObjectivePositions, true
}

// SetObjectivePositions sets field value
func (o *MapV1) SetObjectivePositions(v ObjectivePositionsV1) {
	o.ObjectivePositions = v
}

// GetZiplinePaths returns the ZiplinePaths field value
func (o *MapV1) GetZiplinePaths() []ZiplanePathV1 {
	if o == nil {
		var ret []ZiplanePathV1
		return ret
	}

	return o.ZiplinePaths
}

// GetZiplinePathsOk returns a tuple with the ZiplinePaths field value
// and a boolean to check if the value has been set.
func (o *MapV1) GetZiplinePathsOk() ([]ZiplanePathV1, bool) {
	if o == nil {
		return nil, false
	}
	return o.ZiplinePaths, true
}

// SetZiplinePaths sets field value
func (o *MapV1) SetZiplinePaths(v []ZiplanePathV1) {
	o.ZiplinePaths = v
}

func (o MapV1) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o MapV1) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Radius) {
		toSerialize["radius"] = o.Radius
	}
	toSerialize["images"] = o.Images
	toSerialize["objective_positions"] = o.ObjectivePositions
	toSerialize["zipline_paths"] = o.ZiplinePaths
	return toSerialize, nil
}

func (o *MapV1) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"images",
		"objective_positions",
		"zipline_paths",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varMapV1 := _MapV1{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varMapV1)

	if err != nil {
		return err
	}

	*o = MapV1(varMapV1)

	return err
}

type NullableMapV1 struct {
	value *MapV1
	isSet bool
}

func (v NullableMapV1) Get() *MapV1 {
	return v.value
}

func (v *NullableMapV1) Set(val *MapV1) {
	v.value = val
	v.isSet = true
}

func (v NullableMapV1) IsSet() bool {
	return v.isSet
}

func (v *NullableMapV1) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableMapV1(val *MapV1) *NullableMapV1 {
	return &NullableMapV1{value: val, isSet: true}
}

func (v NullableMapV1) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableMapV1) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


