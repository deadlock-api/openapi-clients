/*
Deadlock API

 ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package deadlock_api_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// PlayersAPIService PlayersAPI service
type PlayersAPIService service

type ApiEnemyStatsRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	gameMode *string
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minMatchId *int64
	maxMatchId *int64
	minMatchesPlayed *int64
	maxMatchesPlayed *int64
}

// Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;.
func (r ApiEnemyStatsRequest) GameMode(gameMode string) ApiEnemyStatsRequest {
	r.gameMode = &gameMode
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiEnemyStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiEnemyStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiEnemyStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiEnemyStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiEnemyStatsRequest) MinDurationS(minDurationS int64) ApiEnemyStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiEnemyStatsRequest) MaxDurationS(maxDurationS int64) ApiEnemyStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter matches based on their ID.
func (r ApiEnemyStatsRequest) MinMatchId(minMatchId int64) ApiEnemyStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiEnemyStatsRequest) MaxMatchId(maxMatchId int64) ApiEnemyStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// Filter based on the number of matches played.
func (r ApiEnemyStatsRequest) MinMatchesPlayed(minMatchesPlayed int64) ApiEnemyStatsRequest {
	r.minMatchesPlayed = &minMatchesPlayed
	return r
}

// Filter based on the number of matches played.
func (r ApiEnemyStatsRequest) MaxMatchesPlayed(maxMatchesPlayed int64) ApiEnemyStatsRequest {
	r.maxMatchesPlayed = &maxMatchesPlayed
	return r
}

func (r ApiEnemyStatsRequest) Execute() ([]EnemyStats, *http.Response, error) {
	return r.ApiService.EnemyStatsExecute(r)
}

/*
EnemyStats Enemy Stats


This endpoint returns the enemy stats.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The players `SteamID3`
 @return ApiEnemyStatsRequest
*/
func (a *PlayersAPIService) EnemyStats(ctx context.Context, accountId int32) ApiEnemyStatsRequest {
	return ApiEnemyStatsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []EnemyStats
func (a *PlayersAPIService) EnemyStatsExecute(r ApiEnemyStatsRequest) ([]EnemyStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []EnemyStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.EnemyStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/{account_id}/enemy-stats"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId < 0 {
		return localVarReturnValue, nil, reportError("accountId must be greater than 0")
	}

	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.minMatchesPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_matches_played", r.minMatchesPlayed, "form", "")
	}
	if r.maxMatchesPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_matches_played", r.maxMatchesPlayed, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMatchHistoryRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	forceRefetch *bool
	onlyStoredHistory *bool
}

// Refetch the match history from Steam, even if it is already cached in &#x60;ClickHouse&#x60;. Only use this if you are sure that the data in &#x60;ClickHouse&#x60; is outdated. Enabling this flag results in a strict rate limit.
func (r ApiMatchHistoryRequest) ForceRefetch(forceRefetch bool) ApiMatchHistoryRequest {
	r.forceRefetch = &forceRefetch
	return r
}

// Return only the already stored match history from &#x60;ClickHouse&#x60;. There is no rate limit for this option, so if you need a lot of data, you can use this option. This option is not compatible with &#x60;force_refetch&#x60;.
func (r ApiMatchHistoryRequest) OnlyStoredHistory(onlyStoredHistory bool) ApiMatchHistoryRequest {
	r.onlyStoredHistory = &onlyStoredHistory
	return r
}

func (r ApiMatchHistoryRequest) Execute() ([]PlayerMatchHistoryEntry, *http.Response, error) {
	return r.ApiService.MatchHistoryExecute(r)
}

/*
MatchHistory Match History


This endpoint returns the player match history for the given `account_id`.

The player match history is a combination of the data from **Steam** and **ClickHouse**, so you always get the most up-to-date data and full history.

Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)

Relevant Protobuf Messages:
- CMsgClientToGcGetMatchHistory
- CMsgClientToGcGetMatchHistoryResponse

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 5req/h<br>With `only_stored_history=true`: 100req/s<br>With `force_refetch=true`: 5req/h |
| Key | 400req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 5req/h |
| Global | 2000req/h<br>With `only_stored_history=true`: -<br>With `force_refetch=true`: 10req/h |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The players `SteamID3`
 @return ApiMatchHistoryRequest
*/
func (a *PlayersAPIService) MatchHistory(ctx context.Context, accountId int32) ApiMatchHistoryRequest {
	return ApiMatchHistoryRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PlayerMatchHistoryEntry
func (a *PlayersAPIService) MatchHistoryExecute(r ApiMatchHistoryRequest) ([]PlayerMatchHistoryEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PlayerMatchHistoryEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.MatchHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/{account_id}/match-history"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId < 0 {
		return localVarReturnValue, nil, reportError("accountId must be greater than 0")
	}

	if r.forceRefetch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force_refetch", r.forceRefetch, "form", "")
	}
	if r.onlyStoredHistory != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "only_stored_history", r.onlyStoredHistory, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMateStatsRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	gameMode *string
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minMatchId *int64
	maxMatchId *int64
	minMatchesPlayed *int64
	maxMatchesPlayed *int64
	sameParty *bool
}

// Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;.
func (r ApiMateStatsRequest) GameMode(gameMode string) ApiMateStatsRequest {
	r.gameMode = &gameMode
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiMateStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiMateStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiMateStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiMateStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiMateStatsRequest) MinDurationS(minDurationS int64) ApiMateStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiMateStatsRequest) MaxDurationS(maxDurationS int64) ApiMateStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter matches based on their ID.
func (r ApiMateStatsRequest) MinMatchId(minMatchId int64) ApiMateStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiMateStatsRequest) MaxMatchId(maxMatchId int64) ApiMateStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// Filter based on the number of matches played.
func (r ApiMateStatsRequest) MinMatchesPlayed(minMatchesPlayed int64) ApiMateStatsRequest {
	r.minMatchesPlayed = &minMatchesPlayed
	return r
}

// Filter based on the number of matches played.
func (r ApiMateStatsRequest) MaxMatchesPlayed(maxMatchesPlayed int64) ApiMateStatsRequest {
	r.maxMatchesPlayed = &maxMatchesPlayed
	return r
}

// Filter based on whether the mates were on the same party. **Careful:** this will require us to use the match metadata, which can have missing matches.
func (r ApiMateStatsRequest) SameParty(sameParty bool) ApiMateStatsRequest {
	r.sameParty = &sameParty
	return r
}

func (r ApiMateStatsRequest) Execute() ([]MateStats, *http.Response, error) {
	return r.ApiService.MateStatsExecute(r)
}

/*
MateStats Mate Stats


This endpoint returns the mate stats.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The players `SteamID3`
 @return ApiMateStatsRequest
*/
func (a *PlayersAPIService) MateStats(ctx context.Context, accountId int32) ApiMateStatsRequest {
	return ApiMateStatsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []MateStats
func (a *PlayersAPIService) MateStatsExecute(r ApiMateStatsRequest) ([]MateStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MateStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.MateStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/{account_id}/mate-stats"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId < 0 {
		return localVarReturnValue, nil, reportError("accountId must be greater than 0")
	}

	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.minMatchesPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_matches_played", r.minMatchesPlayed, "form", "")
	}
	if r.maxMatchesPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_matches_played", r.maxMatchesPlayed, "form", "")
	}
	if r.sameParty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "same_party", r.sameParty, "form", "")
	} else {
		var defaultValue bool = true
		parameterAddToHeaderOrQuery(localVarQueryParams, "same_party", defaultValue, "form", "")
		r.sameParty = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPartyStatsRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountId int32
	gameMode *string
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minMatchId *int64
	maxMatchId *int64
}

// Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;.
func (r ApiPartyStatsRequest) GameMode(gameMode string) ApiPartyStatsRequest {
	r.gameMode = &gameMode
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiPartyStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiPartyStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiPartyStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiPartyStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiPartyStatsRequest) MinDurationS(minDurationS int64) ApiPartyStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiPartyStatsRequest) MaxDurationS(maxDurationS int64) ApiPartyStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter matches based on their ID.
func (r ApiPartyStatsRequest) MinMatchId(minMatchId int64) ApiPartyStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiPartyStatsRequest) MaxMatchId(maxMatchId int64) ApiPartyStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

func (r ApiPartyStatsRequest) Execute() ([]PartyStats, *http.Response, error) {
	return r.ApiService.PartyStatsExecute(r)
}

/*
PartyStats Party Stats


This endpoint returns the party stats.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The players `SteamID3`
 @return ApiPartyStatsRequest
*/
func (a *PlayersAPIService) PartyStats(ctx context.Context, accountId int32) ApiPartyStatsRequest {
	return ApiPartyStatsRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []PartyStats
func (a *PlayersAPIService) PartyStatsExecute(r ApiPartyStatsRequest) ([]PartyStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PartyStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.PartyStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/{account_id}/party-stats"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId < 0 {
		return localVarReturnValue, nil, reportError("accountId must be greater than 0")
	}

	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlayerHeroStatsRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountIds *[]int32
	gameMode *string
	heroIds *string
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
}

// Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
func (r ApiPlayerHeroStatsRequest) AccountIds(accountIds []int32) ApiPlayerHeroStatsRequest {
	r.accountIds = &accountIds
	return r
}

// Filter matches based on their game mode. Valid values: &#x60;normal&#x60;, &#x60;street_brawl&#x60;. **Default:** &#x60;normal&#x60;.
func (r ApiPlayerHeroStatsRequest) GameMode(gameMode string) ApiPlayerHeroStatsRequest {
	r.gameMode = &gameMode
	return r
}

// Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiPlayerHeroStatsRequest) HeroIds(heroIds string) ApiPlayerHeroStatsRequest {
	r.heroIds = &heroIds
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiPlayerHeroStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiPlayerHeroStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiPlayerHeroStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiPlayerHeroStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiPlayerHeroStatsRequest) MinDurationS(minDurationS int64) ApiPlayerHeroStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiPlayerHeroStatsRequest) MaxDurationS(maxDurationS int64) ApiPlayerHeroStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their final net worth.
func (r ApiPlayerHeroStatsRequest) MinNetworth(minNetworth int64) ApiPlayerHeroStatsRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their final net worth.
func (r ApiPlayerHeroStatsRequest) MaxNetworth(maxNetworth int64) ApiPlayerHeroStatsRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiPlayerHeroStatsRequest) MinAverageBadge(minAverageBadge int32) ApiPlayerHeroStatsRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (tier &#x3D; first digits, subtier &#x3D; last digit) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiPlayerHeroStatsRequest) MaxAverageBadge(maxAverageBadge int32) ApiPlayerHeroStatsRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiPlayerHeroStatsRequest) MinMatchId(minMatchId int64) ApiPlayerHeroStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiPlayerHeroStatsRequest) MaxMatchId(maxMatchId int64) ApiPlayerHeroStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

func (r ApiPlayerHeroStatsRequest) Execute() ([]HeroStats, *http.Response, error) {
	return r.ApiService.PlayerHeroStatsExecute(r)
}

/*
PlayerHeroStats Hero Stats


This endpoint returns statistics for each hero played by a given player account.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlayerHeroStatsRequest
*/
func (a *PlayersAPIService) PlayerHeroStats(ctx context.Context) ApiPlayerHeroStatsRequest {
	return ApiPlayerHeroStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HeroStats
func (a *PlayersAPIService) PlayerHeroStatsExecute(r ApiPlayerHeroStatsRequest) ([]HeroStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeroStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.PlayerHeroStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/hero-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountIds == nil {
		return localVarReturnValue, nil, reportError("accountIds is required and must be specified")
	}
	if len(*r.accountIds) < 1 {
		return localVarReturnValue, nil, reportError("accountIds must have at least 1 elements")
	}
	if len(*r.accountIds) > 1000 {
		return localVarReturnValue, nil, reportError("accountIds must have less than 1000 elements")
	}

	{
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	if r.gameMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "game_mode", r.gameMode, "form", "")
	}
	if r.heroIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_ids", r.heroIds, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSteamRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	accountIds *[]int64
}

// Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
func (r ApiSteamRequest) AccountIds(accountIds []int64) ApiSteamRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiSteamRequest) Execute() ([]SteamProfile, *http.Response, error) {
	return r.ApiService.SteamExecute(r)
}

/*
Steam Batch Steam Profile


This endpoint returns Steam profiles of players.

See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSteamRequest
*/
func (a *PlayersAPIService) Steam(ctx context.Context) ApiSteamRequest {
	return ApiSteamRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SteamProfile
func (a *PlayersAPIService) SteamExecute(r ApiSteamRequest) ([]SteamProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SteamProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.Steam")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/steam"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountIds == nil {
		return localVarReturnValue, nil, reportError("accountIds is required and must be specified")
	}
	if len(*r.accountIds) < 1 {
		return localVarReturnValue, nil, reportError("accountIds must have at least 1 elements")
	}
	if len(*r.accountIds) > 1000 {
		return localVarReturnValue, nil, reportError("accountIds must have less than 1000 elements")
	}

	{
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSteamSearchRequest struct {
	ctx context.Context
	ApiService *PlayersAPIService
	searchQuery *string
}

// Search query for Steam profiles.
func (r ApiSteamSearchRequest) SearchQuery(searchQuery string) ApiSteamSearchRequest {
	r.searchQuery = &searchQuery
	return r
}

func (r ApiSteamSearchRequest) Execute() ([]SteamProfile, *http.Response, error) {
	return r.ApiService.SteamSearchExecute(r)
}

/*
SteamSearch Steam Profile Search


This endpoint lets you search for Steam profiles by account_id or personaname.

See: https://developer.valvesoftware.com/wiki/Steam_Web_API#GetPlayerSummaries_(v0002)

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSteamSearchRequest
*/
func (a *PlayersAPIService) SteamSearch(ctx context.Context) ApiSteamSearchRequest {
	return ApiSteamSearchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SteamProfile
func (a *PlayersAPIService) SteamSearchExecute(r ApiSteamSearchRequest) ([]SteamProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SteamProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlayersAPIService.SteamSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/steam-search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.searchQuery == nil {
		return localVarReturnValue, nil, reportError("searchQuery is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "search_query", r.searchQuery, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
