/*
Deadlock API

 ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package deadlock-api-client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// MatchesAPIService MatchesAPI service
type MatchesAPIService service

type ApiActiveMatchesRequest struct {
	ctx context.Context
	ApiService *MatchesAPIService
	accountId *int32
	accountIds *[]int32
}

// The account ID to filter active matches by (&#x60;SteamID3&#x60;)
// Deprecated
func (r ApiActiveMatchesRequest) AccountId(accountId int32) ApiActiveMatchesRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of account ids to include
func (r ApiActiveMatchesRequest) AccountIds(accountIds []int32) ApiActiveMatchesRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiActiveMatchesRequest) Execute() ([]ActiveMatch, *http.Response, error) {
	return r.ApiService.ActiveMatchesExecute(r)
}

/*
ActiveMatches Active


Returns active matches that are currently being played.

Fetched from the watch tab in game, which is limited to the **top 200 matches**.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiActiveMatchesRequest
*/
func (a *MatchesAPIService) ActiveMatches(ctx context.Context) ApiActiveMatchesRequest {
	return ApiActiveMatchesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ActiveMatch
func (a *MatchesAPIService) ActiveMatchesExecute(r ApiActiveMatchesRequest) ([]ActiveMatch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ActiveMatch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MatchesAPIService.ActiveMatches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/matches/active"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiActiveMatchesRawRequest struct {
	ctx context.Context
	ApiService *MatchesAPIService
}

func (r ApiActiveMatchesRawRequest) Execute() ([]int32, *http.Response, error) {
	return r.ApiService.ActiveMatchesRawExecute(r)
}

/*
ActiveMatchesRaw Active as Protobuf


Returns active matches that are currently being played, serialized as protobuf message.

Fetched from the watch tab in game, which is limited to the **top 200 matches**.

You have to decode the protobuf message.

Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)

Relevant Protobuf Message:
- CMsgClientToGcGetActiveMatchesResponse

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiActiveMatchesRawRequest
*/
func (a *MatchesAPIService) ActiveMatchesRaw(ctx context.Context) ApiActiveMatchesRawRequest {
	return ApiActiveMatchesRawRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int32
func (a *MatchesAPIService) ActiveMatchesRawExecute(r ApiActiveMatchesRawRequest) ([]int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MatchesAPIService.ActiveMatchesRaw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/matches/active/raw"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkMetadataRequest struct {
	ctx context.Context
	ApiService *MatchesAPIService
	includeInfo *bool
	includeObjectives *bool
	includeMidBoss *bool
	includePlayerInfo *bool
	includePlayerItems *bool
	includePlayerStats *bool
	includePlayerDeathDetails *bool
	matchIds *[]int64
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	isHighSkillRangeParties *bool
	isLowPriPool *bool
	isNewPlayerPool *bool
	accountIds *[]int32
	heroIds *string
	orderBy *string
	orderDirection *string
	limit *int32
}

// Include match info in the response.
func (r ApiBulkMetadataRequest) IncludeInfo(includeInfo bool) ApiBulkMetadataRequest {
	r.includeInfo = &includeInfo
	return r
}

// Include objectives in the response.
func (r ApiBulkMetadataRequest) IncludeObjectives(includeObjectives bool) ApiBulkMetadataRequest {
	r.includeObjectives = &includeObjectives
	return r
}

// Include midboss in the response.
func (r ApiBulkMetadataRequest) IncludeMidBoss(includeMidBoss bool) ApiBulkMetadataRequest {
	r.includeMidBoss = &includeMidBoss
	return r
}

// Include player info in the response.
func (r ApiBulkMetadataRequest) IncludePlayerInfo(includePlayerInfo bool) ApiBulkMetadataRequest {
	r.includePlayerInfo = &includePlayerInfo
	return r
}

// Include player items in the response.
func (r ApiBulkMetadataRequest) IncludePlayerItems(includePlayerItems bool) ApiBulkMetadataRequest {
	r.includePlayerItems = &includePlayerItems
	return r
}

// Include player stats in the response.
func (r ApiBulkMetadataRequest) IncludePlayerStats(includePlayerStats bool) ApiBulkMetadataRequest {
	r.includePlayerStats = &includePlayerStats
	return r
}

// Include player death details in the response.
func (r ApiBulkMetadataRequest) IncludePlayerDeathDetails(includePlayerDeathDetails bool) ApiBulkMetadataRequest {
	r.includePlayerDeathDetails = &includePlayerDeathDetails
	return r
}

// Comma separated list of match ids, limited by &#x60;limit&#x60;
func (r ApiBulkMetadataRequest) MatchIds(matchIds []int64) ApiBulkMetadataRequest {
	r.matchIds = &matchIds
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiBulkMetadataRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiBulkMetadataRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiBulkMetadataRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiBulkMetadataRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiBulkMetadataRequest) MinDurationS(minDurationS int64) ApiBulkMetadataRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiBulkMetadataRequest) MaxDurationS(maxDurationS int64) ApiBulkMetadataRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiBulkMetadataRequest) MinAverageBadge(minAverageBadge int32) ApiBulkMetadataRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiBulkMetadataRequest) MaxAverageBadge(maxAverageBadge int32) ApiBulkMetadataRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiBulkMetadataRequest) MinMatchId(minMatchId int64) ApiBulkMetadataRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiBulkMetadataRequest) MaxMatchId(maxMatchId int64) ApiBulkMetadataRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// Filter matches based on whether they are in the high skill range.
func (r ApiBulkMetadataRequest) IsHighSkillRangeParties(isHighSkillRangeParties bool) ApiBulkMetadataRequest {
	r.isHighSkillRangeParties = &isHighSkillRangeParties
	return r
}

// Filter matches based on whether they are in the low priority pool.
func (r ApiBulkMetadataRequest) IsLowPriPool(isLowPriPool bool) ApiBulkMetadataRequest {
	r.isLowPriPool = &isLowPriPool
	return r
}

// Filter matches based on whether they are in the new player pool.
func (r ApiBulkMetadataRequest) IsNewPlayerPool(isNewPlayerPool bool) ApiBulkMetadataRequest {
	r.isNewPlayerPool = &isNewPlayerPool
	return r
}

// Filter matches by account IDs of players that participated in the match.
func (r ApiBulkMetadataRequest) AccountIds(accountIds []int32) ApiBulkMetadataRequest {
	r.accountIds = &accountIds
	return r
}

// Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiBulkMetadataRequest) HeroIds(heroIds string) ApiBulkMetadataRequest {
	r.heroIds = &heroIds
	return r
}

// The field to order the results by.
func (r ApiBulkMetadataRequest) OrderBy(orderBy string) ApiBulkMetadataRequest {
	r.orderBy = &orderBy
	return r
}

// The direction to order the results by.
func (r ApiBulkMetadataRequest) OrderDirection(orderDirection string) ApiBulkMetadataRequest {
	r.orderDirection = &orderDirection
	return r
}

// The maximum number of matches to return.
func (r ApiBulkMetadataRequest) Limit(limit int32) ApiBulkMetadataRequest {
	r.limit = &limit
	return r
}

func (r ApiBulkMetadataRequest) Execute() ([]int32, *http.Response, error) {
	return r.ApiService.BulkMetadataExecute(r)
}

/*
BulkMetadata Bulk Metadata


This endpoints lets you fetch multiple match metadata at once. The response is a JSON array of match metadata.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 4req/s |
| Key | - |
| Global | 10req/s |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkMetadataRequest
*/
func (a *MatchesAPIService) BulkMetadata(ctx context.Context) ApiBulkMetadataRequest {
	return ApiBulkMetadataRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []int32
func (a *MatchesAPIService) BulkMetadataExecute(r ApiBulkMetadataRequest) ([]int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MatchesAPIService.BulkMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/matches/metadata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_info", r.includeInfo, "form", "")
	} else {
		var defaultValue bool = true
		r.includeInfo = &defaultValue
	}
	if r.includeObjectives != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_objectives", r.includeObjectives, "form", "")
	}
	if r.includeMidBoss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_mid_boss", r.includeMidBoss, "form", "")
	}
	if r.includePlayerInfo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_player_info", r.includePlayerInfo, "form", "")
	}
	if r.includePlayerItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_player_items", r.includePlayerItems, "form", "")
	}
	if r.includePlayerStats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_player_stats", r.includePlayerStats, "form", "")
	}
	if r.includePlayerDeathDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_player_death_details", r.includePlayerDeathDetails, "form", "")
	}
	if r.matchIds != nil {
		t := *r.matchIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "match_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "match_ids", t, "form", "multi")
		}
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.isHighSkillRangeParties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_high_skill_range_parties", r.isHighSkillRangeParties, "form", "")
	}
	if r.isLowPriPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_low_pri_pool", r.isLowPriPool, "form", "")
	}
	if r.isNewPlayerPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_new_player_pool", r.isNewPlayerPool, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	if r.heroIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_ids", r.heroIds, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.orderDirection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_direction", r.orderDirection, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 1000
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMetadataRequest struct {
	ctx context.Context
	ApiService *MatchesAPIService
	matchId int64
	isCustom *bool
}

func (r ApiMetadataRequest) IsCustom(isCustom bool) ApiMetadataRequest {
	r.isCustom = &isCustom
	return r
}

func (r ApiMetadataRequest) Execute() (*http.Response, error) {
	return r.ApiService.MetadataExecute(r)
}

/*
Metadata Metadata


This endpoint returns the match metadata for the given `match_id` parsed into JSON.

Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)

Relevant Protobuf Messages:
- CMsgMatchMetaData
- CMsgMatchMetaDataContents

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins |
| Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min |
| Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param matchId The match ID
 @return ApiMetadataRequest
*/
func (a *MatchesAPIService) Metadata(ctx context.Context, matchId int64) ApiMetadataRequest {
	return ApiMetadataRequest{
		ApiService: a,
		ctx: ctx,
		matchId: matchId,
	}
}

// Execute executes the request
func (a *MatchesAPIService) MetadataExecute(r ApiMetadataRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MatchesAPIService.Metadata")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/matches/{match_id}/metadata"
	localVarPath = strings.Replace(localVarPath, "{"+"match_id"+"}", url.PathEscape(parameterValueToString(r.matchId, "matchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.matchId < 0 {
		return nil, reportError("matchId must be greater than 0")
	}

	if r.isCustom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_custom", r.isCustom, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMetadataRawRequest struct {
	ctx context.Context
	ApiService *MatchesAPIService
	matchId int64
	isCustom *bool
}

func (r ApiMetadataRawRequest) IsCustom(isCustom bool) ApiMetadataRawRequest {
	r.isCustom = &isCustom
	return r
}

func (r ApiMetadataRawRequest) Execute() ([]int32, *http.Response, error) {
	return r.ApiService.MetadataRawExecute(r)
}

/*
MetadataRaw Metadata as Protobuf


This endpoints returns the raw .meta.bz2 file for the given `match_id`.

You have to decompress it and decode the protobuf message.

Protobuf definitions can be found here: [https://github.com/SteamDatabase/Protobufs](https://github.com/SteamDatabase/Protobufs)

Relevant Protobuf Messages:
- CMsgMatchMetaData
- CMsgMatchMetaDataContents

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | From Cache: 100req/s<br>From S3: 100req/10s<br>From Steam: 10req/30mins |
| Key | From Cache: 100req/s<br>From S3: 100req/s<br>From Steam: 10req/min |
| Global | From Cache: 100req/s<br>From S3: 700req/s<br>From Steam: 10req/10s |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param matchId The match ID
 @return ApiMetadataRawRequest
*/
func (a *MatchesAPIService) MetadataRaw(ctx context.Context, matchId int64) ApiMetadataRawRequest {
	return ApiMetadataRawRequest{
		ApiService: a,
		ctx: ctx,
		matchId: matchId,
	}
}

// Execute executes the request
//  @return []int32
func (a *MatchesAPIService) MetadataRawExecute(r ApiMetadataRawRequest) ([]int32, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MatchesAPIService.MetadataRaw")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/matches/{match_id}/metadata/raw"
	localVarPath = strings.Replace(localVarPath, "{"+"match_id"+"}", url.PathEscape(parameterValueToString(r.matchId, "matchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.matchId < 0 {
		return localVarReturnValue, nil, reportError("matchId must be greater than 0")
	}

	if r.isCustom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_custom", r.isCustom, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRecentlyFetchedRequest struct {
	ctx context.Context
	ApiService *MatchesAPIService
}

func (r ApiRecentlyFetchedRequest) Execute() ([]ClickhouseMatchInfo, *http.Response, error) {
	return r.ApiService.RecentlyFetchedExecute(r)
}

/*
RecentlyFetched Recently Fetched


This endpoint returns a list of match ids that have been fetched within the last 10 minutes.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRecentlyFetchedRequest
*/
func (a *MatchesAPIService) RecentlyFetched(ctx context.Context) ApiRecentlyFetchedRequest {
	return ApiRecentlyFetchedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ClickhouseMatchInfo
func (a *MatchesAPIService) RecentlyFetchedExecute(r ApiRecentlyFetchedRequest) ([]ClickhouseMatchInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ClickhouseMatchInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MatchesAPIService.RecentlyFetched")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/matches/recently-fetched"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSaltsRequest struct {
	ctx context.Context
	ApiService *MatchesAPIService
	matchId int64
}

func (r ApiSaltsRequest) Execute() (*MatchSaltsResponse, *http.Response, error) {
	return r.ApiService.SaltsExecute(r)
}

/*
Salts Salts


This endpoints returns salts that can be used to fetch metadata and demofile for a match.

**Note:** We currently fetch many matches without salts, so for these matches we do not have salts stored.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | From DB: 100req/s<br>From Steam: 10req/30mins |
| Key | From DB: -<br>From Steam: 10req/min |
| Global | From DB: -<br>From Steam: 10req/10s |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param matchId The match ID
 @return ApiSaltsRequest
*/
func (a *MatchesAPIService) Salts(ctx context.Context, matchId int64) ApiSaltsRequest {
	return ApiSaltsRequest{
		ApiService: a,
		ctx: ctx,
		matchId: matchId,
	}
}

// Execute executes the request
//  @return MatchSaltsResponse
func (a *MatchesAPIService) SaltsExecute(r ApiSaltsRequest) (*MatchSaltsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MatchSaltsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MatchesAPIService.Salts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/matches/{match_id}/salts"
	localVarPath = strings.Replace(localVarPath, "{"+"match_id"+"}", url.PathEscape(parameterValueToString(r.matchId, "matchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.matchId < 0 {
		return localVarReturnValue, nil, reportError("matchId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUrlRequest struct {
	ctx context.Context
	ApiService *MatchesAPIService
	matchId int64
}

func (r ApiUrlRequest) Execute() (*MatchSpectateResponse, *http.Response, error) {
	return r.ApiService.UrlExecute(r)
}

/*
Url Live Broadcast URL


This endpoints spectates a match and returns the live URL to be used in any demofile broadcast parser.

Example Parsers:
- [Demofile-Net](https://github.com/saul/demofile-net)
- [Haste](https://github.com/blukai/haste/)

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 10req/30mins |
| Key | 60req/min |
| Global | 100req/10s |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param matchId The match ID
 @return ApiUrlRequest
*/
func (a *MatchesAPIService) Url(ctx context.Context, matchId int64) ApiUrlRequest {
	return ApiUrlRequest{
		ApiService: a,
		ctx: ctx,
		matchId: matchId,
	}
}

// Execute executes the request
//  @return MatchSpectateResponse
func (a *MatchesAPIService) UrlExecute(r ApiUrlRequest) (*MatchSpectateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MatchSpectateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MatchesAPIService.Url")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/matches/{match_id}/live/url"
	localVarPath = strings.Replace(localVarPath, "{"+"match_id"+"}", url.PathEscape(parameterValueToString(r.matchId, "matchId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.matchId < 0 {
		return localVarReturnValue, nil, reportError("matchId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
