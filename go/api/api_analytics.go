/*
Deadlock API

 ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package deadlock-api-client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// AnalyticsAPIService AnalyticsAPI service
type AnalyticsAPIService service

type ApiAbilityOrderStatsRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	heroId *int32
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minAbilityUpgrades *int64
	maxAbilityUpgrades *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	minMatches *int32
	accountId *int32
	accountIds *[]int32
}

// See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiAbilityOrderStatsRequest) HeroId(heroId int32) ApiAbilityOrderStatsRequest {
	r.heroId = &heroId
	return r
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiAbilityOrderStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiAbilityOrderStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiAbilityOrderStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiAbilityOrderStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiAbilityOrderStatsRequest) MinDurationS(minDurationS int64) ApiAbilityOrderStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiAbilityOrderStatsRequest) MaxDurationS(maxDurationS int64) ApiAbilityOrderStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their minimum number of ability upgrades over the whole match.
func (r ApiAbilityOrderStatsRequest) MinAbilityUpgrades(minAbilityUpgrades int64) ApiAbilityOrderStatsRequest {
	r.minAbilityUpgrades = &minAbilityUpgrades
	return r
}

// Filter players based on their maximum number of ability upgrades over the whole match.
func (r ApiAbilityOrderStatsRequest) MaxAbilityUpgrades(maxAbilityUpgrades int64) ApiAbilityOrderStatsRequest {
	r.maxAbilityUpgrades = &maxAbilityUpgrades
	return r
}

// Filter players based on their net worth.
func (r ApiAbilityOrderStatsRequest) MinNetworth(minNetworth int64) ApiAbilityOrderStatsRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiAbilityOrderStatsRequest) MaxNetworth(maxNetworth int64) ApiAbilityOrderStatsRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiAbilityOrderStatsRequest) MinAverageBadge(minAverageBadge int32) ApiAbilityOrderStatsRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiAbilityOrderStatsRequest) MaxAverageBadge(maxAverageBadge int32) ApiAbilityOrderStatsRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiAbilityOrderStatsRequest) MinMatchId(minMatchId int64) ApiAbilityOrderStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiAbilityOrderStatsRequest) MaxMatchId(maxMatchId int64) ApiAbilityOrderStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// The minimum number of matches played for an ability order to be included in the response.
func (r ApiAbilityOrderStatsRequest) MinMatches(minMatches int32) ApiAbilityOrderStatsRequest {
	r.minMatches = &minMatches
	return r
}

// Filter for matches with a specific player account ID.
// Deprecated
func (r ApiAbilityOrderStatsRequest) AccountId(accountId int32) ApiAbilityOrderStatsRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of account ids to include
func (r ApiAbilityOrderStatsRequest) AccountIds(accountIds []int32) ApiAbilityOrderStatsRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiAbilityOrderStatsRequest) Execute() ([]AnalyticsAbilityOrderStats, *http.Response, error) {
	return r.ApiService.AbilityOrderStatsExecute(r)
}

/*
AbilityOrderStats Ability Order Stats


Retrieves statistics for the ability order of a hero.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAbilityOrderStatsRequest
*/
func (a *AnalyticsAPIService) AbilityOrderStats(ctx context.Context) ApiAbilityOrderStatsRequest {
	return ApiAbilityOrderStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AnalyticsAbilityOrderStats
func (a *AnalyticsAPIService) AbilityOrderStatsExecute(r ApiAbilityOrderStatsRequest) ([]AnalyticsAbilityOrderStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AnalyticsAbilityOrderStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.AbilityOrderStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/ability-order-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.heroId == nil {
		return localVarReturnValue, nil, reportError("heroId is required and must be specified")
	}
	if *r.heroId < 0 {
		return localVarReturnValue, nil, reportError("heroId must be greater than 0")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "form", "")
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minAbilityUpgrades != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_ability_upgrades", r.minAbilityUpgrades, "form", "")
	}
	if r.maxAbilityUpgrades != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_ability_upgrades", r.maxAbilityUpgrades, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.minMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_matches", r.minMatches, "form", "")
	} else {
		var defaultValue int32 = 20
		r.minMatches = &defaultValue
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBadgeDistributionRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	isHighSkillRangeParties *bool
	isLowPriPool *bool
	isNewPlayerPool *bool
	minMatchId *int64
	maxMatchId *int64
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiBadgeDistributionRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiBadgeDistributionRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiBadgeDistributionRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiBadgeDistributionRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiBadgeDistributionRequest) MinDurationS(minDurationS int64) ApiBadgeDistributionRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiBadgeDistributionRequest) MaxDurationS(maxDurationS int64) ApiBadgeDistributionRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter matches based on whether they are in the high skill range.
func (r ApiBadgeDistributionRequest) IsHighSkillRangeParties(isHighSkillRangeParties bool) ApiBadgeDistributionRequest {
	r.isHighSkillRangeParties = &isHighSkillRangeParties
	return r
}

// Filter matches based on whether they are in the low priority pool.
func (r ApiBadgeDistributionRequest) IsLowPriPool(isLowPriPool bool) ApiBadgeDistributionRequest {
	r.isLowPriPool = &isLowPriPool
	return r
}

// Filter matches based on whether they are in the new player pool.
func (r ApiBadgeDistributionRequest) IsNewPlayerPool(isNewPlayerPool bool) ApiBadgeDistributionRequest {
	r.isNewPlayerPool = &isNewPlayerPool
	return r
}

// Filter matches based on their ID.
func (r ApiBadgeDistributionRequest) MinMatchId(minMatchId int64) ApiBadgeDistributionRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiBadgeDistributionRequest) MaxMatchId(maxMatchId int64) ApiBadgeDistributionRequest {
	r.maxMatchId = &maxMatchId
	return r
}

func (r ApiBadgeDistributionRequest) Execute() ([]BadgeDistribution, *http.Response, error) {
	return r.ApiService.BadgeDistributionExecute(r)
}

/*
BadgeDistribution Badge Distribution


This endpoint returns the player badge distribution.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBadgeDistributionRequest
*/
func (a *AnalyticsAPIService) BadgeDistribution(ctx context.Context) ApiBadgeDistributionRequest {
	return ApiBadgeDistributionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BadgeDistribution
func (a *AnalyticsAPIService) BadgeDistributionExecute(r ApiBadgeDistributionRequest) ([]BadgeDistribution, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BadgeDistribution
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.BadgeDistribution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/badge-distribution"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.isHighSkillRangeParties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_high_skill_range_parties", r.isHighSkillRangeParties, "form", "")
	}
	if r.isLowPriPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_low_pri_pool", r.isLowPriPool, "form", "")
	}
	if r.isNewPlayerPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_new_player_pool", r.isNewPlayerPool, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBuildItemStatsRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	heroId *int32
	minLastUpdatedUnixTimestamp *int64
	maxLastUpdatedUnixTimestamp *int64
}

// Filter builds based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiBuildItemStatsRequest) HeroId(heroId int32) ApiBuildItemStatsRequest {
	r.heroId = &heroId
	return r
}

// Filter builds based on their last updated time (Unix timestamp). **Default:** 30 days ago.
func (r ApiBuildItemStatsRequest) MinLastUpdatedUnixTimestamp(minLastUpdatedUnixTimestamp int64) ApiBuildItemStatsRequest {
	r.minLastUpdatedUnixTimestamp = &minLastUpdatedUnixTimestamp
	return r
}

// Filter builds based on their last updated time (Unix timestamp).
func (r ApiBuildItemStatsRequest) MaxLastUpdatedUnixTimestamp(maxLastUpdatedUnixTimestamp int64) ApiBuildItemStatsRequest {
	r.maxLastUpdatedUnixTimestamp = &maxLastUpdatedUnixTimestamp
	return r
}

func (r ApiBuildItemStatsRequest) Execute() ([]BuildItemStats, *http.Response, error) {
	return r.ApiService.BuildItemStatsExecute(r)
}

/*
BuildItemStats Build Item Stats


Retrieves item statistics from hero builds.

Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBuildItemStatsRequest
*/
func (a *AnalyticsAPIService) BuildItemStats(ctx context.Context) ApiBuildItemStatsRequest {
	return ApiBuildItemStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []BuildItemStats
func (a *AnalyticsAPIService) BuildItemStatsExecute(r ApiBuildItemStatsRequest) ([]BuildItemStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []BuildItemStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.BuildItemStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/build-item-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "form", "")
	}
	if r.minLastUpdatedUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_last_updated_unix_timestamp", r.minLastUpdatedUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minLastUpdatedUnixTimestamp = &defaultValue
	}
	if r.maxLastUpdatedUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_last_updated_unix_timestamp", r.maxLastUpdatedUnixTimestamp, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeroCombStatsRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	includeHeroIds *[]int32
	excludeHeroIds *[]int32
	minMatches *int32
	maxMatches *int32
	combSize *int32
	accountId *int32
	accountIds *[]int32
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiHeroCombStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiHeroCombStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiHeroCombStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiHeroCombStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroCombStatsRequest) MinDurationS(minDurationS int64) ApiHeroCombStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroCombStatsRequest) MaxDurationS(maxDurationS int64) ApiHeroCombStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their net worth.
func (r ApiHeroCombStatsRequest) MinNetworth(minNetworth int64) ApiHeroCombStatsRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiHeroCombStatsRequest) MaxNetworth(maxNetworth int64) ApiHeroCombStatsRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroCombStatsRequest) MinAverageBadge(minAverageBadge int32) ApiHeroCombStatsRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroCombStatsRequest) MaxAverageBadge(maxAverageBadge int32) ApiHeroCombStatsRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiHeroCombStatsRequest) MinMatchId(minMatchId int64) ApiHeroCombStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiHeroCombStatsRequest) MaxMatchId(maxMatchId int64) ApiHeroCombStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// Comma separated list of hero ids to include. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiHeroCombStatsRequest) IncludeHeroIds(includeHeroIds []int32) ApiHeroCombStatsRequest {
	r.includeHeroIds = &includeHeroIds
	return r
}

// Comma separated list of hero ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiHeroCombStatsRequest) ExcludeHeroIds(excludeHeroIds []int32) ApiHeroCombStatsRequest {
	r.excludeHeroIds = &excludeHeroIds
	return r
}

// The minimum number of matches played for a hero combination to be included in the response.
func (r ApiHeroCombStatsRequest) MinMatches(minMatches int32) ApiHeroCombStatsRequest {
	r.minMatches = &minMatches
	return r
}

// The maximum number of matches played for a hero combination to be included in the response.
func (r ApiHeroCombStatsRequest) MaxMatches(maxMatches int32) ApiHeroCombStatsRequest {
	r.maxMatches = &maxMatches
	return r
}

// The combination size to return.
func (r ApiHeroCombStatsRequest) CombSize(combSize int32) ApiHeroCombStatsRequest {
	r.combSize = &combSize
	return r
}

// Filter for matches with a specific player account ID.
// Deprecated
func (r ApiHeroCombStatsRequest) AccountId(accountId int32) ApiHeroCombStatsRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of account ids to include
func (r ApiHeroCombStatsRequest) AccountIds(accountIds []int32) ApiHeroCombStatsRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiHeroCombStatsRequest) Execute() ([]HeroCombStats, *http.Response, error) {
	return r.ApiService.HeroCombStatsExecute(r)
}

/*
HeroCombStats Hero Comb Stats


Retrieves overall statistics for each hero combination.

Results are cached for **1 hour**. The cache key is determined by the specific combination of filter parameters used in the query. Subsequent requests using the exact same filters within this timeframe will receive the cached response.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHeroCombStatsRequest
*/
func (a *AnalyticsAPIService) HeroCombStats(ctx context.Context) ApiHeroCombStatsRequest {
	return ApiHeroCombStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HeroCombStats
func (a *AnalyticsAPIService) HeroCombStatsExecute(r ApiHeroCombStatsRequest) ([]HeroCombStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeroCombStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.HeroCombStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/hero-comb-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.includeHeroIds != nil {
		t := *r.includeHeroIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include_hero_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include_hero_ids", t, "form", "multi")
		}
	}
	if r.excludeHeroIds != nil {
		t := *r.excludeHeroIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_hero_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_hero_ids", t, "form", "multi")
		}
	}
	if r.minMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_matches", r.minMatches, "form", "")
	} else {
		var defaultValue int32 = 20
		r.minMatches = &defaultValue
	}
	if r.maxMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_matches", r.maxMatches, "form", "")
	}
	if r.combSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comb_size", r.combSize, "form", "")
	} else {
		var defaultValue int32 = 6
		r.combSize = &defaultValue
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeroCountersStatsRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minEnemyNetworth *int64
	maxEnemyNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	sameLaneFilter *bool
	minMatches *int64
	maxMatches *int32
	accountId *int32
	accountIds *[]int32
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiHeroCountersStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiHeroCountersStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiHeroCountersStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiHeroCountersStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroCountersStatsRequest) MinDurationS(minDurationS int64) ApiHeroCountersStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroCountersStatsRequest) MaxDurationS(maxDurationS int64) ApiHeroCountersStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their net worth.
func (r ApiHeroCountersStatsRequest) MinNetworth(minNetworth int64) ApiHeroCountersStatsRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiHeroCountersStatsRequest) MaxNetworth(maxNetworth int64) ApiHeroCountersStatsRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter enemy players based on their net worth.
func (r ApiHeroCountersStatsRequest) MinEnemyNetworth(minEnemyNetworth int64) ApiHeroCountersStatsRequest {
	r.minEnemyNetworth = &minEnemyNetworth
	return r
}

// Filter enemy players based on their net worth.
func (r ApiHeroCountersStatsRequest) MaxEnemyNetworth(maxEnemyNetworth int64) ApiHeroCountersStatsRequest {
	r.maxEnemyNetworth = &maxEnemyNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroCountersStatsRequest) MinAverageBadge(minAverageBadge int32) ApiHeroCountersStatsRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroCountersStatsRequest) MaxAverageBadge(maxAverageBadge int32) ApiHeroCountersStatsRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiHeroCountersStatsRequest) MinMatchId(minMatchId int64) ApiHeroCountersStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiHeroCountersStatsRequest) MaxMatchId(maxMatchId int64) ApiHeroCountersStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;enemy_hero_id&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
func (r ApiHeroCountersStatsRequest) SameLaneFilter(sameLaneFilter bool) ApiHeroCountersStatsRequest {
	r.sameLaneFilter = &sameLaneFilter
	return r
}

// The minimum number of matches played for a hero combination to be included in the response.
func (r ApiHeroCountersStatsRequest) MinMatches(minMatches int64) ApiHeroCountersStatsRequest {
	r.minMatches = &minMatches
	return r
}

// The maximum number of matches played for a hero combination to be included in the response.
func (r ApiHeroCountersStatsRequest) MaxMatches(maxMatches int32) ApiHeroCountersStatsRequest {
	r.maxMatches = &maxMatches
	return r
}

// Filter for matches with a specific player account ID.
// Deprecated
func (r ApiHeroCountersStatsRequest) AccountId(accountId int32) ApiHeroCountersStatsRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of account ids to include
func (r ApiHeroCountersStatsRequest) AccountIds(accountIds []int32) ApiHeroCountersStatsRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiHeroCountersStatsRequest) Execute() ([]HeroCounterStats, *http.Response, error) {
	return r.ApiService.HeroCountersStatsExecute(r)
}

/*
HeroCountersStats Hero Counter Stats


Retrieves hero-versus-hero matchup statistics based on historical match data.

This endpoint analyzes completed matches to calculate how often a specific hero (`hero_id`) wins against an enemy hero (`enemy_hero_id`) and the total number of times they have faced each other under the specified filter conditions.

Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHeroCountersStatsRequest
*/
func (a *AnalyticsAPIService) HeroCountersStats(ctx context.Context) ApiHeroCountersStatsRequest {
	return ApiHeroCountersStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HeroCounterStats
func (a *AnalyticsAPIService) HeroCountersStatsExecute(r ApiHeroCountersStatsRequest) ([]HeroCounterStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeroCounterStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.HeroCountersStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/hero-counter-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minEnemyNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_enemy_networth", r.minEnemyNetworth, "form", "")
	}
	if r.maxEnemyNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_enemy_networth", r.maxEnemyNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.sameLaneFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "same_lane_filter", r.sameLaneFilter, "form", "")
	} else {
		var defaultValue bool = true
		r.sameLaneFilter = &defaultValue
	}
	if r.minMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_matches", r.minMatches, "form", "")
	} else {
		var defaultValue int64 = 20
		r.minMatches = &defaultValue
	}
	if r.maxMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_matches", r.maxMatches, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeroScoreboardRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	sortBy *string
	sortDirection *string
	minMatches *int32
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	accountId *int32
	accountIds *[]int32
}

// The field to sort by.
func (r ApiHeroScoreboardRequest) SortBy(sortBy string) ApiHeroScoreboardRequest {
	r.sortBy = &sortBy
	return r
}

// The direction to sort heroes in.
func (r ApiHeroScoreboardRequest) SortDirection(sortDirection string) ApiHeroScoreboardRequest {
	r.sortDirection = &sortDirection
	return r
}

// Filter by min number of matches played.
func (r ApiHeroScoreboardRequest) MinMatches(minMatches int32) ApiHeroScoreboardRequest {
	r.minMatches = &minMatches
	return r
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiHeroScoreboardRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiHeroScoreboardRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiHeroScoreboardRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiHeroScoreboardRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroScoreboardRequest) MinDurationS(minDurationS int64) ApiHeroScoreboardRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroScoreboardRequest) MaxDurationS(maxDurationS int64) ApiHeroScoreboardRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their net worth.
func (r ApiHeroScoreboardRequest) MinNetworth(minNetworth int64) ApiHeroScoreboardRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiHeroScoreboardRequest) MaxNetworth(maxNetworth int64) ApiHeroScoreboardRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroScoreboardRequest) MinAverageBadge(minAverageBadge int32) ApiHeroScoreboardRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroScoreboardRequest) MaxAverageBadge(maxAverageBadge int32) ApiHeroScoreboardRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiHeroScoreboardRequest) MinMatchId(minMatchId int64) ApiHeroScoreboardRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiHeroScoreboardRequest) MaxMatchId(maxMatchId int64) ApiHeroScoreboardRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// Filter for matches with a specific player account ID.
// Deprecated
func (r ApiHeroScoreboardRequest) AccountId(accountId int32) ApiHeroScoreboardRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of account ids to include
func (r ApiHeroScoreboardRequest) AccountIds(accountIds []int32) ApiHeroScoreboardRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiHeroScoreboardRequest) Execute() ([]Entry, *http.Response, error) {
	return r.ApiService.HeroScoreboardExecute(r)
}

/*
HeroScoreboard Hero Scoreboard


This endpoint returns the hero scoreboard.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHeroScoreboardRequest
*/
func (a *AnalyticsAPIService) HeroScoreboard(ctx context.Context) ApiHeroScoreboardRequest {
	return ApiHeroScoreboardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Entry
func (a *AnalyticsAPIService) HeroScoreboardExecute(r ApiHeroScoreboardRequest) ([]Entry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Entry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.HeroScoreboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/scoreboards/heroes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sortBy == nil {
		return localVarReturnValue, nil, reportError("sortBy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	if r.sortDirection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_direction", r.sortDirection, "form", "")
	}
	if r.minMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_matches", r.minMatches, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeroStatsRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	bucket *string
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	minHeroMatches *int64
	maxHeroMatches *int64
	minHeroMatchesTotal *int64
	maxHeroMatchesTotal *int64
	includeItemIds *[]int32
	excludeItemIds *[]int32
	accountId *int32
	accountIds *[]int32
}

// Bucket allows you to group the stats by a specific field.
func (r ApiHeroStatsRequest) Bucket(bucket string) ApiHeroStatsRequest {
	r.bucket = &bucket
	return r
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiHeroStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiHeroStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiHeroStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiHeroStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroStatsRequest) MinDurationS(minDurationS int64) ApiHeroStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroStatsRequest) MaxDurationS(maxDurationS int64) ApiHeroStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their net worth.
func (r ApiHeroStatsRequest) MinNetworth(minNetworth int64) ApiHeroStatsRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiHeroStatsRequest) MaxNetworth(maxNetworth int64) ApiHeroStatsRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroStatsRequest) MinAverageBadge(minAverageBadge int32) ApiHeroStatsRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroStatsRequest) MaxAverageBadge(maxAverageBadge int32) ApiHeroStatsRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiHeroStatsRequest) MinMatchId(minMatchId int64) ApiHeroStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiHeroStatsRequest) MaxMatchId(maxMatchId int64) ApiHeroStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// Filter players based on the number of matches they have played with a specific hero within the filtered time range.
func (r ApiHeroStatsRequest) MinHeroMatches(minHeroMatches int64) ApiHeroStatsRequest {
	r.minHeroMatches = &minHeroMatches
	return r
}

// Filter players based on the number of matches they have played with a specific hero within the filtered time range.
func (r ApiHeroStatsRequest) MaxHeroMatches(maxHeroMatches int64) ApiHeroStatsRequest {
	r.maxHeroMatches = &maxHeroMatches
	return r
}

// Filter players based on the number of matches they have played with a specific hero in their entire history.
func (r ApiHeroStatsRequest) MinHeroMatchesTotal(minHeroMatchesTotal int64) ApiHeroStatsRequest {
	r.minHeroMatchesTotal = &minHeroMatchesTotal
	return r
}

// Filter players based on the number of matches they have played with a specific hero in their entire history.
func (r ApiHeroStatsRequest) MaxHeroMatchesTotal(maxHeroMatchesTotal int64) ApiHeroStatsRequest {
	r.maxHeroMatchesTotal = &maxHeroMatchesTotal
	return r
}

// Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
func (r ApiHeroStatsRequest) IncludeItemIds(includeItemIds []int32) ApiHeroStatsRequest {
	r.includeItemIds = &includeItemIds
	return r
}

// Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
func (r ApiHeroStatsRequest) ExcludeItemIds(excludeItemIds []int32) ApiHeroStatsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Filter for matches with a specific player account ID.
// Deprecated
func (r ApiHeroStatsRequest) AccountId(accountId int32) ApiHeroStatsRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of account ids to include
func (r ApiHeroStatsRequest) AccountIds(accountIds []int32) ApiHeroStatsRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiHeroStatsRequest) Execute() ([]AnalyticsHeroStats, *http.Response, error) {
	return r.ApiService.HeroStatsExecute(r)
}

/*
HeroStats Hero Stats


Retrieves performance statistics for each hero based on historical match data.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHeroStatsRequest
*/
func (a *AnalyticsAPIService) HeroStats(ctx context.Context) ApiHeroStatsRequest {
	return ApiHeroStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AnalyticsHeroStats
func (a *AnalyticsAPIService) HeroStatsExecute(r ApiHeroStatsRequest) ([]AnalyticsHeroStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []AnalyticsHeroStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.HeroStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/hero-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bucket != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket", r.bucket, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.minHeroMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_hero_matches", r.minHeroMatches, "form", "")
	}
	if r.maxHeroMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_hero_matches", r.maxHeroMatches, "form", "")
	}
	if r.minHeroMatchesTotal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_hero_matches_total", r.minHeroMatchesTotal, "form", "")
	}
	if r.maxHeroMatchesTotal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_hero_matches_total", r.maxHeroMatchesTotal, "form", "")
	}
	if r.includeItemIds != nil {
		t := *r.includeItemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include_item_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include_item_ids", t, "form", "multi")
		}
	}
	if r.excludeItemIds != nil {
		t := *r.excludeItemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_item_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_item_ids", t, "form", "multi")
		}
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeroSynergiesStatsRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	sameLaneFilter *bool
	samePartyFilter *bool
	minMatches *int64
	maxMatches *int32
	accountId *int32
	accountIds *[]int32
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiHeroSynergiesStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiHeroSynergiesStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiHeroSynergiesStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiHeroSynergiesStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroSynergiesStatsRequest) MinDurationS(minDurationS int64) ApiHeroSynergiesStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroSynergiesStatsRequest) MaxDurationS(maxDurationS int64) ApiHeroSynergiesStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their net worth.
func (r ApiHeroSynergiesStatsRequest) MinNetworth(minNetworth int64) ApiHeroSynergiesStatsRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiHeroSynergiesStatsRequest) MaxNetworth(maxNetworth int64) ApiHeroSynergiesStatsRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroSynergiesStatsRequest) MinAverageBadge(minAverageBadge int32) ApiHeroSynergiesStatsRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiHeroSynergiesStatsRequest) MaxAverageBadge(maxAverageBadge int32) ApiHeroSynergiesStatsRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiHeroSynergiesStatsRequest) MinMatchId(minMatchId int64) ApiHeroSynergiesStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiHeroSynergiesStatsRequest) MaxMatchId(maxMatchId int64) ApiHeroSynergiesStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id1&#x60; and &#x60;hero_id2&#x60; were assigned to the same lane (e.g., both Mid Lane). When &#x60;false&#x60;, considers all matchups regardless of assigned lane.
func (r ApiHeroSynergiesStatsRequest) SameLaneFilter(sameLaneFilter bool) ApiHeroSynergiesStatsRequest {
	r.sameLaneFilter = &sameLaneFilter
	return r
}

// When &#x60;true&#x60;, only considers matchups where both &#x60;hero_id&#x60; and &#x60;hero_id2&#x60; were on the same party. When &#x60;false&#x60;, considers all matchups regardless of party affiliation.
func (r ApiHeroSynergiesStatsRequest) SamePartyFilter(samePartyFilter bool) ApiHeroSynergiesStatsRequest {
	r.samePartyFilter = &samePartyFilter
	return r
}

// The minimum number of matches played for a hero combination to be included in the response.
func (r ApiHeroSynergiesStatsRequest) MinMatches(minMatches int64) ApiHeroSynergiesStatsRequest {
	r.minMatches = &minMatches
	return r
}

// The maximum number of matches played for a hero combination to be included in the response.
func (r ApiHeroSynergiesStatsRequest) MaxMatches(maxMatches int32) ApiHeroSynergiesStatsRequest {
	r.maxMatches = &maxMatches
	return r
}

// Filter for matches with a specific player account ID.
// Deprecated
func (r ApiHeroSynergiesStatsRequest) AccountId(accountId int32) ApiHeroSynergiesStatsRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of account ids to include
func (r ApiHeroSynergiesStatsRequest) AccountIds(accountIds []int32) ApiHeroSynergiesStatsRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiHeroSynergiesStatsRequest) Execute() ([]HeroSynergyStats, *http.Response, error) {
	return r.ApiService.HeroSynergiesStatsExecute(r)
}

/*
HeroSynergiesStats Hero Synergy Stats


Retrieves hero pair synergy statistics based on historical match data.

This endpoint analyzes completed matches to calculate how often a specific pair of heroes (`hero_id1` and `hero_id2`) won when playing *together on the same team*, and the total number of times they have played together under the specified filter conditions.

Results are cached for **1 hour** based on the combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHeroSynergiesStatsRequest
*/
func (a *AnalyticsAPIService) HeroSynergiesStats(ctx context.Context) ApiHeroSynergiesStatsRequest {
	return ApiHeroSynergiesStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []HeroSynergyStats
func (a *AnalyticsAPIService) HeroSynergiesStatsExecute(r ApiHeroSynergiesStatsRequest) ([]HeroSynergyStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []HeroSynergyStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.HeroSynergiesStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/hero-synergy-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.sameLaneFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "same_lane_filter", r.sameLaneFilter, "form", "")
	} else {
		var defaultValue bool = true
		r.sameLaneFilter = &defaultValue
	}
	if r.samePartyFilter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "same_party_filter", r.samePartyFilter, "form", "")
	} else {
		var defaultValue bool = true
		r.samePartyFilter = &defaultValue
	}
	if r.minMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_matches", r.minMatches, "form", "")
	} else {
		var defaultValue int64 = 20
		r.minMatches = &defaultValue
	}
	if r.maxMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_matches", r.maxMatches, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiItemPermutationStatsRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	itemIds *[]int32
	combSize *int32
	heroIds *string
	heroId *int32
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	accountId *int32
	accountIds *[]int32
}

// Comma separated list of item ids. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
func (r ApiItemPermutationStatsRequest) ItemIds(itemIds []int32) ApiItemPermutationStatsRequest {
	r.itemIds = &itemIds
	return r
}

// The combination size to return.
func (r ApiItemPermutationStatsRequest) CombSize(combSize int32) ApiItemPermutationStatsRequest {
	r.combSize = &combSize
	return r
}

// Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiItemPermutationStatsRequest) HeroIds(heroIds string) ApiItemPermutationStatsRequest {
	r.heroIds = &heroIds
	return r
}

// Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
// Deprecated
func (r ApiItemPermutationStatsRequest) HeroId(heroId int32) ApiItemPermutationStatsRequest {
	r.heroId = &heroId
	return r
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiItemPermutationStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiItemPermutationStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiItemPermutationStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiItemPermutationStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiItemPermutationStatsRequest) MinDurationS(minDurationS int64) ApiItemPermutationStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiItemPermutationStatsRequest) MaxDurationS(maxDurationS int64) ApiItemPermutationStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their net worth.
func (r ApiItemPermutationStatsRequest) MinNetworth(minNetworth int64) ApiItemPermutationStatsRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiItemPermutationStatsRequest) MaxNetworth(maxNetworth int64) ApiItemPermutationStatsRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiItemPermutationStatsRequest) MinAverageBadge(minAverageBadge int32) ApiItemPermutationStatsRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiItemPermutationStatsRequest) MaxAverageBadge(maxAverageBadge int32) ApiItemPermutationStatsRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiItemPermutationStatsRequest) MinMatchId(minMatchId int64) ApiItemPermutationStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiItemPermutationStatsRequest) MaxMatchId(maxMatchId int64) ApiItemPermutationStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// Filter for matches with a specific player account ID.
// Deprecated
func (r ApiItemPermutationStatsRequest) AccountId(accountId int32) ApiItemPermutationStatsRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of account ids to include
func (r ApiItemPermutationStatsRequest) AccountIds(accountIds []int32) ApiItemPermutationStatsRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiItemPermutationStatsRequest) Execute() ([]ItemPermutationStats, *http.Response, error) {
	return r.ApiService.ItemPermutationStatsExecute(r)
}

/*
ItemPermutationStats Item Permutation Stats


Retrieves item permutation statistics based on historical match data.

Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiItemPermutationStatsRequest
*/
func (a *AnalyticsAPIService) ItemPermutationStats(ctx context.Context) ApiItemPermutationStatsRequest {
	return ApiItemPermutationStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ItemPermutationStats
func (a *AnalyticsAPIService) ItemPermutationStatsExecute(r ApiItemPermutationStatsRequest) ([]ItemPermutationStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ItemPermutationStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.ItemPermutationStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/item-permutation-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.itemIds != nil {
		t := *r.itemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "item_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "item_ids", t, "form", "multi")
		}
	}
	if r.combSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "comb_size", r.combSize, "form", "")
	} else {
		var defaultValue int32 = 2
		r.combSize = &defaultValue
	}
	if r.heroIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_ids", r.heroIds, "form", "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiItemStatsRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	bucket *string
	heroIds *string
	heroId *int32
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	includeItemIds *[]int32
	excludeItemIds *[]int32
	minMatches *int32
	maxMatches *int32
	accountId *int32
	accountIds *[]int32
}

// Bucket allows you to group the stats by a specific field.
func (r ApiItemStatsRequest) Bucket(bucket string) ApiItemStatsRequest {
	r.bucket = &bucket
	return r
}

// Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiItemStatsRequest) HeroIds(heroIds string) ApiItemStatsRequest {
	r.heroIds = &heroIds
	return r
}

// Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
// Deprecated
func (r ApiItemStatsRequest) HeroId(heroId int32) ApiItemStatsRequest {
	r.heroId = &heroId
	return r
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiItemStatsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiItemStatsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiItemStatsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiItemStatsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiItemStatsRequest) MinDurationS(minDurationS int64) ApiItemStatsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiItemStatsRequest) MaxDurationS(maxDurationS int64) ApiItemStatsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their net worth.
func (r ApiItemStatsRequest) MinNetworth(minNetworth int64) ApiItemStatsRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiItemStatsRequest) MaxNetworth(maxNetworth int64) ApiItemStatsRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiItemStatsRequest) MinAverageBadge(minAverageBadge int32) ApiItemStatsRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiItemStatsRequest) MaxAverageBadge(maxAverageBadge int32) ApiItemStatsRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiItemStatsRequest) MinMatchId(minMatchId int64) ApiItemStatsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiItemStatsRequest) MaxMatchId(maxMatchId int64) ApiItemStatsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// Comma separated list of item ids to include. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
func (r ApiItemStatsRequest) IncludeItemIds(includeItemIds []int32) ApiItemStatsRequest {
	r.includeItemIds = &includeItemIds
	return r
}

// Comma separated list of item ids to exclude. See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
func (r ApiItemStatsRequest) ExcludeItemIds(excludeItemIds []int32) ApiItemStatsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// The minimum number of matches played for an item to be included in the response.
func (r ApiItemStatsRequest) MinMatches(minMatches int32) ApiItemStatsRequest {
	r.minMatches = &minMatches
	return r
}

// The maximum number of matches played for a hero combination to be included in the response.
func (r ApiItemStatsRequest) MaxMatches(maxMatches int32) ApiItemStatsRequest {
	r.maxMatches = &maxMatches
	return r
}

// Filter for matches with a specific player account ID.
// Deprecated
func (r ApiItemStatsRequest) AccountId(accountId int32) ApiItemStatsRequest {
	r.accountId = &accountId
	return r
}

// Comma separated list of account ids to include
func (r ApiItemStatsRequest) AccountIds(accountIds []int32) ApiItemStatsRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiItemStatsRequest) Execute() ([]ItemStats, *http.Response, error) {
	return r.ApiService.ItemStatsExecute(r)
}

/*
ItemStats Item Stats


Retrieves item statistics based on historical match data.

Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiItemStatsRequest
*/
func (a *AnalyticsAPIService) ItemStats(ctx context.Context) ApiItemStatsRequest {
	return ApiItemStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []ItemStats
func (a *AnalyticsAPIService) ItemStatsExecute(r ApiItemStatsRequest) ([]ItemStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ItemStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.ItemStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/item-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bucket != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bucket", r.bucket, "form", "")
	}
	if r.heroIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_ids", r.heroIds, "form", "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.includeItemIds != nil {
		t := *r.includeItemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include_item_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include_item_ids", t, "form", "multi")
		}
	}
	if r.excludeItemIds != nil {
		t := *r.excludeItemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_item_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_item_ids", t, "form", "multi")
		}
	}
	if r.minMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_matches", r.minMatches, "form", "")
	} else {
		var defaultValue int32 = 20
		r.minMatches = &defaultValue
	}
	if r.maxMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_matches", r.maxMatches, "form", "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlayerScoreboardRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	sortBy *string
	sortDirection *string
	heroId *int32
	minMatches *int32
	maxMatches *int32
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	start *int32
	limit *int32
	accountIds *[]int32
}

// The field to sort by.
func (r ApiPlayerScoreboardRequest) SortBy(sortBy string) ApiPlayerScoreboardRequest {
	r.sortBy = &sortBy
	return r
}

// The direction to sort players in.
func (r ApiPlayerScoreboardRequest) SortDirection(sortDirection string) ApiPlayerScoreboardRequest {
	r.sortDirection = &sortDirection
	return r
}

// Filter matches based on the hero ID. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiPlayerScoreboardRequest) HeroId(heroId int32) ApiPlayerScoreboardRequest {
	r.heroId = &heroId
	return r
}

// The minimum number of matches played for a player to be included in the scoreboard.
func (r ApiPlayerScoreboardRequest) MinMatches(minMatches int32) ApiPlayerScoreboardRequest {
	r.minMatches = &minMatches
	return r
}

// The maximum number of matches played for a hero combination to be included in the response.
func (r ApiPlayerScoreboardRequest) MaxMatches(maxMatches int32) ApiPlayerScoreboardRequest {
	r.maxMatches = &maxMatches
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiPlayerScoreboardRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiPlayerScoreboardRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiPlayerScoreboardRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiPlayerScoreboardRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiPlayerScoreboardRequest) MinDurationS(minDurationS int64) ApiPlayerScoreboardRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiPlayerScoreboardRequest) MaxDurationS(maxDurationS int64) ApiPlayerScoreboardRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their net worth.
func (r ApiPlayerScoreboardRequest) MinNetworth(minNetworth int64) ApiPlayerScoreboardRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiPlayerScoreboardRequest) MaxNetworth(maxNetworth int64) ApiPlayerScoreboardRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiPlayerScoreboardRequest) MinAverageBadge(minAverageBadge int32) ApiPlayerScoreboardRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiPlayerScoreboardRequest) MaxAverageBadge(maxAverageBadge int32) ApiPlayerScoreboardRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiPlayerScoreboardRequest) MinMatchId(minMatchId int64) ApiPlayerScoreboardRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiPlayerScoreboardRequest) MaxMatchId(maxMatchId int64) ApiPlayerScoreboardRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// The offset to start fetching players from.
func (r ApiPlayerScoreboardRequest) Start(start int32) ApiPlayerScoreboardRequest {
	r.start = &start
	return r
}

// The maximum number of players to fetch.
func (r ApiPlayerScoreboardRequest) Limit(limit int32) ApiPlayerScoreboardRequest {
	r.limit = &limit
	return r
}

// Comma separated list of account ids to include
func (r ApiPlayerScoreboardRequest) AccountIds(accountIds []int32) ApiPlayerScoreboardRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiPlayerScoreboardRequest) Execute() ([]Entry, *http.Response, error) {
	return r.ApiService.PlayerScoreboardExecute(r)
}

/*
PlayerScoreboard Player Scoreboard


This endpoint returns the player scoreboard.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlayerScoreboardRequest
*/
func (a *AnalyticsAPIService) PlayerScoreboard(ctx context.Context) ApiPlayerScoreboardRequest {
	return ApiPlayerScoreboardRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Entry
func (a *AnalyticsAPIService) PlayerScoreboardExecute(r ApiPlayerScoreboardRequest) ([]Entry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Entry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.PlayerScoreboard")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/scoreboards/players"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sortBy == nil {
		return localVarReturnValue, nil, reportError("sortBy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	if r.sortDirection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_direction", r.sortDirection, "form", "")
	}
	if r.heroId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_id", r.heroId, "form", "")
	}
	if r.minMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_matches", r.minMatches, "form", "")
	} else {
		var defaultValue int32 = 20
		r.minMatches = &defaultValue
	}
	if r.maxMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_matches", r.maxMatches, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlayerStatsMetricsRequest struct {
	ctx context.Context
	ApiService *AnalyticsAPIService
	heroIds *string
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	minNetworth *int64
	maxNetworth *int64
	minAverageBadge *int32
	maxAverageBadge *int32
	minMatchId *int64
	maxMatchId *int64
	maxMatches *int32
	includeItemIds *[]int32
	excludeItemIds *[]int32
	accountIds *[]int32
}

// Filter matches based on the hero IDs. See more: &lt;https://assets.deadlock-api.com/v2/heroes&gt;
func (r ApiPlayerStatsMetricsRequest) HeroIds(heroIds string) ApiPlayerStatsMetricsRequest {
	r.heroIds = &heroIds
	return r
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiPlayerStatsMetricsRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiPlayerStatsMetricsRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiPlayerStatsMetricsRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiPlayerStatsMetricsRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiPlayerStatsMetricsRequest) MinDurationS(minDurationS int64) ApiPlayerStatsMetricsRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiPlayerStatsMetricsRequest) MaxDurationS(maxDurationS int64) ApiPlayerStatsMetricsRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter players based on their net worth.
func (r ApiPlayerStatsMetricsRequest) MinNetworth(minNetworth int64) ApiPlayerStatsMetricsRequest {
	r.minNetworth = &minNetworth
	return r
}

// Filter players based on their net worth.
func (r ApiPlayerStatsMetricsRequest) MaxNetworth(maxNetworth int64) ApiPlayerStatsMetricsRequest {
	r.maxNetworth = &maxNetworth
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiPlayerStatsMetricsRequest) MinAverageBadge(minAverageBadge int32) ApiPlayerStatsMetricsRequest {
	r.minAverageBadge = &minAverageBadge
	return r
}

// Filter matches based on the average badge level (0-116) of *both* teams involved. See more: &lt;https://assets.deadlock-api.com/v2/ranks&gt;
func (r ApiPlayerStatsMetricsRequest) MaxAverageBadge(maxAverageBadge int32) ApiPlayerStatsMetricsRequest {
	r.maxAverageBadge = &maxAverageBadge
	return r
}

// Filter matches based on their ID.
func (r ApiPlayerStatsMetricsRequest) MinMatchId(minMatchId int64) ApiPlayerStatsMetricsRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiPlayerStatsMetricsRequest) MaxMatchId(maxMatchId int64) ApiPlayerStatsMetricsRequest {
	r.maxMatchId = &maxMatchId
	return r
}

// The maximum number of matches to analyze.
func (r ApiPlayerStatsMetricsRequest) MaxMatches(maxMatches int32) ApiPlayerStatsMetricsRequest {
	r.maxMatches = &maxMatches
	return r
}

// Comma separated list of item ids to include (only heroes who have purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
func (r ApiPlayerStatsMetricsRequest) IncludeItemIds(includeItemIds []int32) ApiPlayerStatsMetricsRequest {
	r.includeItemIds = &includeItemIds
	return r
}

// Comma separated list of item ids to exclude (only heroes who have not purchased these items). See more: &lt;https://assets.deadlock-api.com/v2/items&gt;
func (r ApiPlayerStatsMetricsRequest) ExcludeItemIds(excludeItemIds []int32) ApiPlayerStatsMetricsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Comma separated list of account ids to include
func (r ApiPlayerStatsMetricsRequest) AccountIds(accountIds []int32) ApiPlayerStatsMetricsRequest {
	r.accountIds = &accountIds
	return r
}

func (r ApiPlayerStatsMetricsRequest) Execute() (*map[string]HashMapValue, *http.Response, error) {
	return r.ApiService.PlayerStatsMetricsExecute(r)
}

/*
PlayerStatsMetrics Player Stats Metrics


Returns comprehensive statistical analysis of player performance.

Results are cached for **1 hour** based on the unique combination of query parameters provided. Subsequent identical requests within this timeframe will receive the cached response.

> Note: Quantiles are calculated using the [DDSketch](https://www.vldb.org/pvldb/vol12/p2195-masson.pdf) algorithm, so they are not exact but have a maximum relative error of 0.01.

### Rate Limits:
| Type | Limit |
| ---- | ----- |
| IP | 100req/s |
| Key | - |
| Global | - |
    

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPlayerStatsMetricsRequest
*/
func (a *AnalyticsAPIService) PlayerStatsMetrics(ctx context.Context) ApiPlayerStatsMetricsRequest {
	return ApiPlayerStatsMetricsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]HashMapValue
func (a *AnalyticsAPIService) PlayerStatsMetricsExecute(r ApiPlayerStatsMetricsRequest) (*map[string]HashMapValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]HashMapValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnalyticsAPIService.PlayerStatsMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/analytics/player-stats/metrics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.heroIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hero_ids", r.heroIds, "form", "")
	}
	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
		var defaultValue int64 = 1759017600
		r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.minNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_networth", r.minNetworth, "form", "")
	}
	if r.maxNetworth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_networth", r.maxNetworth, "form", "")
	}
	if r.minAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_average_badge", r.minAverageBadge, "form", "")
	}
	if r.maxAverageBadge != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_average_badge", r.maxAverageBadge, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	if r.maxMatches != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_matches", r.maxMatches, "form", "")
	}
	if r.includeItemIds != nil {
		t := *r.includeItemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include_item_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include_item_ids", t, "form", "multi")
		}
	}
	if r.excludeItemIds != nil {
		t := *r.excludeItemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_item_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_item_ids", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
