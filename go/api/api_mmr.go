/*
Deadlock API

 ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package deadlock-api-client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// MMRAPIService MMRAPI service
type MMRAPIService service

type ApiHeroMmrRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	accountIds *[]int32
	heroId int32
	maxMatchId *int64
}

// Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
func (r ApiHeroMmrRequest) AccountIds(accountIds []int32) ApiHeroMmrRequest {
	r.accountIds = &accountIds
	return r
}

// Filter matches based on their ID.
func (r ApiHeroMmrRequest) MaxMatchId(maxMatchId int64) ApiHeroMmrRequest {
	r.maxMatchId = &maxMatchId
	return r
}

func (r ApiHeroMmrRequest) Execute() ([]MMRHistory, *http.Response, error) {
	return r.ApiService.HeroMmrExecute(r)
}

/*
HeroMmr Hero MMR


Batch Player Hero MMR

Filters for the last 90 days if no `max_match_id` is provided.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param heroId The hero ID to fetch the MMR history for. See more: <https://assets.deadlock-api.com/v2/heroes>
 @return ApiHeroMmrRequest
*/
func (a *MMRAPIService) HeroMmr(ctx context.Context, heroId int32) ApiHeroMmrRequest {
	return ApiHeroMmrRequest{
		ApiService: a,
		ctx: ctx,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return []MMRHistory
func (a *MMRAPIService) HeroMmrExecute(r ApiHeroMmrRequest) ([]MMRHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MMRHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.HeroMmr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/mmr/{hero_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountIds == nil {
		return localVarReturnValue, nil, reportError("accountIds is required and must be specified")
	}
	if len(*r.accountIds) < 1 {
		return localVarReturnValue, nil, reportError("accountIds must have at least 1 elements")
	}
	if len(*r.accountIds) > 1000 {
		return localVarReturnValue, nil, reportError("accountIds must have less than 1000 elements")
	}
	if r.heroId < 0 {
		return localVarReturnValue, nil, reportError("heroId must be greater than 0")
	}

	{
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "multi")
		}
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeroMmrHistoryRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	accountId int32
	heroId int32
}

func (r ApiHeroMmrHistoryRequest) Execute() ([]MMRHistory, *http.Response, error) {
	return r.ApiService.HeroMmrHistoryExecute(r)
}

/*
HeroMmrHistory Hero MMR History

Player Hero MMR History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The players `SteamID3`
 @param heroId The hero ID to fetch the MMR history for. See more: <https://assets.deadlock-api.com/v2/heroes>
 @return ApiHeroMmrHistoryRequest
*/
func (a *MMRAPIService) HeroMmrHistory(ctx context.Context, accountId int32, heroId int32) ApiHeroMmrHistoryRequest {
	return ApiHeroMmrHistoryRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return []MMRHistory
func (a *MMRAPIService) HeroMmrHistoryExecute(r ApiHeroMmrHistoryRequest) ([]MMRHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MMRHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.HeroMmrHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/{account_id}/mmr-history/{hero_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId < 0 {
		return localVarReturnValue, nil, reportError("accountId must be greater than 0")
	}
	if r.heroId < 0 {
		return localVarReturnValue, nil, reportError("heroId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMmrRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	accountIds *[]int32
	maxMatchId *int64
}

// Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
func (r ApiMmrRequest) AccountIds(accountIds []int32) ApiMmrRequest {
	r.accountIds = &accountIds
	return r
}

// Filter matches based on their ID.
func (r ApiMmrRequest) MaxMatchId(maxMatchId int64) ApiMmrRequest {
	r.maxMatchId = &maxMatchId
	return r
}

func (r ApiMmrRequest) Execute() ([]MMRHistory, *http.Response, error) {
	return r.ApiService.MmrExecute(r)
}

/*
Mmr MMR


Batch Player MMR

Filters for the last 90 days if no `max_match_id` is provided.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMmrRequest
*/
func (a *MMRAPIService) Mmr(ctx context.Context) ApiMmrRequest {
	return ApiMmrRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MMRHistory
func (a *MMRAPIService) MmrExecute(r ApiMmrRequest) ([]MMRHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MMRHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.Mmr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/mmr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountIds == nil {
		return localVarReturnValue, nil, reportError("accountIds is required and must be specified")
	}
	if len(*r.accountIds) < 1 {
		return localVarReturnValue, nil, reportError("accountIds must have at least 1 elements")
	}
	if len(*r.accountIds) > 1000 {
		return localVarReturnValue, nil, reportError("accountIds must have less than 1000 elements")
	}

	{
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "multi")
		}
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMmrHistoryRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	accountId int32
}

func (r ApiMmrHistoryRequest) Execute() ([]MMRHistory, *http.Response, error) {
	return r.ApiService.MmrHistoryExecute(r)
}

/*
MmrHistory MMR History

Player MMR History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The players `SteamID3`
 @return ApiMmrHistoryRequest
*/
func (a *MMRAPIService) MmrHistory(ctx context.Context, accountId int32) ApiMmrHistoryRequest {
	return ApiMmrHistoryRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []MMRHistory
func (a *MMRAPIService) MmrHistoryExecute(r ApiMmrHistoryRequest) ([]MMRHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MMRHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.MmrHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/{account_id}/mmr-history"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId < 0 {
		return localVarReturnValue, nil, reportError("accountId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
