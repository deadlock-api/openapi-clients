/*
Deadlock API

 ## API Clients  We have auto generated and updated clients for many languages. You can find them here: [https://github.com/deadlock-api/openapi-clients](https://github.com/deadlock-api/openapi-clients)  ## Support the Deadlock API  Whether you're building your own database, developing data science projects, or enhancing your website with game and player analytics, the Deadlock API has the data you need.  Your sponsorship helps keep this resource open, free and future-proof for everyone. By supporting the Deadlock API, you will enable continued development, new features and reliable access for developers, analysts and streamers worldwide.  Help us continue to provide the data you need - sponsor the Deadlock API today!  **-> You can Sponsor the Deadlock API on [Patreon](https://www.patreon.com/c/user?u=68961896) or [GitHub](https://github.com/sponsors/raimannma)**  ## Disclaimer _deadlock-api.com is not endorsed by Valve and does not reflect the views or opinions of Valve or anyone officially involved in producing or managing Valve properties. Valve and all associated properties are trademarks or registered trademarks of Valve Corporation_         

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package deadlock_api_client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// MMRAPIService MMRAPI service
type MMRAPIService service

type ApiHeroMmrRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	accountIds *[]int32
	heroId int32
	maxMatchId *int64
}

// Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
func (r ApiHeroMmrRequest) AccountIds(accountIds []int32) ApiHeroMmrRequest {
	r.accountIds = &accountIds
	return r
}

// Filter matches based on their ID.
func (r ApiHeroMmrRequest) MaxMatchId(maxMatchId int64) ApiHeroMmrRequest {
	r.maxMatchId = &maxMatchId
	return r
}

func (r ApiHeroMmrRequest) Execute() ([]MMRHistory, *http.Response, error) {
	return r.ApiService.HeroMmrExecute(r)
}

/*
HeroMmr Batch Hero MMR


Batch Player Hero MMR


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param heroId The hero ID to fetch the MMR history for. See more: <https://assets.deadlock-api.com/v2/heroes>
 @return ApiHeroMmrRequest
*/
func (a *MMRAPIService) HeroMmr(ctx context.Context, heroId int32) ApiHeroMmrRequest {
	return ApiHeroMmrRequest{
		ApiService: a,
		ctx: ctx,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return []MMRHistory
func (a *MMRAPIService) HeroMmrExecute(r ApiHeroMmrRequest) ([]MMRHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MMRHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.HeroMmr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/mmr/{hero_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountIds == nil {
		return localVarReturnValue, nil, reportError("accountIds is required and must be specified")
	}
	if len(*r.accountIds) < 1 {
		return localVarReturnValue, nil, reportError("accountIds must have at least 1 elements")
	}
	if len(*r.accountIds) > 1000 {
		return localVarReturnValue, nil, reportError("accountIds must have less than 1000 elements")
	}
	if r.heroId < 0 {
		return localVarReturnValue, nil, reportError("heroId must be greater than 0")
	}

	{
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeroMmrDistributionRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	heroId int32
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	isHighSkillRangeParties *bool
	isLowPriPool *bool
	isNewPlayerPool *bool
	minMatchId *int64
	maxMatchId *int64
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiHeroMmrDistributionRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiHeroMmrDistributionRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiHeroMmrDistributionRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiHeroMmrDistributionRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroMmrDistributionRequest) MinDurationS(minDurationS int64) ApiHeroMmrDistributionRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiHeroMmrDistributionRequest) MaxDurationS(maxDurationS int64) ApiHeroMmrDistributionRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter matches based on whether they are in the high skill range.
func (r ApiHeroMmrDistributionRequest) IsHighSkillRangeParties(isHighSkillRangeParties bool) ApiHeroMmrDistributionRequest {
	r.isHighSkillRangeParties = &isHighSkillRangeParties
	return r
}

// Filter matches based on whether they are in the low priority pool.
func (r ApiHeroMmrDistributionRequest) IsLowPriPool(isLowPriPool bool) ApiHeroMmrDistributionRequest {
	r.isLowPriPool = &isLowPriPool
	return r
}

// Filter matches based on whether they are in the new player pool.
func (r ApiHeroMmrDistributionRequest) IsNewPlayerPool(isNewPlayerPool bool) ApiHeroMmrDistributionRequest {
	r.isNewPlayerPool = &isNewPlayerPool
	return r
}

// Filter matches based on their ID.
func (r ApiHeroMmrDistributionRequest) MinMatchId(minMatchId int64) ApiHeroMmrDistributionRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiHeroMmrDistributionRequest) MaxMatchId(maxMatchId int64) ApiHeroMmrDistributionRequest {
	r.maxMatchId = &maxMatchId
	return r
}

func (r ApiHeroMmrDistributionRequest) Execute() ([]DistributionEntry, *http.Response, error) {
	return r.ApiService.HeroMmrDistributionExecute(r)
}

/*
HeroMmrDistribution Hero MMR Distribution


Player Hero MMR Distribution


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param heroId The hero ID to fetch the MMR history for. See more: <https://assets.deadlock-api.com/v2/heroes>
 @return ApiHeroMmrDistributionRequest
*/
func (a *MMRAPIService) HeroMmrDistribution(ctx context.Context, heroId int32) ApiHeroMmrDistributionRequest {
	return ApiHeroMmrDistributionRequest{
		ApiService: a,
		ctx: ctx,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return []DistributionEntry
func (a *MMRAPIService) HeroMmrDistributionExecute(r ApiHeroMmrDistributionRequest) ([]DistributionEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DistributionEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.HeroMmrDistribution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/mmr/distribution/{hero_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.heroId < 0 {
		return localVarReturnValue, nil, reportError("heroId must be greater than 0")
	}

	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
        var defaultValue int64 = 1763596800
        parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", defaultValue, "form", "")
        r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.isHighSkillRangeParties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_high_skill_range_parties", r.isHighSkillRangeParties, "form", "")
	}
	if r.isLowPriPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_low_pri_pool", r.isLowPriPool, "form", "")
	}
	if r.isNewPlayerPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_new_player_pool", r.isNewPlayerPool, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeroMmrHistoryRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	accountId int32
	heroId int32
}

func (r ApiHeroMmrHistoryRequest) Execute() ([]MMRHistory, *http.Response, error) {
	return r.ApiService.HeroMmrHistoryExecute(r)
}

/*
HeroMmrHistory Hero MMR History

Player Hero MMR History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The players `SteamID3`
 @param heroId The hero ID to fetch the MMR history for. See more: <https://assets.deadlock-api.com/v2/heroes>
 @return ApiHeroMmrHistoryRequest
*/
func (a *MMRAPIService) HeroMmrHistory(ctx context.Context, accountId int32, heroId int32) ApiHeroMmrHistoryRequest {
	return ApiHeroMmrHistoryRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
		heroId: heroId,
	}
}

// Execute executes the request
//  @return []MMRHistory
func (a *MMRAPIService) HeroMmrHistoryExecute(r ApiHeroMmrHistoryRequest) ([]MMRHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MMRHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.HeroMmrHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/{account_id}/mmr-history/{hero_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"hero_id"+"}", url.PathEscape(parameterValueToString(r.heroId, "heroId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId < 0 {
		return localVarReturnValue, nil, reportError("accountId must be greater than 0")
	}
	if r.heroId < 0 {
		return localVarReturnValue, nil, reportError("heroId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMmrRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	accountIds *[]int32
	maxMatchId *int64
}

// Comma separated list of account ids, Account IDs are in &#x60;SteamID3&#x60; format.
func (r ApiMmrRequest) AccountIds(accountIds []int32) ApiMmrRequest {
	r.accountIds = &accountIds
	return r
}

// Filter matches based on their ID.
func (r ApiMmrRequest) MaxMatchId(maxMatchId int64) ApiMmrRequest {
	r.maxMatchId = &maxMatchId
	return r
}

func (r ApiMmrRequest) Execute() ([]MMRHistory, *http.Response, error) {
	return r.ApiService.MmrExecute(r)
}

/*
Mmr Batch MMR


Batch Player MMR


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMmrRequest
*/
func (a *MMRAPIService) Mmr(ctx context.Context) ApiMmrRequest {
	return ApiMmrRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MMRHistory
func (a *MMRAPIService) MmrExecute(r ApiMmrRequest) ([]MMRHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MMRHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.Mmr")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/mmr"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountIds == nil {
		return localVarReturnValue, nil, reportError("accountIds is required and must be specified")
	}
	if len(*r.accountIds) < 1 {
		return localVarReturnValue, nil, reportError("accountIds must have at least 1 elements")
	}
	if len(*r.accountIds) > 1000 {
		return localVarReturnValue, nil, reportError("accountIds must have less than 1000 elements")
	}

	{
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMmrDistributionRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	minUnixTimestamp *int64
	maxUnixTimestamp *int64
	minDurationS *int64
	maxDurationS *int64
	isHighSkillRangeParties *bool
	isLowPriPool *bool
	isNewPlayerPool *bool
	minMatchId *int64
	maxMatchId *int64
}

// Filter matches based on their start time (Unix timestamp). **Default:** 30 days ago.
func (r ApiMmrDistributionRequest) MinUnixTimestamp(minUnixTimestamp int64) ApiMmrDistributionRequest {
	r.minUnixTimestamp = &minUnixTimestamp
	return r
}

// Filter matches based on their start time (Unix timestamp).
func (r ApiMmrDistributionRequest) MaxUnixTimestamp(maxUnixTimestamp int64) ApiMmrDistributionRequest {
	r.maxUnixTimestamp = &maxUnixTimestamp
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiMmrDistributionRequest) MinDurationS(minDurationS int64) ApiMmrDistributionRequest {
	r.minDurationS = &minDurationS
	return r
}

// Filter matches based on their duration in seconds (up to 7000s).
func (r ApiMmrDistributionRequest) MaxDurationS(maxDurationS int64) ApiMmrDistributionRequest {
	r.maxDurationS = &maxDurationS
	return r
}

// Filter matches based on whether they are in the high skill range.
func (r ApiMmrDistributionRequest) IsHighSkillRangeParties(isHighSkillRangeParties bool) ApiMmrDistributionRequest {
	r.isHighSkillRangeParties = &isHighSkillRangeParties
	return r
}

// Filter matches based on whether they are in the low priority pool.
func (r ApiMmrDistributionRequest) IsLowPriPool(isLowPriPool bool) ApiMmrDistributionRequest {
	r.isLowPriPool = &isLowPriPool
	return r
}

// Filter matches based on whether they are in the new player pool.
func (r ApiMmrDistributionRequest) IsNewPlayerPool(isNewPlayerPool bool) ApiMmrDistributionRequest {
	r.isNewPlayerPool = &isNewPlayerPool
	return r
}

// Filter matches based on their ID.
func (r ApiMmrDistributionRequest) MinMatchId(minMatchId int64) ApiMmrDistributionRequest {
	r.minMatchId = &minMatchId
	return r
}

// Filter matches based on their ID.
func (r ApiMmrDistributionRequest) MaxMatchId(maxMatchId int64) ApiMmrDistributionRequest {
	r.maxMatchId = &maxMatchId
	return r
}

func (r ApiMmrDistributionRequest) Execute() ([]DistributionEntry, *http.Response, error) {
	return r.ApiService.MmrDistributionExecute(r)
}

/*
MmrDistribution MMR Distribution


Player MMR Distribution


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMmrDistributionRequest
*/
func (a *MMRAPIService) MmrDistribution(ctx context.Context) ApiMmrDistributionRequest {
	return ApiMmrDistributionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DistributionEntry
func (a *MMRAPIService) MmrDistributionExecute(r ApiMmrDistributionRequest) ([]DistributionEntry, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DistributionEntry
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.MmrDistribution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/mmr/distribution"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.minUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", r.minUnixTimestamp, "form", "")
	} else {
        var defaultValue int64 = 1763596800
        parameterAddToHeaderOrQuery(localVarQueryParams, "min_unix_timestamp", defaultValue, "form", "")
        r.minUnixTimestamp = &defaultValue
	}
	if r.maxUnixTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_unix_timestamp", r.maxUnixTimestamp, "form", "")
	}
	if r.minDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_s", r.minDurationS, "form", "")
	}
	if r.maxDurationS != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_s", r.maxDurationS, "form", "")
	}
	if r.isHighSkillRangeParties != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_high_skill_range_parties", r.isHighSkillRangeParties, "form", "")
	}
	if r.isLowPriPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_low_pri_pool", r.isLowPriPool, "form", "")
	}
	if r.isNewPlayerPool != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_new_player_pool", r.isNewPlayerPool, "form", "")
	}
	if r.minMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_match_id", r.minMatchId, "form", "")
	}
	if r.maxMatchId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_match_id", r.maxMatchId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMmrHistoryRequest struct {
	ctx context.Context
	ApiService *MMRAPIService
	accountId int32
}

func (r ApiMmrHistoryRequest) Execute() ([]MMRHistory, *http.Response, error) {
	return r.ApiService.MmrHistoryExecute(r)
}

/*
MmrHistory MMR History

Player MMR History

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId The players `SteamID3`
 @return ApiMmrHistoryRequest
*/
func (a *MMRAPIService) MmrHistory(ctx context.Context, accountId int32) ApiMmrHistoryRequest {
	return ApiMmrHistoryRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []MMRHistory
func (a *MMRAPIService) MmrHistoryExecute(r ApiMmrHistoryRequest) ([]MMRHistory, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MMRHistory
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MMRAPIService.MmrHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/players/{account_id}/mmr-history"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId < 0 {
		return localVarReturnValue, nil, reportError("accountId must be greater than 0")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
